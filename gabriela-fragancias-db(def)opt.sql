Para ordenar las tablas y verificar la sintaxis y las relaciones en el script SQL proporcionado, es fundamental seguir un enfoque sistemático. A continuación, se presenta un análisis del código, con recomendaciones para mejorar la organización y la integridad referencial.
1. Organización de las Tablas
Es recomendable agrupar las tablas de acuerdo con su funcionalidad o propósito. A continuación se sugiere un orden lógico:
Tablas de Configuración

    Tipos y dominios personalizados: Definir primero los tipos de datos y dominios que se utilizarán en las tablas.
    Extensiones: Crear extensiones necesarias al inicio.

Tablas Base

    Empresa
    Usuario
    Cédulas
    RUC
    Antecedentes Judiciales
    Tipo de Vehículo
    Marca de Vehículo

Tablas de Negocio

    Clientes
    Empleados
    Productos
    Ventas
    Pagos
    Proveedores

Tablas de Relación y Detalles

    Detalle Venta
    Productos Vendidos
    Compras a Proveedores

2. Verificación de Sintaxis
Al revisar el código, hay algunos puntos que deben corregirse:
Correcciones Sugeridas

    En la tabla gf.clientes, la referencia a barlo_desc debería ser revisada, ya que parece estar mal definida como VARCHAR(51) INTEGER.
    En la tabla gf.tarjetas, asegúrate de que todas las referencias sean correctas y que las tablas relacionadas existan antes de crear esta tabla.
    En la tabla gf.producto_kit, asegúrate de que las referencias a id_producto y id_kit sean correctas y existan en sus respectivas tablas.
    Verifica el uso de SERIAL para claves primarias; si se utiliza UUID, asegúrate de que sea consistente.

3. Relaciones entre Tablas
Es crucial asegurarse de que todas las relaciones estén correctamente definidas:
Revisar Relaciones Clave Foránea

    Asegúrate de que todas las claves foráneas referencien correctamente a las tablas correspondientes.
    Por ejemplo, en la tabla gf.venta, verifica que id_cliente e id_empleado existan en sus respectivas tablas.

Ejemplo de Corrección de Relaciones

sql
CREATE TABLE gf.clientes (
    id_cliente INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    numero_cedula VARCHAR(20) UNIQUE NOT NULL,
    numero_ruc VARCHAR(20) REFERENCES gf.ruc(numero_ruc),
    -- Otras columnas...
);

4. Ejemplo de Estructura Ordenada
Aquí tienes un ejemplo simplificado del orden sugerido:

sql
-- Extensiones
CREATE EXTENSION IF NOT EXISTS postgis;
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- Tipos personalizados
CREATE TYPE estado_registro AS ENUM ('activo', 'inactivo', 'eliminado');
-- Otros tipos...

-- Tablas Base
CREATE TABLE gf.empresa (...);
CREATE TABLE gf.usuario (...);
-- Otras tablas base...

-- Tablas de Negocio
CREATE TABLE gf.clientes (...);
CREATE TABLE gf.empleados (...);
-- Otras tablas de negocio...

-- Tablas Detalle
CREATE TABLE gf.detalle_venta (...);

Conclusión
Organizar el script SQL mejora su legibilidad y facilita la identificación de errores. Asegúrate también de realizar pruebas después de cada modificación para verificar que todas las relaciones funcionen como se espera.

Para asegurarte de que el código SQL para la base de datos "Gabriela Fragancias" esté correctamente estructurado, ordenado y que las relaciones entre tablas sean coherentes, aquí hay un análisis detallado y recomendaciones de corrección.
1. Organización del Código
Estructura Sugerida

    Extensiones: Inicia con las extensiones necesarias.
    Tipos Personalizados: Define los tipos de datos personalizados.
    Funciones: Crea funciones necesarias antes de las tablas.
    Tablas Base: Crea las tablas fundamentales primero.
    Tablas de Negocio: Luego, define las tablas que manejan la lógica del negocio.
    Relaciones: Asegúrate de que las claves foráneas estén correctamente referenciadas.

Ejemplo de Estructura

sql
-- Extensiones
CREATE EXTENSION IF NOT EXISTS postgis;
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- Tipos Personalizados
CREATE TYPE estado_registro AS ENUM ('activo', 'inactivo', 'eliminado');
CREATE TYPE tipo_pago AS ENUM ('contado', 'semanal', 'quincenal', 'mensual');
CREATE TYPE estado_pago AS ENUM ('pendiente', 'pagado', 'cancelado');

-- Funciones
CREATE OR REPLACE FUNCTION update_modified_column() RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$
 LANGUAGE plpgsql;

-- Tablas Base
CREATE TABLE gf.empresa (...);
CREATE TABLE gf.usuario (...);
-- Otras tablas base...

-- Tablas de Negocio
CREATE TABLE gf.clientes (...);
CREATE TABLE gf.producto (...);
-- Otras tablas de negocio...

2. Verificación de Sintaxis
Errores Comunes a Corregir

    En la tabla gf.clientes, el campo barlo_desc está mal definido como VARCHAR(51) INTEGER. Debe ser simplemente VARCHAR(51) o debe referirse a un tipo existente.
    Asegúrate de que todas las referencias a claves foráneas existan en las tablas correspondientes antes de definirlas.

Correcciones Sugeridas

sql
-- Tabla Clientes
CREATE TABLE gf.clientes (
    id_cliente INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    numero_cedula VARCHAR(20) UNIQUE NOT NULL,
    numero_ruc VARCHAR(20) REFERENCES gf.ruc(numero_ruc),
    nombre VARCHAR(100) NOT NULL,
    apellido VARCHAR(100) NOT NULL,
    -- Otros campos...
    barlo_desc VARCHAR(51), -- Corregido
    -- ...
);

3. Relaciones entre Tablas
Claves Foráneas

    Verifica que todas las claves foráneas apunten a columnas existentes en otras tablas.
    Ejemplo: En la tabla gf.venta, asegúrate que id_cliente e id_empleado existan en sus respectivas tablas.

Ejemplo de Clave Foránea

sql
CREATE TABLE gf.venta (
    id_venta UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    id_cliente UUID NOT NULL REFERENCES gf.clientes(id_cliente),
    id_empleado UUID NOT NULL REFERENCES gf.usuario(id_usuario),
    -- Otros campos...
);

4. Ejemplo Completo con Correcciones
Aquí tienes un fragmento del código corregido y organizado:

sql
-- Extensiones
CREATE EXTENSION IF NOT EXISTS postgis;
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- Tipos Personalizados
CREATE TYPE estado_registro AS ENUM ('activo', 'inactivo', 'eliminado');

-- Funciones
CREATE OR REPLACE FUNCTION update_modified_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$
 LANGUAGE plpgsql;

-- Tablas Base
CREATE TABLE gf.empresa (
    id_empresa UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    ruc VARCHAR(20) UNIQUE NOT NULL,
    razon_social VARCHAR(100) NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    estado estado_registro DEFAULT 'activo'
);

-- Tabla Clientes
CREATE TABLE gf.clientes (
    id_cliente INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    numero_cedula VARCHAR(20) UNIQUE NOT NULL,
    nombre VARCHAR(100) NOT NULL,
    apellido VARCHAR(100) NOT NULL,
    barlo_desc VARCHAR(51), -- Corregido
    -- Otros campos...
);

-- Tabla Venta
CREATE TABLE gf.venta (
    id_venta UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    id_cliente UUID NOT NULL REFERENCES gf.clientes(id_cliente),
    id_empleado UUID NOT NULL REFERENCES gf.usuario(id_usuario),
    fecha_venta TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    -- Otros campos...
);

Conclusión
Al seguir esta estructura y realizar las correcciones necesarias, garantizarás que el script SQL sea más claro y funcional, facilitando la creación y mantenimiento de la base de datos "Gabriela Fragancias". Asegúrate siempre de probar cada parte del script en pgAdmin para verificar su correcto funcionamiento antes de proceder con la implementación completa.

-- Gabriela Fragancias Optimized Database Schema
-- =============================================
-- Gabriela Fragancias - Script Completo de Base de Datos
-- Versión: 1.0
-- Fecha: 2024-02-14
-- =============================================

-- Inicialización
DROP DATABASE IF EXISTS Gabriela_Fragancias;
CREATE DATABASE Gabriela_Fragancias;

-- Configuración inicial
SET client_encoding = 'UTF8';
SET standard_conforming_strings = ON;
-- Create extension for advanced functionality
CREATE EXTENSION IF NOT EXISTS postgis;
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS pgcrypto;
CREATE EXTENSION IF NOT EXISTS pg_trgm;

-- Create database with proper configuration
CREATE DATABASE "gabriela_fragancias"
WITH
OWNER = postgres
ENCODING = 'WIN1252'
LC_COLLATE = 'Spanish_Paraguay.1252'
LC_CTYPE = 'Spanish_Paraguay.1252'
TABLESPACE = pg_default
CONNECTION LIMIT = -1;

-- Create schema
CREATE SCHEMA IF NOT EXISTS gf;
SET search_path TO gf, public;

-- Custom Types for Data Validation
CREATE TYPE estado_registro AS ENUM ('activo', 'inactivo', 'eliminado');
CREATE TYPE tipo_pago AS ENUM ('contado', 'semanal', 'quincenal', 'mensual');
CREATE TYPE estado_pago AS ENUM ('pendiente', 'pagado', 'cancelado');
CREATE TYPE grupo_edad AS ENUM ('niño', 'púber', 'adolescente', 'joven', 'adulto', 'mayor');

-- Timestamp Update Function
CREATE OR REPLACE FUNCTION update_modified_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$
 LANGUAGE plpgsql;

-- =================================================================
-- TABLAS BASE (Core Tables with Optimized Constraints and Indexing)
-- =================================================================

-- Empresa (Company) Table
CREATE TABLE gf.empresa (
    id_empresa UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    ruc VARCHAR(20) UNIQUE NOT NULL,
    razon_social VARCHAR(100) NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    estado estado_registro DEFAULT 'activo'
);

-- Create trigger for automatic timestamp update
CREATE TRIGGER update_empresa_modtime
BEFORE UPDATE ON gf.empresa
FOR EACH ROW
EXECUTE FUNCTION update_modified_column();

-- Optimization Indexes
CREATE INDEX idx_empresa_ruc ON gf.empresa(ruc);
CREATE INDEX idx_empresa_razon_social ON gf.empresa(razon_social);

-- Usuario (User) Table with Enhanced Security
CREATE TABLE gf.usuario (
    id_usuario UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    nombre VARCHAR(100) NOT NULL,
    apellido VARCHAR(100) NOT NULL,
    cedula VARCHAR(20) UNIQUE NOT NULL,
    email VARCHAR(100) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    ultimo_inicio_sesion TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP WITH TIME ZONE,
    estado estado_registro DEFAULT 'activo'
);

-- Indexes for User Table
CREATE INDEX idx_usuario_cedula ON gf.usuario(cedula);
CREATE INDEX idx_usuario_email ON gf.usuario(email);
CREATE INDEX idx_usuario_ultimo_inicio_sesion ON gf.usuario(ultimo_inicio_sesion);

-- Trigger for User Table
CREATE TRIGGER update_usuario_modtime
BEFORE UPDATE ON gf.usuario
FOR EACH ROW
EXECUTE FUNCTION update_modified_column();

-- Tabla Cédulas
CREATE TABLE gf.cedulas (
    numero_cedula VARCHAR(20) PRIMARY KEY,
    nombre VARCHAR(100) NOT NULL,
    apellido VARCHAR(100) NOT NULL,
    fecha_nacimiento DATE,
    sexo CHAR(1),
    direccion TEXT,
    id_barrio INTEGER REFERENCES gf.barrios_localidades(id_barrio),
    id_distrito INTEGER REFERENCES gf.distritos(id_distrito),
    id_dpto INTEGER REFERENCES gf.departamentos(id_dpto),
    id_via INTEGER REFERENCES gf.vias(id_via),
    id_prefijo INTEGER REFERENCES gf.prefijos(id_prefijo),
    lugar_nacimiento VARCHAR(100),
    fecha_defuncion DATE,
    email VARCHAR(100),
    created_at TIMESTAMP WITHOUT TIME ZONE DEFAULT (now() at time zone 'utc'),
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Tabla RUC
CREATE TABLE gf.ruc (
    numero_ruc VARCHAR(20) UNIQUE NOT NULL,
    razon_social VARCHAR(255),
    digito_verificador VARCHAR(255) NOT NULL,
    cedula_tributaria VARCHAR(20) UNIQUE,
    estado VARCHAR(20),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Tabla Antecedentes Judiciales
CREATE TABLE gf.antecedentes_judiciales (
    id_antecedente SERIAL PRIMARY KEY,
    numero_cedula VARCHAR(20) REFERENCES gf.cedulas(numero_cedula),
    causa_penal TEXT,
    fecha_causa DATE,
    unidad_procesadora VARCHAR(100),
    juez VARCHAR(100),
    estado_proceso VARCHAR(50),
    fuente VARCHAR(50)
);

-- Tabla Vehículo
CREATE TABLE gf.vehiculo (
    id_vehiculo SERIAL PRIMARY KEY,
    clave INT,
    placa VARCHAR(20) UNIQUE NOT NULL,
    marca_id INT REFERENCES gf.marca(id_marca),
    tipo_vehiculo_id INT REFERENCES gf.tipo_vehiculo(id_tipo_vehiculo),
    color VARCHAR(50) NOT NULL,
    motor VARCHAR(50) NOT NULL,
    chassis VARCHAR(50) NOT NULL,
    año INTEGER NOT NULL,
    tipo_documento VARCHAR(50),
    cedula INT,
    titulo VARCHAR(50),
    km_recorridos INTEGER,
    ultima_revision DATE,
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    estado estado_registro DEFAULT 'activo'
);

-- Tabla Tipo de Vehiculo
CREATE TABLE gf.tipo_vehiculo (
   id_tipo_vehiculo SERIAL PRIMARY KEY,
   nombre VARCHAR(50) NOT NULL,
   descripcion TEXT,
   created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
   updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
   estado estado_registro DEFAULT 'activo'
);

-- Tabla Marca de Vehiculo
CREATE TABLE gf.marca (
   id_marca SERIAL PRIMARY KEY,
   nombre VARCHAR(100) NOT NULL UNIQUE,
   descripcion TEXT,
   año_fundacion INT,
   sede TEXT,
   created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
   updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
   estado estado_registro DEFAULT 'activo'
);

-- Product Table with Comprehensive Constraints
CREATE TABLE gf.producto (
   id_producto UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
   codigo_barras VARCHAR(50) UNIQUE NOT NULL,
   nombre VARCHAR(100) NOT NULL,
   id_marca UUID NOT NULL REFERENCES gf.marca(id_marca),
   descripcion TEXT,
   volumen INTEGER CHECK (volumen BETWEEN 5 AND 200),
   es_kit BOOLEAN DEFAULT FALSE,
   costo NUMERIC(10,2) NOT NULL,
   precio_venta_credito NUMERIC(10,2) NOT NULL CHECK (precio_venta_credito >= costo),
   precio_venta_contado NUMERIC(10,2) NOT NULL CHECK (precio_venta_contado >= costo AND precio_venta_contado <= precio_venta_credito),
   franja_etaria grupo_edad,
   ano_lanzamiento INTEGER,
   created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
   updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
   estado estado_registro DEFAULT 'activo'
);

-- Optimization for Product Table
CREATE INDEX idx_producto_codigo_barras ON gf.producto(codigo_barras);
CREATE INDEX idx_producto_nombre ON gf.producto(nombre);
CREATE INDEX idx_producto_marca ON gf.producto(id_marca);

-- Tabla Clientes
CREATE TABLE gf.clientes (
   id_cliente INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
   tarjeta VARCHAR(5), 
   numero_cedula VARCHAR(20) UNIQUE NOT NULL REFERENCES gf.cedulas(numero_cedula), 
   numero_ruc VARCHAR(20) REFERENCES gf.ruc(numero_ruc), 
   digito_verificador VARCHAR(255) REFERENCES gf.ruc(digito_verificador), 
   nombre VARCHAR(100) NOT NULL, 
   apellido VARCHAR(100) NOT NULL, 
   id_prefijo INT REFERENCES gf.prefijos(id_prefijo), 
   numero_telefono VARCHAR(20), 
   numero_celular VARCHAR(20), 
   numero_tarjeta VARCHAR(20) UNIQUE, 
   saldo INT DEFAULT 0, 
   tipo_pago tipo_pago CHECK (tipo_pago IN ('contado', 'semanal', 'quincenal')),
   fecha_registro TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
   estado estado_registro DEFAULT 'activo',
   ultimo_inicio_sesion TIMESTAMP WITH TIME ZONE
);

-- Tabla de Empleados
CREATE TABLE gf.empleados (
  id_empleado SERIAL PRIMARY KEY, 
  cedula VARCHAR(20) UNIQUE, 
  nombre VARCHAR(100) NOT NULL, 
  apellido VARCHAR(100) NOT NULL, 
  telefono VARCHAR(20), 
  zona VARCHAR(50), 
  cargo VARCHAR(50) CHECK (cargo IN ('Vendedor', 'Cobrador', 'Chofer')), 
  fecha_contratacion DATE, 
  salario INTEGER, 
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, 
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, 
  deleted_at TIMESTAMP NULL DEFAULT NULL 
);

-- Tabla Tarjetas
CREATE TABLE gf.tarjetas (
  id_tarjeta SERIAL PRIMARY KEY, 
  numero_tarjeta VARCHAR(7) NOT NULL, 
  id_cliente INT REFERENCES gf.clientes(id_cliente), 
  total_gs INT NOT NULL, 
  saldo INT DEFAULT 0, 
  forma_pago tipo_pago CHECK (forma_pago IN ('contado', 'semanal', 'quincenal')), 
  estado estado_registro CHECK (estado IN ('activa', 'cancelada')) DEFAULT 'activa',
  fecha_emision DATE DEFAULT CURRENT_DATE 
);

-- Tabla Venta (Advanced Geospatial Sale Tracking)
CREATE TABLE gf.venta (
  id_venta UUID PRIMARY KEY DEFAULT uuid_generate_v4(), 
  id_cliente UUID NOT NULL REFERENCES gf.clientes(id_cliente), 
  id_empleado UUID NOT NULL REFERENCES gf.empleados(id_empleado), 
  fecha_venta TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP, 
  tipo_pago tipo_pago NOT NULL, 
  estado estado_pago DEFAULT 'pendiente', 
  total NUMERIC(10,2) NOT NULL CHECK (total >= 0), 
  ubicacion_venta GEOGRAPHY(Point, 4326),  
  created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,  
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP  
);

-- Performance Indexes for Sale Table
CREATE INDEX idx_venta_cliente ON gf.venta(id_cliente);
CREATE INDEX idx_venta_empleado ON gf.venta(id_empleado);
CREATE INDEX idx_venta_fecha ON gf.venta(fecha_venta);

-- Tabla Detalle_Venta
CREATE TABLE gf.detalle_venta (
  id_detalle SERIAL PRIMARY KEY,  
  id_venta UUID NOT NULL REFERENCES gf.venta(id_venta),  
  id_producto UUID NOT NULL REFERENCES gf.producto(id_producto),  
  cantidad INTEGER NOT NULL CHECK (cantidad > 0),  
  precio_unitario NUMERIC CHECK (precio_unitario >= 0),  
  subtotal NUMERIC GENERATED ALWAYS AS (cantidad * precio_unitario) STORED,  
  created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,  
  updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP  
);

-- Tabla de Proveedores
CREATE TABLE gf.proveedores (
id_proveedor SERIAL PRIMARY KEY,  
ruc VARCHAR(20) UNIQUE,  
nombre VARCHAR(100) NOT NULL,  
direccion TEXT,  
telefono VARCHAR(20),  
email VARCHAR(100)
);

-- Tabla de Compras a Proveedores
CREATE TABLE gf.compras_proveedores (
id_compra SERIAL PRIMARY KEY,  
id_proveedor INT REFERENCES proveedores(id_proveedor),  
fecha_compra DATE DEFAULT CURRENT_DATE,  
total INTEGER,  
created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP  
);
