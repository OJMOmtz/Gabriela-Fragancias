Análisis del Esquema de Base de Datos Gabriela Fragancias
Aspectos Positivos

Estructura General

Buena organización con schema gf
Uso apropiado de PostGIS para datos geoespaciales
Buenos tipos ENUM para datos enumerados
Implementación correcta de soft delete con deleted_at
Manejo adecuado de timestamps con created_at y updated_at


Normalización

Buena separación de entidades (Cliente, Empleado heredando de Persona)
Normalización adecuada en productos y kits
Buena normalización de ubicaciones geográficas


Índices y Optimización

Buenos índices espaciales
Índices apropiados en claves foráneas
Índices en campos de búsqueda frecuente


Seguridad y Validación

Buenas restricciones CHECK
Validaciones de formato para email y cédula
Manejo de estados con ENUM



Problemas Identificados y Recomendaciones
1. Inconsistencias en Sintaxis
sql

--Creación de la Base de Datos
CREATE DATABASE Gabriela_Fragancias;

--Tabla Empresa
CREATE TABLE gf.empresa (
    id_empresa SERIAL PRIMARY KEY,
    ruc VARCHAR(20) UNIQUE NOT NULL,
    razon_social VARCHAR(100) NOT NULL
);

-- Tabla Usuario
CREATE TABLE gf.usuario (
    id_usuario SERIAL PRIMARY KEY,
    nombre_usuario VARCHAR(100) NOT NULL,
    contrasena VARCHAR(100) NOT NULL,
    rol VARCHAR(50) NOT NULL
);

--Tabla Cédulas
CREATE TABLE gf.cedulas (
    numero_cedula VARCHAR(20) UNIQUE NOT NULL, --(debe ser la primary key)
    nombre VARCHAR(100) NOT NULL,
    apellido VARCHAR(100) NOT NULL,
    fecha_nacimiento DATE,
	sexo CHAR(1),
    direccion TEXT,
	lugar_nacimiento VARCHAR(100),
    telefono VARCHAR(20),
    fecha_defuncion DATE,
    email VARCHAR(100),
    id_ruc INTEGER REFERENCES ruc(ruc_id),
    created_at TIMESTAMP WITHOUT TIME ZONE DEFAULT (now() at time zone 'utc'),
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

--Tabla RUC
CREATE TABLE ruc (
    numero_ruc VARCHAR(20) UNIQUE NOT NULL,
    razon_social VARCHAR(255),
    digito_verificador VARCHAR(255) NOT NULL,
    cedula_tributaria VARCHAR(20) UNIQUE,
    estado VARCHAR(20),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

1000000	CAÑETE GONZALEZ, JUANA DEL CARMEN	3	CAGJ761720E	ACTIVO
1000001	CHIR DE LOPEZ, RAQUEL	1	CIAR6422903	ACTIVO
1000004	MOLINA DE TROCHE, SANDRA ELIZABETH	6	MOTS763530	SUSPENSION TEMPORAL
1000006	VILLASANTTI  ACOSTA, MAURICIO	2	VIAM6519216	CANCELADO
1000007	ROMERO GOMEZ, ALFREDO	0	ROGA652940D	CANCELADO
1000009	GONZALEZ FERNANDEZ, ROBERTO TRIGIDIO	7	GOFR651540U	ACTIVO

CREATE TABLE empresas_ruc (
    id_ruc SERIAL PRIMARY KEY,
    razon_social VARCHAR(255),
    numero_ruc VARCHAR(20) UNIQUE NOT NULL,
    digito_verificador INTEGER NOT NULL,
    estado VARCHAR(20) CHECK (estado IN ('activo', 'inactivo', 'suspendido')),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

--Tabla Antecedentes Judiciales
CREATE TABLE gf.antecedentes_judiciales (
    id_antecedente SERIAL PRIMARY KEY,
    numero_cedula VARCHAR(20) REFERENCES gf.cedulas(numero_cedula),
    causa_penal TEXT,
    fecha_causa DATE,
    unidad_procesadora VARCHAR(100),
    juez VARCHAR(100),
    estado_proceso VARCHAR(50),
    fuente VARCHAR(50)
);

Estructura del archivo D:/PADRONES/Automotores\cap001.dbf:
Columnas:
    CIDCAP Numeric(11)
    ORDEN Numeric(5)
    CLAVE Numeric(9)
    CAUSA VARCHAR(50)
    UNIDAD Numeric(11)
    FECNOTA Numeric(11) (DDMMAAAA)
    JUEZ VARCHAR(30)
    ESTADO VARCHAR(4)
 Campos: 29
Largo: 350
Total Filas: 318507
Tamaño: 111478675

--Tabla Zonas
CREATE TABLE Zonas (
    id_zona SERIAL PRIMARY KEY,
    nombre_zona VARCHAR(100) NOT NULL UNIQUE,
	dia_visita VARCHAR (12),
    geom GEOGRAPHY(POLYGON, 4326)
);

-- Tabla Clientes (con mejoras)
CREATE TABLE Clientes (
    id_cliente INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    tarjeta VARCHAR(7) UNIQUE NOT NULL,
    numero_cedula VARCHAR(20) UNIQUE NOT NULL,
    nombre VARCHAR(100) NOT NULL,
    apellido VARCHAR(100) NOT NULL,
    id_prefijo INTEGER REFERENCES prefijos(id_prefijo),
    id_direccion INTEGER REFERENCES direcciones(id_direccion),
    direccion GEOGRAPHY(POINT, 4326),
    numero_telefono VARCHAR(20),
    numero_tarjeta VARCHAR(20) UNIQUE,
    saldo INTEGER DEFAULT 0,
    tipo_pago VARCHAR(20) CHECK (tipo_pago IN ('SEM', 'QUIN', 'MENS')),
    fecha_registro TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    estado VARCHAR(20) CHECK (estado IN ('activo', 'inactivo')) DEFAULT 'activo',
    ultimo_inicio_sesion TIMESTAMP WITH TIME ZONE
);

--Tabla Prefijos
CREATE TABLE gf.prefijos (
    id_prefijo SERIAL PRIMARY KEY,
    prefijo VARCHAR(4) UNIQUE NOT NULL,
    descripcion VARCHAR(50)
);

961;HOLA PARAGUAY-VOX;
971;PERSONAL;
972;PERSONAL;
973;PERSONAL;
975;PERSONAL;
976;PERSONAL;
981;TELECEL-TIGO;
982;TELECEL-TIGO;
983;TELECEL-TIGO;
984;TELECEL-TIGO;
985;TELECEL-TIGO;
991;AMX MOVIL CLARO;
992;AMX MOVIL CLARO;
993;AMX MOVIL CLARO;
995;AMX MOVIL CLARO;

INSERT INTO gf.prefijos (prefijo, descripcion) 
VALUES 
    ('+595961', 'HOLA PARAGUAY-VOX'),
    ('+595971', 'PERSONAL'),
    ('+595972', 'PERSONAL'),
    ('+595973', 'PERSONAL'),
    ('+595975', 'PERSONAL'),
    ('+595976', 'PERSONAL'),
    ('+595981', 'TELECEL-TIGO'),
    ('+595982', 'TELECEL-TIGO'),
    ('+595983', 'TELECEL-TIGO'),
    ('+595984', 'TELECEL-TIGO'),
    ('+595985', 'TELECEL-TIGO'),
    ('+595991', 'AMX MOVIL CLARO'),
    ('+595992', 'AMX MOVIL CLARO'),
    ('+595993', 'AMX MOVIL CLARO'),
    ('+595995', 'AMX MOVIL CLARO');

-- Tabla Marcas
CREATE TABLE Marcas (
    id_marca SERIAL PRIMARY KEY,
    nombre VARCHAR(100) UNIQUE NOT NULL,
    año_fundacion INT
);

-- Tabla Productos
CREATE TABLE Productos (
    id_producto SERIAL PRIMARY KEY,
    codigo_barras VARCHAR(50) UNIQUE NOT NULL,
    nombre VARCHAR(100) NOT NULL,
    id_marca INTEGER REFERENCES Marcas(id_marca),
    precio_contado DECIMAL(10, 2) NOT NULL,
    precio_credito DECIMAL(10, 2) NOT NULL,
    stock INTEGER NOT NULL,
    descripcion TEXT,
    presentacion VARCHAR(50),
    volumen INT CHECK (volumen BETWEEN 5 AND 200),
    es_kit BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

--Tabla Vendedores
CREATE TABLE Vendedores (
    id_vendedor SERIAL PRIMARY KEY,
    nombre VARCHAR(100) NOT NULL,
    zona VARCHAR(50) NOT NULL,
    comision DECIMAL(10, 2) DEFAULT 50000
);

--Tabla Tarjetas
CREATE TABLE Tarjetas (
    id_tarjeta SERIAL PRIMARY KEY,
    numero_tarjeta VARCHAR(7) NOT NULL,
    id_cliente INTEGER REFERENCES Clientes(id_cliente),
    id_vendedor INTEGER REFERENCES Vendedores(id_vendedor),
    id_zona INTEGER REFERENCES Zonas(id_zona),
    total_gs DECIMAL(10, 2) NOT NULL,
    saldo DECIMAL(10, 2) DEFAULT 0,
    forma_pago VARCHAR(20) CHECK (forma_pago IN ('SEM', 'QUIN', 'MENS')),
    estado VARCHAR(20) CHECK (estado IN ('activa', 'cancelada')) DEFAULT 'activa',
    fecha_emision DATE DEFAULT CURRENT_DATE,
    id_tarjeta_anterior INTEGER REFERENCES Tarjetas(id_tarjeta)
);

--Tabla de Productos
CREATE TABLE Productos (
    id_producto SERIAL PRIMARY KEY,
    nombre VARCHAR(100) NOT NULL,
    codigo_barras VARCHAR(13) UNIQUE NOT NULL,
    precio_costo DECIMAL(10, 2),
    precio_venta DECIMAL(10, 2),
    stock INTEGER DEFAULT 0,
    descripcion TEXT
);

--Tabla Productos Vendidos
CREATE TABLE Productos_Vendidos (
    id_producto_vendido SERIAL PRIMARY KEY,
    id_tarjeta INTEGER REFERENCES Tarjetas(id_tarjeta),
    id_producto INTEGER REFERENCES Productos(id_producto),
    cantidad INTEGER CHECK (cantidad > 0),
    precio DECIMAL(10, 2)
);

--Tabla Pagos
CREATE TABLE Pagos (
    id_pago SERIAL PRIMARY KEY,
    id_tarjeta INTEGER REFERENCES Tarjetas(id_tarjeta),
    fecha_pago DATE DEFAULT CURRENT_DATE,
    monto DECIMAL(10, 2) NOT NULL,
    saldo_restante DECIMAL(10, 2) NOT NULL,
    entrega_inicial BOOLEAN DEFAULT FALSE,
    recargo BOOLEAN DEFAULT FALSE
);

--Tabla de Maletines
CREATE TABLE Maletines (
    id_maletin SERIAL PRIMARY KEY,
    id_vendedor INT REFERENCES Vendedores(id_vendedor),
    fecha_carga DATE DEFAULT CURRENT_DATE
);

--Tabla de Productos en Maletines: Vincula productos con maletines, especificando la cantidad de productos asignados.
CREATE TABLE Productos_Maletin (
	id_maletin INT REFERENCES Maletines(id_maletin),
	id_producto INT REFERENCES Productos(id_producto),
	cantidad INT NOT NULL,
	PRIMARY KEY (id_maletin, id_producto)
);

--Tabla de Liquidaciones
CREATE TABLE Liquidaciones (
	id_liquidacion SERIAL PRIMARY KEY,
	id_vendedor INT REFERENCES Vendedores(id_vendedor),
	fecha_liquidacion DATE DEFAULT CURRENT_DATE,
	total_ventas DECIMAL(10, 2),
	comision DECIMAL(10, 2),
	total_pagar DECIMAL(10, 2)
);


--Tabla de Inventario (Maletines de Productos)
CREATE TABLE Inventario (
    id_inventario SERIAL PRIMARY KEY,
    id_vendedor INTEGER REFERENCES Vendedores(id_vendedor),
    id_producto INTEGER REFERENCES Productos(id_producto),
    cantidad INTEGER NOT NULL
);

--Tabla de Vehículos
CREATE TABLE Vehiculos (
    id_vehiculo SERIAL PRIMARY KEY,
    placa VARCHAR(20) UNIQUE NOT NULL,
    marca VARCHAR(50),
    modelo VARCHAR(50),
    año INT,
    numero_motor VARCHAR(50) UNIQUE,
    numero_chasis VARCHAR(50) UNIQUE,
    km_recorridos DECIMAL(10, 2),
    fecha_revision DATE
);

CREATE TABLE direcciones (
    id_direccion SERIAL PRIMARY KEY,
    calle VARCHAR(100),
    numero VARCHAR(10),
    barrio VARCHAR(50),
    ciudad VARCHAR(50),
    codigo_postal VARCHAR(10),
    ubicacion GEOGRAPHY(POINT, 4326)
);

-- Tabla Rutas
CREATE TABLE rutas (
    id SERIAL PRIMARY KEY,
    id_vendedor INTEGER REFERENCES Vendedores(id_vendedor),
    id_vehiculo INTEGER REFERENCES vehiculos(id_vehiculo),
    fecha DATE NOT NULL,
    inicio_ruta GEOGRAPHY(POINT, 4326),
    fin_ruta GEOGRAPHY(POINT, 4326),
    distancia_km DECIMAL(10,2),
    tiempo_estimado INTEGER, -- minutos
    tiempo_real INTEGER,
    estado VARCHAR(20) CHECK (estado IN ('planificada', 'en_progreso', 'completada', 'cancelada')),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Tabla Puntos Ruta
CREATE TABLE puntos_ruta (
    id SERIAL PRIMARY KEY,
    ruta_id INTEGER REFERENCES rutas(id),
    id_cliente INTEGER REFERENCES clientes(id_cliente),
    orden INTEGER NOT NULL,
    hora_planificada TIME,
    hora_real TIME,
    ubicacion GEOGRAPHY(POINT, 4326),
    estado VARCHAR(20) CHECK (estado IN ('pendiente', 'visitado', 'no_visitado', 'reprogramado')),
    notas TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Tabla Log Actividad 
CREATE TABLE log_actividad(
    id SERIAL PRIMARY KEY,
    usuario_id INT REFERENCES Usuario(id_usuario),
    accion VARCHAR(50),
    tabla_afectada VARCHAR(50),
    registro_id INT,
    detalles JSONB,
    ip_address VARCHAR(45),
    create_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

gf.departamentos
03,CORDILLERA
04,GUAIRÁ
05,CAAGUAZÚ
09,PARAGUARÍ
10,ALTO PARANÁ
11,CENTRAL

gf.distritos
Zona 1
171,10,13,ALTO PARANÁ,SANTA RITA,1013
172,10,14,ALTO PARANÁ,NARANJAL,1014
176,10,18,ALTO PARANÁ,SAN ALBERTO,1018
179,10,21,ALTO PARANÁ,TAVAPY,1021
Zona 2
162,10,04,ALTO PARANÁ,DR. JUAN LEÓN MALLORQUÍN,1004
165,10,07,ALTO PARANÁ,JUAN E. O'LEARY,1007
167,10,09,ALTO PARANÁ,YGUAZÚ,1009
169,10,11,ALTO PARANÁ,MINGA GUAZÚ,1011
Zona 3
51,04,01,GUAIRÁ,VILLARRICA,0401
53,04,03,GUAIRÁ,CAPITÁN MAURICIO JOSÉ TROCHE,0403
56,04,06,GUAIRÁ,GRAL. EUGENIO A. GARAY,0406
61,04,11,GUAIRÁ,MBOCAYATY,0411
62,04,12,GUAIRÁ,NATALICIO TALAVERA,0412
65,04,15,GUAIRÁ,YATAITY,0415
Zona 4
185,11,05,CENTRAL,ITÁ,1105
143,09,01,PARAGUARÍ,PARAGUARÍ,0901
157,09,15,PARAGUARÍ,YAGUARÓN,0915
44,03,14,CORDILLERA,PIRIBEBUY,0314
Zona 5
69,05,01,CAAGUAZÚ,CORONEL OVIEDO,0501

Barrios_Localidades_Paraguay
Zona 1
10,13,ALTO PARANÁ,SANTA RITA,1,017,FRACCIÓN SNEIDER,1013017
10,13,ALTO PARANÁ,SANTA RITA,1,009,FRACCIÓN SHULTZ,1013009
10,13,ALTO PARANÁ,SANTA RITA,1,018,EL COLONO,1013018
10,13,ALTO PARANÁ,SANTA RITA,1,010,NUEVA SANTA RITA,1013010
10,13,ALTO PARANÁ,SANTA RITA,1,008,NUEVA ESPERANZA,1013008
10,13,ALTO PARANÁ,SANTA RITA,1,007,CENTRO,1013007
10,13,ALTO PARANÁ,SANTA RITA,1,019,SAN RAMÓN,1013019
10,13,ALTO PARANÁ,SANTA RITA,1,006,BELLA VISTA,1013006
10,13,ALTO PARANÁ,SANTA RITA,1,014,LOS TRIGALES,1013014
10,13,ALTO PARANÁ,SANTA RITA,1,011,BARRIO ALEJANDRINO,1013011
10,13,ALTO PARANÁ,SANTA RITA,1,005,ESQUINA GAUCHA,1013005
10,13,ALTO PARANÁ,SANTA RITA,1,004,UNIÓN,1013004
10,13,ALTO PARANÁ,SANTA RITA,1,020,JARDÍN AMERICA,1013020
10,13,ALTO PARANÁ,SANTA RITA,1,021,CARMELITAS,1013021
10,13,ALTO PARANÁ,SANTA RITA,1,002,SINUELO,1013002
10,13,ALTO PARANÁ,SANTA RITA,1,012,FRACCIÓN SANTA LUCÍA,1013012
10,13,ALTO PARANÁ,SANTA RITA,1,003,FRACCIÓN LA AMISTAD,1013003
10,13,ALTO PARANÁ,SANTA RITA,1,013,BUEN JESÚS,1013013
10,13,ALTO PARANÁ,SANTA RITA,1,001,PORTAL SINUELO,1013001
10,13,ALTO PARANÁ,SANTA RITA,1,015,FRACCIÓN SCALIA,1013015
10,13,ALTO PARANÁ,SANTA RITA,1,016,FRACCIÓN DEWES,1013016
10,13,ALTO PARANÁ,SANTA RITA,1,022,SAN JOSÉ,1013022
10,14,ALTO PARANÁ,NARANJAL,1,002,LAS PALMAS,1014002
10,14,ALTO PARANÁ,NARANJAL,1,001,CENTRO,1014001
10,18,ALTO PARANÁ,SAN ALBERTO,1,005,CENTRO,1018005
10,18,ALTO PARANÁ,SAN ALBERTO,1,004,8 DE DICIEMBRE,1018004
10,18,ALTO PARANÁ,SAN ALBERTO,1,006,SANTA MARÍA,1018006
10,18,ALTO PARANÁ,SAN ALBERTO,1,003,PORTAL,1018003
10,18,ALTO PARANÁ,SAN ALBERTO,1,007,BETARRAN,1018007
10,18,ALTO PARANÁ,SAN ALBERTO,1,002,SAN ALBERTO,1018002
10,18,ALTO PARANÁ,SAN ALBERTO,1,001,VILLA DEPORTIVA,1018001
10,21,ALTO PARANÁ,TAVAPY,1,002,SAN JOSÉ,1021002
10,21,ALTO PARANÁ,TAVAPY,1,001,SAN ANTONIO,1021001
10,21,ALTO PARANÁ,TAVAPY,1,003,CENTRO,1021003
10,21,ALTO PARANÁ,TAVAPY,1,005,SAN RAMÓN,1021005
10,21,ALTO PARANÁ,TAVAPY,1,006,SANTA CATALINA,1021006
10,21,ALTO PARANÁ,TAVAPY,1,004,SAN ROQUE,1021004
Zona 2
10,04,ALTO PARANÁ,DR. JUAN LEÓN MALLORQUÍN,1,001,SAN ANTONIO,1004001
10,04,ALTO PARANÁ,DR. JUAN LEÓN MALLORQUÍN,1,004,INMACULADA,1004004
10,04,ALTO PARANÁ,DR. JUAN LEÓN MALLORQUÍN,1,005,SANTA LIBRADA,1004005
10,04,ALTO PARANÁ,DR. JUAN LEÓN MALLORQUÍN,1,003,SANTA ROSA,1004003
10,04,ALTO PARANÁ,DR. JUAN LEÓN MALLORQUÍN,1,002,SAN FRANCISCO,1004002
10,07,ALTO PARANÁ,JUAN E. O'LEARY,1,008,EL PROGRESO,1007008
10,07,ALTO PARANÁ,JUAN E. O'LEARY,1,009,LA CANDELARIA,1007009
10,07,ALTO PARANÁ,JUAN E. O'LEARY,1,007,VIRGEN INMACULADA CONCEPCIÓN,1007007
10,07,ALTO PARANÁ,JUAN E. O'LEARY,1,005,CENTRO,1007005
10,07,ALTO PARANÁ,JUAN E. O'LEARY,1,003,SANTA ROSA,1007003
10,07,ALTO PARANÁ,JUAN E. O'LEARY,1,006,SAN ISIDRO,1007006
10,07,ALTO PARANÁ,JUAN E. O'LEARY,1,002,SAN RAFAEL,1007002
10,07,ALTO PARANÁ,JUAN E. O'LEARY,1,004,SAN ANTONIO,1007004
10,09,ALTO PARANÁ,YGUAZÚ,1,002,VIRGEN DE CAACUPÉ,1009002
10,09,ALTO PARANÁ,YGUAZÚ,1,003,SAN ISIDRO,1009003
10,09,ALTO PARANÁ,YGUAZÚ,1,004,SAN BLAS,1009004
10,09,ALTO PARANÁ,YGUAZÚ,1,001,CENTRO URBANO,1009001
10,09,ALTO PARANÁ,YGUAZÚ,1,006,SAN MIGUEL,1009006
10,09,ALTO PARANÁ,YGUAZÚ,1,005,SAN VALENTÍN,1009005
10,11,ALTO PARANÁ,MINGA GUAZÚ,1,029,SANTA MONICA,1011029
10,11,ALTO PARANÁ,MINGA GUAZÚ,1,013,CONAVI,1011013
10,11,ALTO PARANÁ,MINGA GUAZÚ,1,015,FRACCIÓN SANTA TERESA,1011015
10,11,ALTO PARANÁ,MINGA GUAZÚ,1,030,FRACCIÓN NORMA LUISA,1011030
10,11,ALTO PARANÁ,MINGA GUAZÚ,1,031,YHAGUY,1011031
10,11,ALTO PARANÁ,MINGA GUAZÚ,1,022,FRACCIÓN SAN MIGUEL,1011022
10,11,ALTO PARANÁ,MINGA GUAZÚ,1,023,FRACCIÓN GUARANI,1011023
10,11,ALTO PARANÁ,MINGA GUAZÚ,1,017,SAN ROQUE,1011017
10,11,ALTO PARANÁ,MINGA GUAZÚ,1,016,FRACCIÓN LAS GARDENIAS,1011016
10,11,ALTO PARANÁ,MINGA GUAZÚ,1,018,MONTE LINDO,1011018
10,11,ALTO PARANÁ,MINGA GUAZÚ,1,020,ÑAHATY,1011020
10,11,ALTO PARANÁ,MINGA GUAZÚ,1,021,CAMPO VERDE,1011021
10,11,ALTO PARANÁ,MINGA GUAZÚ,1,019,CALLE 16 MONDAY,1011019
10,11,ALTO PARANÁ,MINGA GUAZÚ,1,001,KAVURE'I,1011001
10,11,ALTO PARANÁ,MINGA GUAZÚ,1,006,CALLE 16 ACARAY,1011006
10,11,ALTO PARANÁ,MINGA GUAZÚ,1,002,ZONA GRANJA MI ABUELA,1011002
10,11,ALTO PARANÁ,MINGA GUAZÚ,1,003,FRACCIÓN SCHNEIDER II,1011003
10,11,ALTO PARANÁ,MINGA GUAZÚ,1,007,SAN ANTONIO,1011007
10,11,ALTO PARANÁ,MINGA GUAZÚ,1,008,CENTRO,1011008
10,11,ALTO PARANÁ,MINGA GUAZÚ,1,005,DOMINGO SAVIO,1011005
10,11,ALTO PARANÁ,MINGA GUAZÚ,1,010,MARÍA AUXILIADORA,1011010
10,11,ALTO PARANÁ,MINGA GUAZÚ,1,009,VILLA NÉLIDA,1011009
10,11,ALTO PARANÁ,MINGA GUAZÚ,1,014,JARDÍN DEL ORIENTE,1011014
10,11,ALTO PARANÁ,MINGA GUAZÚ,1,024,FRACCIÓN MARÍA LÍA,1011024
10,11,ALTO PARANÁ,MINGA GUAZÚ,1,028,FRACCIÓN LOS ÁLAMOS,1011028
10,11,ALTO PARANÁ,MINGA GUAZÚ,1,011,FRACCIÓN LAS PALMERAS,1011011
10,11,ALTO PARANÁ,MINGA GUAZÚ,1,004,PA'I CORONEL,1011004
10,11,ALTO PARANÁ,MINGA GUAZÚ,1,012,CEDRALES,1011012
10,11,ALTO PARANÁ,MINGA GUAZÚ,1,025,FRACCIÓN LOS MINGUEROS,1011025
10,11,ALTO PARANÁ,MINGA GUAZÚ,1,026,SAN BERNARDO,1011026
10,11,ALTO PARANÁ,MINGA GUAZÚ,1,027,FRACCIÓN RESIDENCIAL JAZMÍN II,1011027

Zona 3
04,01,GUAIRÁ,VILLARRICA,1,002,YVAROTY,0401002
04,01,GUAIRÁ,VILLARRICA,1,005,CENTRO,0401005
04,01,GUAIRÁ,VILLARRICA,1,001,TUYUTIMI,0401001
04,01,GUAIRÁ,VILLARRICA,1,003,SAN MIGUEL,0401003
04,01,GUAIRÁ,VILLARRICA,1,009,YVYRA ROVY,0401009
04,01,GUAIRÁ,VILLARRICA,1,011,SALESIANO,0401011
04,01,GUAIRÁ,VILLARRICA,1,013,KURUSU FRANCISCO,0401013
04,01,GUAIRÁ,VILLARRICA,1,007,SANTA LIBRADA,0401007
04,01,GUAIRÁ,VILLARRICA,1,004,LOMAS VALENTÍNAS,0401004
04,01,GUAIRÁ,VILLARRICA,1,014,URBANO,0401014
04,01,GUAIRÁ,VILLARRICA,1,006,ESTACIÓN,0401006
04,01,GUAIRÁ,VILLARRICA,1,015,"ASENT. SINAI 1, 2 y 3",0401015
04,01,GUAIRÁ,VILLARRICA,1,012,CRISTO REY,0401012
04,01,GUAIRÁ,VILLARRICA,1,008,SANTA LUCÍA,0401008
04,01,GUAIRÁ,VILLARRICA,1,010,SAN BLAS,0401010
04,03,GUAIRÁ,CAPITÁN MAURICIO JOSÉ TROCHE,1,008,ALEGRE,0403008
04,03,GUAIRÁ,CAPITÁN MAURICIO JOSÉ TROCHE,1,002,VIRGEN DEL HUERTO,0403002
04,03,GUAIRÁ,CAPITÁN MAURICIO JOSÉ TROCHE,1,004,CENTRO,0403004
04,03,GUAIRÁ,CAPITÁN MAURICIO JOSÉ TROCHE,1,003,SAN MIGUEL,0403003
04,03,GUAIRÁ,CAPITÁN MAURICIO JOSÉ TROCHE,1,005,SANTA ROSA,0403005
04,03,GUAIRÁ,CAPITÁN MAURICIO JOSÉ TROCHE,1,006,SAN BLAS,0403006
04,03,GUAIRÁ,CAPITÁN MAURICIO JOSÉ TROCHE,1,007,LOMA CLAVEL,0403007
04,06,GUAIRÁ,GRAL. EUGENIO A. GARAY,1,003,SAN BLAS,0406003
04,06,GUAIRÁ,GRAL. EUGENIO A. GARAY,1,004,SAN ANTONIO,0406004
04,06,GUAIRÁ,GRAL. EUGENIO A. GARAY,1,005,KILÓMETRO 29,0406005
04,06,GUAIRÁ,GRAL. EUGENIO A. GARAY,1,001,SAN ISIDRO,0406001
04,06,GUAIRÁ,GRAL. EUGENIO A. GARAY,1,006,SAN MIGUEL,0406006
04,06,GUAIRÁ,GRAL. EUGENIO A. GARAY,1,002,SAGRADO CORAZÓN DE JESÚS,0406002
04,11,GUAIRÁ,MBOCAYATY,1,003,MARÍA AUXILIADORA,0411003
04,11,GUAIRÁ,MBOCAYATY,1,004,SANTA LIBRADA,0411004
04,11,GUAIRÁ,MBOCAYATY,1,001,VIRGEN DE LA ASUNCIÓN,0411001
04,11,GUAIRÁ,MBOCAYATY,1,002,VIRGEN DEL ROSARIO,0411002
04,12,GUAIRÁ,NATALICIO TALAVERA,1,003,ESCUELA,0412003
04,12,GUAIRÁ,NATALICIO TALAVERA,1,004,SAN PEDRO,0412004
04,12,GUAIRÁ,NATALICIO TALAVERA,1,006,SANTA ROSA,0412006
04,12,GUAIRÁ,NATALICIO TALAVERA,1,001,IGLESIA,0412001
04,12,GUAIRÁ,NATALICIO TALAVERA,1,005,SAN MIGUEL,0412005
04,12,GUAIRÁ,NATALICIO TALAVERA,1,002,VIRGEN DEL ROSARIO,0412002
04,15,GUAIRÁ,YATAITY,1,001,TAJAMAR,0415001
04,15,GUAIRÁ,YATAITY,1,002,ALEGRE,0415002
04,15,GUAIRÁ,YATAITY,1,006,14 DE SETIEMBRE,0415006
04,15,GUAIRÁ,YATAITY,1,005,COSMOS,0415005
Zona 4
03,14,CORDILLERA,PIRIBEBUY,1,003,SANTA  ANA,0314003
03,14,CORDILLERA,PIRIBEBUY,1,005,MARÍA AUXILIADORA,0314005
03,14,CORDILLERA,PIRIBEBUY,1,002,BARRIO FÁTIMA,0314002
03,14,CORDILLERA,PIRIBEBUY,1,006,VIRGEN DEL ROSARIO,0314006
03,14,CORDILLERA,PIRIBEBUY,1,004,CENTRO,0314004
09,01,PARAGUARÍ,PARAGUARÍ,1,029,URBANIZACIÓN LOS GUAYABOS,0901029
09,01,PARAGUARÍ,PARAGUARÍ,1,018,CALLE,0901018
09,01,PARAGUARÍ,PARAGUARÍ,1,028,URBANIZACIÓN MARÍA DEL CARMEN,0901028
09,01,PARAGUARÍ,PARAGUARÍ,1,019,URBANIZACIÓN ARASA POTY,0901019
09,01,PARAGUARÍ,PARAGUARÍ,1,024,COMANDO DE ARTILLERIA VILLA MILITAR,0901024
09,01,PARAGUARÍ,PARAGUARÍ,1,020,PISCINA,0901020
09,01,PARAGUARÍ,PARAGUARÍ,1,010,CIUDAD NUEVA,0901010
09,01,PARAGUARÍ,PARAGUARÍ,1,006,CENTRO,0901006
09,01,PARAGUARÍ,PARAGUARÍ,1,027,URBANIZACIÓN LAS PALMERAS,0901027
09,01,PARAGUARÍ,PARAGUARÍ,1,026,SANTO DOMINGO,0901026
09,01,PARAGUARÍ,PARAGUARÍ,1,008,ASENT. SANTO DOMINGO,0901008
09,01,PARAGUARÍ,PARAGUARÍ,1,021,FÁTIMA,0901021
09,01,PARAGUARÍ,PARAGUARÍ,1,022,ESTACIÓN,0901022
09,01,PARAGUARÍ,PARAGUARÍ,1,011,SAN BLAS II,0901011
09,01,PARAGUARÍ,PARAGUARÍ,1,012,SANTA CATALINA,0901012
09,01,PARAGUARÍ,PARAGUARÍ,1,023,SAN MIGUEL,0901023
09,01,PARAGUARÍ,PARAGUARÍ,1,004,SANTO TOMÁS,0901004
09,01,PARAGUARÍ,PARAGUARÍ,1,005,PA'I GÓMEZ,0901005
09,01,PARAGUARÍ,PARAGUARÍ,1,013,SUB MARIN,0901013
09,01,PARAGUARÍ,PARAGUARÍ,1,016,URBANIZACIÓN LA NEGRITA,0901016
09,01,PARAGUARÍ,PARAGUARÍ,1,009,SAN BLAS,0901009
09,01,PARAGUARÍ,PARAGUARÍ,1,014,NACIONAL,0901014
09,01,PARAGUARÍ,PARAGUARÍ,1,007,VIRGEN DE CAACUPÉ,0901007
09,01,PARAGUARÍ,PARAGUARÍ,1,017,URBANIZACIÓN VIRGEN DE GUADALUPE,0901017
09,01,PARAGUARÍ,PARAGUARÍ,1,025,ALBORADA,0901025
09,01,PARAGUARÍ,PARAGUARÍ,1,015,SAN FRANCISCO,0901015
09,15,PARAGUARÍ,YAGUARÓN,1,007,ASENT. 1RO DE MAYO,0915007
09,15,PARAGUARÍ,YAGUARÓN,1,006,MBARITU,0915006
09,15,PARAGUARÍ,YAGUARÓN,1,001,SAN FRANCISCO,0915001
09,15,PARAGUARÍ,YAGUARÓN,1,008,KARUNGUA,0915008
09,15,PARAGUARÍ,YAGUARÓN,1,002,SAN ROQUE,0915002
09,15,PARAGUARÍ,YAGUARÓN,1,003,SANTA LIBRADA,0915003
09,15,PARAGUARÍ,YAGUARÓN,1,004,SAN MIGUEL,0915004
09,15,PARAGUARÍ,YAGUARÓN,1,009,YSATY,0915009
09,15,PARAGUARÍ,YAGUARÓN,1,005,SAN JOSÉ,0915005
11,05,CENTRAL,ITÁ,1,002,CERRO CORÁ,1105002
11,05,CENTRAL,ITÁ,1,009,30 DE AGOSTO,1105009
11,05,CENTRAL,ITÁ,1,008,SAN ANTONIO - FRACCIÓN LAS PERLAS,1105008
11,05,CENTRAL,ITÁ,1,004,ASENT. SAN ANTONO- NUEVA ESPERANZA,1105004
11,05,CENTRAL,ITÁ,1,005,ASENT. SAN ANTONIO - JEROVIA,1105005
11,05,CENTRAL,ITÁ,1,006,ASENT. VY'A RENDA-SAN ANTONIO,1105006
11,05,CENTRAL,ITÁ,1,001,SPORTIVO,1105001
11,05,CENTRAL,ITÁ,1,003,SAN BLAS,1105003
11,05,CENTRAL,ITÁ,1,007,ASENT. KOKUERE,1105007
Zona 5
05,01,CAAGUAZÚ,CORONEL OVIEDO,1,014,POTRERITO - SAN ROQUE,0501014
05,01,CAAGUAZÚ,CORONEL OVIEDO,1,013,ASENT. SANTA LUCÍA,0501013
05,01,CAAGUAZÚ,CORONEL OVIEDO,1,015,PRIMERO DE MAYO,0501015
05,01,CAAGUAZÚ,CORONEL OVIEDO,1,001,CERRITO RUGUA,0501001
05,01,CAAGUAZÚ,CORONEL OVIEDO,1,052,ASENT. 31 DE JULIO,0501052
05,01,CAAGUAZÚ,CORONEL OVIEDO,1,051,ASENT. LAS MERCEDES 2,0501051
05,01,CAAGUAZÚ,CORONEL OVIEDO,1,007,COSTA ALEGRE,0501007
05,01,CAAGUAZÚ,CORONEL OVIEDO,1,006,CAPITÁN ROA,0501006
05,01,CAAGUAZÚ,CORONEL OVIEDO,1,005,CENTRO,0501005
05,01,CAAGUAZÚ,CORONEL OVIEDO,1,004,12 DE JUNIO,0501004
05,01,CAAGUAZÚ,CORONEL OVIEDO,1,020,ASENT. BONANZA,0501020
05,01,CAAGUAZÚ,CORONEL OVIEDO,1,022,ASENT. 6 DE ENERO,0501022
05,01,CAAGUAZÚ,CORONEL OVIEDO,1,023,VILLA MOREIRA,0501023
05,01,CAAGUAZÚ,CORONEL OVIEDO,1,009,GENERAL BERNARDINO CABALLERO,0501009
05,01,CAAGUAZÚ,CORONEL OVIEDO,1,008,AZUCENA,0501008
05,01,CAAGUAZÚ,CORONEL OVIEDO,1,012,SAN ISIDRO,0501012
05,01,CAAGUAZÚ,CORONEL OVIEDO,1,011,JOSÉ ALFONSO GODOY,0501011
05,01,CAAGUAZÚ,CORONEL OVIEDO,1,041,REGINA,0501041
05,01,CAAGUAZÚ,CORONEL OVIEDO,1,010,BOQUERÓN,0501010
05,01,CAAGUAZÚ,CORONEL OVIEDO,1,040,FRACCIÓN MANDYJU,0501040
05,01,CAAGUAZÚ,CORONEL OVIEDO,1,021,BALCÓN OVETENSE,0501021
05,01,CAAGUAZÚ,CORONEL OVIEDO,1,002,PRIMERO DE MARZO,0501002
05,01,CAAGUAZÚ,CORONEL OVIEDO,1,016,ASENT. 3 DE NOVIEMBRE,0501016
05,01,CAAGUAZÚ,CORONEL OVIEDO,1,017,ASENT. LA GLORIA,0501017
05,01,CAAGUAZÚ,CORONEL OVIEDO,1,018,ASENT. SOL NACIENTE,0501018
05,01,CAAGUAZÚ,CORONEL OVIEDO,1,019,ASENT. LA GLORIA I,0501019
05,01,CAAGUAZÚ,CORONEL OVIEDO,1,003,SAN MIGUEL,0501003
05,01,CAAGUAZÚ,CORONEL OVIEDO,1,045,UNIVERSITARIO,0501045
05,01,CAAGUAZÚ,CORONEL OVIEDO,1,049,KAAGUY RORY,0501049
05,01,CAAGUAZÚ,CORONEL OVIEDO,1,050,ASENT. LAS MERCEDES 1,0501050
05,01,CAAGUAZÚ,CORONEL OVIEDO,1,027,VILLA AZUCENA,0501027
05,01,CAAGUAZÚ,CORONEL OVIEDO,1,028,ASENT. SIEMPRE VERDE I,0501028
05,01,CAAGUAZÚ,CORONEL OVIEDO,1,026,ASENT. SIEMPRE VERDE II,0501026
05,01,CAAGUAZÚ,CORONEL OVIEDO,1,033,EL PARAISO,0501033
05,01,CAAGUAZÚ,CORONEL OVIEDO,1,024,ASENT. VIRGEN DEL CARMEN,0501024
05,01,CAAGUAZÚ,CORONEL OVIEDO,1,036,MARISTAS I,0501036
05,01,CAAGUAZÚ,CORONEL OVIEDO,1,029,NIÑO JESÚS,0501029
05,01,CAAGUAZÚ,CORONEL OVIEDO,1,035,LA FLORESTA,0501035
05,01,CAAGUAZÚ,CORONEL OVIEDO,1,031,MARISTAS II,0501031
05,01,CAAGUAZÚ,CORONEL OVIEDO,1,030,LA VICTORIA,0501030
05,01,CAAGUAZÚ,CORONEL OVIEDO,1,043,SAN LUIS,0501043
05,01,CAAGUAZÚ,CORONEL OVIEDO,1,044,JUAN LATÍN,0501044
05,01,CAAGUAZÚ,CORONEL OVIEDO,1,034,CALLE HOVY,0501034
05,01,CAAGUAZÚ,CORONEL OVIEDO,1,042,SAN RAFAEL,0501042
05,01,CAAGUAZÚ,CORONEL OVIEDO,1,032,ASENT. PARAISO,0501032
05,01,CAAGUAZÚ,CORONEL OVIEDO,1,039,FRACCIÓN CIUDADELA,0501039
05,01,CAAGUAZÚ,CORONEL OVIEDO,1,038,CORONEL POTY,0501038
05,01,CAAGUAZÚ,CORONEL OVIEDO,1,037,AMANECER,0501037
05,01,CAAGUAZÚ,CORONEL OVIEDO,1,048,SAN ROQUE,0501048
05,01,CAAGUAZÚ,CORONEL OVIEDO,1,047,ESPERANZA,0501047
05,01,CAAGUAZÚ,CORONEL OVIEDO,1,046,SAGRADO CORAZÓN DE JESÚS,0501046
05,01,CAAGUAZÚ,CORONEL OVIEDO,1,025,VILLA DEL MAESTRO,0501025
-- Tablas de ubicación
-- Extensión PostGIS para habilitar funcionalidades espaciales
CREATE EXTENSION IF NOT EXISTS postgis;

Estructura del archivo D:/SOFTWARE/GPS/INEC/CARTOGRAFÍA/PAIS\Departamentos_Paraguay.dbf:
Columnas:
    DPTO VARCHAR(2)
    DPTO_DESC VARCHAR(20)
Campos: 2
Largo: 23	
Total Filas: 18
Tamaño: 512

-- Tabla de Departamentos
CREATE TABLE gf.departamentos (
    id_dpto SERIAL PRIMARY KEY,
    dpto VARCHAR(2) NOT NULL,
    dpto_desc VARCHAR(20) NOT NULL
);

Estructura del archivo D:/SOFTWARE/GPS/INEC/CARTOGRAFÍA/PAIS\Distritos_Paraguay.dbf:
Columnas:
    OBJECTID_1 Numeric(9)
    DPTO VARCHAR(2)
    DISTRITO VARCHAR(2)
    DPTO_DESC VARCHAR(20)
    DIST_DESC VARCHAR(32)
    CLAVE VARCHAR(4)
Campos: 6
Largo: 70	
Total Filas: 250
Tamaño: 17726

-- Tabla de Distritos
CREATE TABLE gf.distritos (
    id_distrito SERIAL PRIMARY KEY,
    id_dpto INTEGER REFERENCES gf.departamentos(id_dpto),
    distrito VARCHAR(2) NOT NULL,
    dist_desc VARCHAR(40) NOT NULL,
    clave VARCHAR(4) NOT NULL
);

Estructura del archivo D:/SOFTWARE/GPS/INEC/CARTOGRAFÍA/PAIS\Barrios_Localidades_Paraguay.dbf:
Columnas:
    DPTO VARCHAR(2)
    DISTRITO VARCHAR(2)
    DPTO_DESC VARCHAR(20)
    DIST_DESC VARCHAR(40)
    AREA VARCHAR(1)
    BAR_LOC VARCHAR(3)
    BARLO_DESC VARCHAR(51)
    CLAVE VARCHAR(7)
Campos: 8
Largo: 127
Total Filas: 8336
Tamaño: 1058962

-- Tabla de Barrios y Localidades
CREATE TABLE gf.barrios_localidades (
    id_barrio SERIAL PRIMARY KEY,
    id_distrito INTEGER REFERENCES gf.distritos(id_distrito),
    area VARCHAR(1),
    bar_loc VARCHAR(3),
    barlo_desc VARCHAR(51),
    clave VARCHAR(7)
);

Estructura del archivo D:/SOFTWARE/GPS/INEC/CARTOGRAFÍA/PAIS\Vias principales_Paraguay.dbf:
Columnas:
    NOMBRE VARCHAR(100)
    LONG_KM_EN Numeric(6)
    RUTA_NRO VARCHAR(2)
    ANCHO Numeric(2)
    TIPO Numeric(2)
    LONG_MTS Numeric(10)
Campos: 6
Largo: 123
Total Filas: 470
Tamaño: 58036

-- Tabla de Vías Principales
CREATE TABLE gf.vias_principales (
    id_via SERIAL PRIMARY KEY,
    nombre VARCHAR(100),
    long_km_en NUMERIC(6),
    ruta_nro VARCHAR(2),
    ancho NUMERIC(2),
    tipo NUMERIC(2),
    long_mts NUMERIC(10)
);

Estructura del archivo D:/SOFTWARE/GPS/INEC/CARTOGRAFÍA/PAIS\Vias_Paraguay.dbf:
Columnas:
    NOMBRE VARCHAR(50)
    TIPO Numeric(2)
    ANCHO Numeric(2)
    DPTO VARCHAR(2)
    DPTO_DESC VARCHAR(20)
Campos: 5
Largo: 77
Total Filas: 410417
Tamaño: 31602303

-- Tabla de Vías
CREATE TABLE gf.vias (
    id_via SERIAL PRIMARY KEY,
    nombre VARCHAR(50),
    tipo NUMERIC(2),
    ancho NUMERIC(2),
    id_dpto INTEGER REFERENCES gf.departamentos(id_dpto)
);

Estructura del archivo D:/SOFTWARE/GPS/INEC/CARTOGRAFÍA/Códigos cartográficos\LOCALES_DE_SALUD_DGEEC2012.dbf:
Columnas:
    DPTO VARCHAR(2)
    DPTO_DESC VARCHAR(20)
    DISTRITO VARCHAR(2)
    DIST_DESC VARCHAR(33)
    NOMBRE VARCHAR(50)
    LONGITUD Numeric(11)
    LATITUD Numeric(11)
Campos: 7
Largo: 130
Total Filas: 1629
Tamaño: 212028

-- Tabla de Locales de Salud
CREATE TABLE locales_salud (
    id_local_salud SERIAL PRIMARY KEY,
    id_dpto INTEGER REFERENCES gf.departamentos(id_dpto),
    id_distrito INTEGER REFERENCES gf.distritos(id_distrito),
    nombre VARCHAR(50),
    ubicacion GEOGRAPHY(POINT, 4326)
);

Estructura del archivo D:/SOFTWARE/GPS/INEC/CARTOGRAFÍA/Códigos cartográficos\LOCALES_EDUCATIVOS_DGEEC2012.dbf:
Columnas:
    DPTO VARCHAR(2)
    DPTO_DESC VARCHAR(20)
    DISTRITO VARCHAR(2)
    DIST_DESC VARCHAR(33)
    NOMBRE VARCHAR(56)
    LONGITUD Numeric(11)
    LATITUD Numeric(11)
Campos: 4
Largo: 129
Total Filas: 9117
Tamaño: 1240170

-- Tabla de Locales Educativos
CREATE TABLE gf.locales_educativos (
    id_local_edu SERIAL PRIMARY KEY,
    id_dpto_id INTEGER REFERENCES gf.departamentos(id_dpto),
    id_distrito INTEGER REFERENCES gf.distritos(id_distrito),
    nombre VARCHAR(56),
    ubicacion GEOGRAPHY(POINT, 4326)
);

Estructura del archivo D:/SOFTWARE/GPS/INEC/CARTOGRAFÍA/Códigos cartográficos\LOCALES_POLICIALES_DGEEC2012.dbf:
Columnas:
    DPTO VARCHAR(2)
    DPTO_DESC VARCHAR(20)
    DISTRITO VARCHAR(2)
    DIST_DESC VARCHAR(30)
    NOMBRE VARCHAR(51)
    LONGITUD Numeric(10)
    LATITUD Numeric(10)
Campos: 7
Largo: 126
Total Filas: 1082
Tamaño: 136590

-- Tabla de Locales Policiales
CREATE TABLE gf.locales_policiales (
    id_local_policial SERIAL PRIMARY KEY,
    id_dpto INTEGER REFERENCES gf.departamentos(id_dpto),
    id_distrito INTEGER REFERENCES gf.distritos(id_distrito),
    nombre VARCHAR(51),
    ubicacion GEOGRAPHY(POINT, 4326)
);

Estructura del archivo D:/SOFTWARE/GPS/INEC/CARTOGRAFÍA/PAIS\Comunidades_Indigenas_Paraguay.dbf:
Columnas:
    DPTO VARCHAR(2)
    DISTRITO VARCHAR(2)
    DPTO_DESC VARCHAR(20)
    DIST_DESC VARCHAR(30)
    AREA VARCHAR(1)
    BAR_LOC VARCHAR(3)
    BARLO_DESC VARCHAR(50)
    COMUNIDAD VARCHAR(4)
    ALDEA VARCHAR(2)
    COM_DESC VARCHAR(50)
    PUEBLO_ETN VARCHAR(30)
    COD_PUEBLO VARCHAR(2)
    FAMILIA VARCHAR(20)
Campos: 13
Largo: 217
Total Filas: 778
Tamaño: 169276

-- Tabla de Comunidades Indígenas
CREATE TABLE gf.comunidades_indigenas (
    id_comunidad SERIAL PRIMARY KEY,
    id_distrito INTEGER REFERENCES gf.distritos(id_distrito),
    area VARCHAR(1),
    bar_loc VARCHAR(3),
    barlo_desc VARCHAR(50),
    comunidad VARCHAR(4),
    aldea VARCHAR(2),
    com_desc VARCHAR(50),
    pueblo_etn VARCHAR(30),
    cod_pueblo VARCHAR(2),
    familia VARCHAR(20)
);

--Optimización con Índices
CREATE INDEX idx_tarjetas_cliente ON Tarjetas(id_cliente);
CREATE INDEX idx_productos_codigo_barras ON Productos(codigo_barras);
CREATE INDEX idx_pagos_fecha ON Pagos(fecha_pago);
CREATE INDEX idx_rutas_vendedor_fecha ON Rutas(id_vendedor, fecha);
CREATE INDEX idx_pagos_cliente_metodo ON Pagos(id_cliente, metodo_pago);
CREATE INDEX idx_antecedentes_cedula ON AntecedentesJudiciales(cedula);
CREATE INDEX idx_inventario_maletines_producto ON Inventario_Maletines(id_maletin, id_producto);
CREATE INDEX idx_vehiculos_motor_chasis_placa ON Vehiculos(numero_motor, numero_chasis, placa);
CREATE INDEX idx_tarjetas_numero ON Tarjetas(numero_tarjeta);
CREATE INDEX idx_maletin_empleado ON Maletines(id_empleado);
CREATE INDEX idx_liquidacion_empleado ON Liquidaciones(id_empleado);
CREATE INDEX ON barrios_localidades (barlo_desc);
CREATE INDEX ON comunidades_indigenas (barlo_desc);
CREATE INDEX idx_rutas_inicio_ruta ON rutas USING GIST (inicio_ruta);
CREATE INDEX idx_puntos_ruta_ubicacion ON puntos_ruta USING GIST (ubicacion);
CREATE INDEX idx_zonas_geom ON zonas USING GIST (geom);

-- Índices espaciales para optimizar consultas
CREATE INDEX ON barrios_localidades USING GIST (barlo_desc);
CREATE INDEX ON comunidades_indigenas USING GIST (barlo_desc);
CREATE INDEX ON locales_salud USING GIST (ubicacion);
CREATE INDEX ON locales_educativos USING GIST (ubicacion);
CREATE INDEX ON locales_policiales USING GIST (ubicacion);
CREATE INDEX idx_clientes_direccion ON Clientes USING GIST (direccion);
CREATE INDEX idx_clientes_ultimo_inicio_sesion ON Clientes (ultimo_inicio_sesion);
CREATE INDEX idx_productos_codigo_barras_inicio ON Productos (LEFT(codigo_barras, 3));
CREATE INDEX idx_productos_codigo_barras_fin ON Productos (RIGHT(codigo_barras, 3));

CREATE TRIGGER update_ultimo_inicio_sesion
BEFORE UPDATE ON Clientes
FOR EACH ROW
WHEN (NEW.estado = 'activo')
EXECUTE PROCEDURE update_ultimo_inicio_sesion();

-- Ejemplo de consulta para encontrar clientes activos en una zona específica
WITH clientes_en_zona AS (
  SELECT id_cliente
  FROM Clientes
  WHERE ST_DWithin(direccion, ST_MakePoint(-58.3816, -34.6037), 1000) -- Buscar clientes a 1 km de un punto
)
SELECT * FROM Clientes
WHERE id_cliente IN (SELECT id_cliente FROM clientes_en_zona);
CREATE OR REPLACE FUNCTION update_ultimo_inicio_sesion()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.estado = 'activo' THEN
        NEW.ultimo_inicio_sesion = CURRENT_TIMESTAMP;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_ultimo_inicio_sesion
BEFORE UPDATE ON Clientes
FOR EACH ROW
WHEN (NEW.estado = 'activo')
EXECUTE FUNCTION update_ultimo_inicio_sesion();

CREATE FUNCTION calcular_edad(fecha_nacimiento DATE)
RETURNS INTEGER AS $$
DECLARE
  edad INTEGER;
BEGIN
  SELECT AGE(CURRENT_DATE, fecha_nacimiento) INTO edad;
  RETURN edad;
END;
$$ LANGUAGE plpgsql;

--Triggers y Funciones

--Actualizar saldo del cliente
CREATE OR REPLACE FUNCTION actualizar_saldo_cliente() 
RETURNS TRIGGER AS $$
BEGIN
    UPDATE Tarjetas 
    SET saldo = saldo - NEW.monto
    WHERE id_tarjeta = NEW.id_tarjeta;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

--Trigger para actualizar saldo tras un pago:
CREATE TRIGGER tg_actualizar_saldo
AFTER INSERT ON Pagos
FOR EACH ROW
EXECUTE FUNCTION actualizar_saldo_cliente();

--Función para actualizar inventario tras una venta:
CREATE OR REPLACE FUNCTION actualizar_inventario() 
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.cantidad > (SELECT stock FROM Productos WHERE id_producto = NEW.id_producto) THEN
        RAISE EXCEPTION 'No hay suficiente stock para este producto';
    ELSE
        UPDATE Productos 
        SET stock = stock - NEW.cantidad 
        WHERE id_producto = NEW.id_producto;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

--Trigger para actualizar inventario tras una venta:
CREATE TRIGGER tg_actualizar_inventario
AFTER INSERT ON Productos_Vendidos
FOR EACH ROW
EXECUTE FUNCTION actualizar_inventario();

CREATE OR REPLACE FUNCTION actualizar_stock_maletin() RETURNS TRIGGER AS $$
BEGIN
    IF NEW.cantidad > (SELECT stock FROM Productos WHERE id_producto = NEW.id_producto) THEN
        RAISE EXCEPTION 'No hay suficiente stock';
    ELSE
        UPDATE Productos SET stock = stock - NEW.cantidad WHERE id_producto = NEW.id_producto;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

--Trigger para Actualizar Stock,
CREATE TRIGGER tg_actualizar_stock
AFTER INSERT ON Productos_Maletin
FOR EACH ROW EXECUTE FUNCTION actualizar_stock_maletin();

CREATE OR REPLACE FUNCTION actualizar_stock_producto() RETURNS TRIGGER AS $$
BEGIN
    IF (NEW.cantidad > (SELECT stock FROM Productos WHERE id_producto = NEW.id_producto)) THEN
        RAISE EXCEPTION 'No hay suficiente stock para este producto';
    ELSE
        UPDATE Productos 
        SET stock = stock - NEW.cantidad 
        WHERE id_producto = NEW.id_producto;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tg_actualizar_stock
AFTER INSERT ON DetalleVenta
FOR EACH ROW
EXECUTE FUNCTION actualizar_stock_producto();

--Trigger para Control de Stock en Maletines: Disminuye el stock de productos cuando se asignan a un maletín.

CREATE OR REPLACE FUNCTION actualizar_stock_maletin() RETURNS TRIGGER AS $$
BEGIN
    IF (NEW.cantidad > (SELECT stock FROM Productos WHERE id_producto = NEW.id_producto)) THEN
        RAISE EXCEPTION 'No hay suficiente stock para el producto %', NEW.id_producto;
    ELSE
        UPDATE Productos 
        SET stock = stock - NEW.cantidad 
        WHERE id_producto = NEW.id_producto;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tg_actualizar_stock_maletin
AFTER INSERT ON Productos_Maletin
FOR EACH ROW
EXECUTE FUNCTION actualizar_stock_maletin();

--Trigger para Actualizar Liquidación por Venta: Calcula la liquidación de la vendedora al final del día.

CREATE OR REPLACE FUNCTION calcular_liquidacion() RETURNS TRIGGER AS $$
BEGIN
	NEW.total_pagar := NEW.total_ventas * 50000;
	RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tg_calcular_liquidacion
BEFORE INSERT ON Liquidaciones
FOR EACH ROW
EXECUTE FUNCTION calcular_liquidacion();

--Trigger de antecedentes judiciales: Verificar si un cliente tiene antecedentes antes de ser registrado.

CREATE OR REPLACE FUNCTION verificar_antecedentes_judiciales() RETURNS TRIGGER AS $$
BEGIN
	IF EXISTS (SELECT 1 FROM AntecedentesJudiciales WHERE numero_ci = NEW.cedula) THEN
		RAISE NOTICE 'El cliente con cédula % tiene antecedentes judiciales', NEW.cedula;
	END IF;
	RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tg_verificar_antecedentes_judiciales
BEFORE INSERT ON Clientes
FOR EACH ROW
EXECUTE FUNCTION verificar_antecedentes_judiciales();

--Vista para Reportes de Ventas
CREATE VIEW VW_Ventas_Por_Cliente AS
SELECT 
    c.id_cliente, 
    c.nombre, 
    c.apellido, 
    COUNT(v.id_tarjeta) AS total_ventas, 
    SUM(v.total_gs) AS monto_total
FROM 
    Clientes c
JOIN 
    Tarjetas v ON c.id_cliente = v.id_cliente
GROUP BY 
    c.id_cliente;

CREATE VIEW VW_Ventas_Por_Zona AS
SELECT Z.nombre_zona, SUM(T.total_gs) AS total_ventas
FROM Zonas Z
JOIN Rutas R ON Z.id_zona = R.id_zona
JOIN Tarjetas T ON R.id_ruta = T.id_ruta
GROUP BY Z.nombre_zona;


SELECT c.nombre, c.apellido, d.calle, d.numero
FROM Clientes c
JOIN direcciones d ON c.id_direccion = d.id_direccion
WHERE c.prefijo = '0972' AND d.ciudad = 'Asunción';

--Interfaz más apropiada
import React, { useState, useEffect } from 'react';
import { Card } from '@/components/ui/card';
import { Alert, AlertDescription } from '@/components/ui/alert';
import { LogIn, UserCircle, LogOut } from 'lucide-react';

const LoginForm = ({ onLogin }) => {
  const [credentials, setCredentials] = useState({ username: '', password: '' });
  const [error, setError] = useState('');

  const handleSubmit = async (e) => {
    e.preventDefault();
    try {
      // Aquí iría la lógica de autenticación real
      onLogin({ username: credentials.username, role: 'vendedor' });
    } catch (err) {
      setError('Credenciales inválidas');
    }
  };

  return (
    <Card className="w-full max-w-md p-6 bg-white">
      <h2 className="text-2xl font-serif mb-6">Gabriela Fragancias</h2>
      <form onSubmit={handleSubmit} className="space-y-4">
        <div>
          <label className="block text-sm font-medium mb-1">Usuario</label>
          <input
            type="text"
            className="w-full p-2 border rounded"
            value={credentials.username}
            onChange={(e) => setCredentials({...credentials, username: e.target.value})}
          />
        </div>
        <div>
          <label className="block text-sm font-medium mb-1">Contraseña</label>
          <input
            type="password"
            className="w-full p-2 border rounded"
            value={credentials.password}
            onChange={(e) => setCredentials({...credentials, password: e.target.value})}
          />
        </div>
        {error && (
          <Alert variant="destructive">
            <AlertDescription>{error}</AlertDescription>
          </Alert>
        )}
        <button
          type="submit"
          className="w-full bg-emerald-600 text-white p-2 rounded hover:bg-emerald-700"
        >
          <LogIn className="inline-block mr-2" size={16} />
          Iniciar Sesión
        </button>
      </form>
    </Card>
  );
};

const PaymentCard = () => {
  const [user, setUser] = useState(null);
  const [payments, setPayments] = useState([
    { control: '28 SEP', fecha: '28-09', entrega: '50.000', saldo: '230.000' },
    { control: '15 OCT', fecha: '05-10', entrega: '40.000', saldo: '190.000' },
    { control: '22 OCT', fecha: '12-10', entrega: '20.000', saldo: '170.000' },
    { control: '28 OCT', fecha: '20-10', entrega: '20.000', saldo: '150.000' },
    { control: '09 NOV', fecha: '02-11', entrega: '20.000', saldo: '130.000' },
  ]);

  const handleLogin = (userData) => {
    setUser(userData);
    // Aquí se podría cargar los datos específicos del vendedor
  };

  const handleLogout = () => {
    setUser(null);
  };

  if (!user) {
    return (
      <div className="min-h-screen bg-gray-100 p-8 flex justify-center items-center">
        <LoginForm onLogin={handleLogin} />
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-gray-100 p-8">
      {/* Header con información de usuario */}
      <div className="max-w-2xl mx-auto mb-4 flex justify-between items-center">
        <div className="flex items-center">
          <UserCircle className="mr-2" />
          <span className="font-mono">{user.username}</span>
        </div>
        <button
          onClick={handleLogout}
          className="text-gray-600 hover:text-gray-800 flex items-center"
        >
          <LogOut className="mr-1" size={16} />
          Cerrar Sesión
        </button>
      </div>

      {/* Contenido original de la tarjeta */}
      <Card className="max-w-2xl mx-auto bg-emerald-50 p-6 relative">
        {/* ... (resto del contenido de la tarjeta igual que antes) ... */}
        
        {/* Agregar registro de actividad */}
        <div className="mt-4 text-xs text-gray-500">
          Última actividad: {new Date().toLocaleString()}
        </div>
      </Card>
    </div>
  );
};

export default PaymentCard;

import React from 'react';
import { Card } from '@/components/ui/card';
import { UserCircle, Database } from 'lucide-react';

const AdminPanel = () => {
  return (
    <div className="min-h-screen bg-gray-100 p-8">
      <h2 className="text-2xl font-serif mb-6">Panel de Administración</h2>
      <div className="grid grid-cols-2 gap-4">
        <Card className="bg-white p-6 flex items-center space-x-4">
          <UserCircle className="text-emerald-600" size={48} />
          <div>
            <h3 className="text-xl font-semibold mb-2">Gestión de Usuarios</h3>
            <p className="text-sm text-gray-600">Administra los usuarios del sistema.</p>
          </div>
        </Card>
        <Card className="bg-white p-6 flex items-center space-x-4">
          <Database className="text-emerald-600" size={48} />
          <div>
            <h3 className="text-xl font-semibold mb-2">Gestión de Base de Datos</h3>
            <p className="text-sm text-gray-600">Administra la base de datos del sistema.</p>
          </div>
        </Card>
      </div>
    </div>
  );
};

export default AdminPanel;

import React, { useState } from 'react';
import { Route, Switch, Link } from 'react-router-dom';
import { Card } from '@/components/ui/card';
import { UserCircle, LogOut } from 'lucide-react';
import LoginForm from './LoginForm';
import AdminPanel from './AdminPanel';

const PaymentCard = () => {
  const [user, setUser] = useState(null);

  const handleLogin = (userData) => {
    setUser(userData);
  };

  const handleLogout = () => {
    setUser(null);
  };

  if (!user) {
    return (
      <div className="min-h-screen bg-gray-100 p-8 flex justify-center items-center">
        <LoginForm onLogin={handleLogin} />
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-gray-100 p-8">
      {/* Header con información de usuario */}
      <div className="max-w-2xl mx-auto mb-4 flex justify-between items-center">
        <div className="flex items-center">
          <UserCircle className="mr-2" />
          <span className="font-mono">{user.username}</span>
        </div>
        <button
          onClick={handleLogout}
          className="text-gray-600 hover:text-gray-800 flex items-center"
        >
          <LogOut className="mr-1" size={16} />
          Cerrar Sesión
        </button>
      </div>

      {/* Enrutamiento */}
      <Switch>
        <Route exact path="/">
          {/* Contenido original de la tarjeta */}
          <Card className="Alto add thead

--15. Insertar Datos Ejemplares

-- Insertar un cliente
INSERT INTO Clientes (cedula, nombre, apellido, telefono, direccion, email)
VALUES ('1234567890', 'Juan', 'Pérez', '0981123456', 'Av. Siempre Viva', 'juan.perez@email.com');

-- Insertar una tarjeta para ese cliente
INSERT INTO Tarjetas (numero_tarjeta, id_cliente, id_vendedor, id_zona, total_gs, saldo, forma_pago)
VALUES ('0012345', 1, 1, 1, 150000, 150000, 'SEM');

-- Insertar un pago para la tarjeta
INSERT INTO Pagos (id_tarjeta, fecha_pago, monto, saldo_restante, entrega_inicial)
VALUES (1, '2024-10-01', 50000, 100000, TRUE);



4. Reportes Pendientes

Reporte de Ganancias por Día: Resumen de ganancias diarias.
Reporte de Pagos Realizados por Clientes: Incluye los pagos parciales y totales de los clientes.
Reporte de Análisis de Ventas por Fecha: Un desglose de las ventas según períodos específicos.
Reporte de Cuentas a Vencer de Proveedores: Para controlar las facturas pendientes de pago a proveedores.
Reporte de Inventario por Marca: Para conocer el inventario desglosado por marca de productos​
	
Gabriela Fragancias, incluyendo la consulta para obtener el perfume más vendido.
1. Creación de tablas

sql

-- Tabla Clientes
CREATE TABLE clientes (
    id_cliente SERIAL PRIMARY KEY,
    nombre VARCHAR(100) NOT NULL,
    apellido VARCHAR(100) NOT NULL,
    cedula VARCHAR(20) UNIQUE NOT NULL,
    direccion TEXT NOT NULL,
    telefono VARCHAR(20),
    zona VARCHAR(50) NOT NULL,
    fecha_registro DATE DEFAULT CURRENT_DATE
);

-- Tabla Productos
CREATE TABLE productos (
    id_producto SERIAL PRIMARY KEY,
    nombre VARCHAR(100) NOT NULL,
    precio NUMERIC(10,2) NOT NULL,
    categoria VARCHAR(50),
    codigo_barras VARCHAR(13) UNIQUE
);

-- Tabla Vendedores
CREATE TABLE vendedores (
    id_vendedor SERIAL PRIMARY KEY,
    nombre VARCHAR(100) NOT NULL,
    apellido VARCHAR(100) NOT NULL,
    comision NUMERIC(10,2) DEFAULT 50000
);

-- Tabla Ventas
CREATE TABLE ventas (
    id_venta SERIAL PRIMARY KEY,
    fecha DATE DEFAULT CURRENT_DATE,
    total NUMERIC(10,2) NOT NULL,
    id_cliente INTEGER REFERENCES clientes(id_cliente),
    id_vendedor INTEGER REFERENCES vendedores(id_vendedor)
);

-- Tabla Detalle de Ventas
CREATE TABLE ventas_detalle (
    id_venta_detalle SERIAL PRIMARY KEY,
    cantidad INTEGER NOT NULL,
    id_venta INTEGER REFERENCES ventas(id_venta),
    id_producto INTEGER REFERENCES productos(id_producto)
);

-- Índices para optimización
CREATE INDEX idx_clientes_cedula ON clientes(cedula);
CREATE INDEX idx_ventas_fecha ON ventas(fecha);
CREATE INDEX idx_productos_codigo_barras ON productos(codigo_barras);

2. Funciones y Triggers
a) Perfume más vendido

sql

-- Función para obtener el perfume más vendido en un rango de fechas
CREATE OR REPLACE FUNCTION perfume_mas_vendido(fecha_inicio DATE, fecha_fin DATE)
RETURNS TABLE (perfume VARCHAR, total_vendido NUMERIC) AS $$
BEGIN
  RETURN QUERY
  SELECT p.nombre, SUM(vd.cantidad) AS total_vendido
  FROM ventas v
  INNER JOIN ventas_detalle vd ON v.id_venta = vd.id_venta
  INNER JOIN productos p ON vd.id_producto = p.id_producto
  WHERE v.fecha BETWEEN fecha_inicio AND fecha_fin
  GROUP BY p.nombre
  ORDER BY total_vendido DESC
  LIMIT 1;
END;
$$ LANGUAGE plpgsql;

b) Top perfumes por año

sql

-- Función para obtener los top N perfumes más vendidos por año
CREATE OR REPLACE FUNCTION top_perfumes_por_ano(ano INTEGER, n INTEGER)
RETURNS TABLE (perfume VARCHAR, total_vendido NUMERIC) AS $$
BEGIN
  RETURN QUERY
  SELECT p.nombre, SUM(vd.cantidad) AS total_vendido
  FROM ventas v
  INNER JOIN ventas_detalle vd ON v.id_venta = vd.id_venta
  INNER JOIN productos p ON vd.id_producto = p.id_producto
  WHERE EXTRACT(YEAR FROM v.fecha) = ano
  GROUP BY p.nombre
  ORDER BY total_vendido DESC
  LIMIT n;
END;
$$ LANGUAGE plpgsql;

c) Trigger para actualizar el saldo del cliente después de una venta

sql

-- Trigger para actualizar el saldo del cliente tras una venta
CREATE OR REPLACE FUNCTION actualizar_saldo_cliente()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE clientes 
    SET saldo = saldo - NEW.total
    WHERE id_cliente = NEW.id_cliente;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tg_actualizar_saldo
AFTER INSERT ON ventas
FOR EACH ROW
EXECUTE FUNCTION actualizar_saldo_cliente();

3. Consultas de ejemplo
a) Obtener el perfume más vendido en un rango de fechas

sql

SELECT * FROM perfume_mas_vendido('2023-01-01', '2023-12-31');

b) Obtener los 3 perfumes más vendidos en un año específico

sql

SELECT * FROM top_perfumes_por_ano(2023, 3);

Con este esquema, puedes gestionar clientes, productos, ventas y vendedores de manera eficiente, además de obtener información detallada sobre las ventas y el rendimiento de los productos.

Si necesitas personalizar alguna parte del código o agregar más funcionalidades, no dudes en indicármelo. ¡Estás listo para comenzar!
Tú dijiste:
presenta todo el código sql, eliminando redundancias y atendiendo bien la estructura y relaciones
ChatGPT Plus
ChatGPT

Aquí te dejo el código SQL completo optimizado, eliminando redundancias y mejorando la estructura de relaciones. Esta base de datos incluye las tablas necesarias para gestionar clientes, productos, ventas, vendedores y relaciones clave, con triggers y funciones que optimizan las operaciones.
1. Creación de las tablas

sql

-- Tabla Clientes
CREATE TABLE clientes (
    id_cliente SERIAL PRIMARY KEY,
    nombre VARCHAR(100) NOT NULL,
    apellido VARCHAR(100) NOT NULL,
    cedula VARCHAR(20) UNIQUE NOT NULL,
    direccion TEXT NOT NULL,
    telefono VARCHAR(20),
    email VARCHAR(100) UNIQUE,
    zona VARCHAR(50) NOT NULL,
    fecha_registro DATE DEFAULT CURRENT_DATE
);

-- Tabla Productos
CREATE TABLE productos (
    id_producto SERIAL PRIMARY KEY,
    nombre VARCHAR(100) NOT NULL,
    precio NUMERIC(10,2) NOT NULL,
    categoria VARCHAR(50),
    codigo_barras VARCHAR(13) UNIQUE NOT NULL,
    stock INTEGER NOT NULL
);

-- Tabla Vendedores
CREATE TABLE vendedores (
    id_vendedor SERIAL PRIMARY KEY,
    nombre VARCHAR(100) NOT NULL,
    apellido VARCHAR(100) NOT NULL,
    comision NUMERIC(10,2) DEFAULT 50000
);

-- Tabla Ventas
CREATE TABLE ventas (
    id_venta SERIAL PRIMARY KEY,
    fecha DATE DEFAULT CURRENT_DATE,
    total NUMERIC(10,2) NOT NULL,
    id_cliente INTEGER REFERENCES clientes(id_cliente),
    id_vendedor INTEGER REFERENCES vendedores(id_vendedor)
);

-- Tabla Detalle de Ventas
CREATE TABLE ventas_detalle (
    id_venta_detalle SERIAL PRIMARY KEY,
    id_venta INTEGER REFERENCES ventas(id_venta) ON DELETE CASCADE,
    id_producto INTEGER REFERENCES productos(id_producto),
    cantidad INTEGER NOT NULL
);

-- Tabla de Inventario por Vendedor (relaciona productos con vendedores)
CREATE TABLE inventario_vendedores (
    id_inventario SERIAL PRIMARY KEY,
    id_vendedor INTEGER REFERENCES vendedores(id_vendedor) ON DELETE CASCADE,
    id_producto INTEGER REFERENCES productos(id_producto),
    cantidad INTEGER NOT NULL
);

-- Tabla Zonas para asociar vendedores a áreas específicas
CREATE TABLE zonas (
    id_zona SERIAL PRIMARY KEY,
    nombre_zona VARCHAR(100) NOT NULL,
    id_vendedor INTEGER REFERENCES vendedores(id_vendedor),
    UNIQUE(id_zona, id_vendedor)
);

-- Índices para optimización
CREATE INDEX idx_clientes_cedula ON clientes(cedula);
CREATE INDEX idx_productos_codigo_barras ON productos(codigo_barras);
CREATE INDEX idx_ventas_fecha ON ventas(fecha);
CREATE INDEX idx_inventario_producto ON inventario_vendedores(id_producto);

2. Funciones y Triggers
a) Perfume más vendido

sql

-- Función para obtener el perfume más vendido en un rango de fechas
CREATE OR REPLACE FUNCTION perfume_mas_vendido(fecha_inicio DATE, fecha_fin DATE)
RETURNS TABLE (perfume VARCHAR, total_vendido NUMERIC) AS $$
BEGIN
  RETURN QUERY
  SELECT p.nombre, SUM(vd.cantidad) AS total_vendido
  FROM ventas v
  INNER JOIN ventas_detalle vd ON v.id_venta = vd.id_venta
  INNER JOIN productos p ON vd.id_producto = p.id_producto
  WHERE v.fecha BETWEEN fecha_inicio AND fecha_fin
  GROUP BY p.nombre
  ORDER BY total_vendido DESC
  LIMIT 1;
END;
$$ LANGUAGE plpgsql;

b) Top perfumes por año

sql

-- Función para obtener los top N perfumes más vendidos por año
CREATE OR REPLACE FUNCTION top_perfumes_por_ano(ano INTEGER, n INTEGER)
RETURNS TABLE (perfume VARCHAR, total_vendido NUMERIC) AS $$
BEGIN
  RETURN QUERY
  SELECT p.nombre, SUM(vd.cantidad) AS total_vendido
  FROM ventas v
  INNER JOIN ventas_detalle vd ON v.id_venta = vd.id_venta
  INNER JOIN productos p ON vd.id_producto = p.id_producto
  WHERE EXTRACT(YEAR FROM v.fecha) = ano
  GROUP BY p.nombre
  ORDER BY total_vendido DESC
  LIMIT n;
END;
$$ LANGUAGE plpgsql;

c) Trigger para actualizar el stock después de una venta

sql

-- Trigger para actualizar el stock de productos tras una venta
CREATE OR REPLACE FUNCTION actualizar_stock_producto() 
RETURNS TRIGGER AS $$
BEGIN
    IF (NEW.cantidad > (SELECT stock FROM productos WHERE id_producto = NEW.id_producto)) THEN
        RAISE EXCEPTION 'No hay suficiente stock para el producto %', NEW.id_producto;
    ELSE
        UPDATE productos
        SET stock = stock - NEW.cantidad
        WHERE id_producto = NEW.id_producto;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tg_actualizar_stock
AFTER INSERT ON ventas_detalle
FOR EACH ROW
EXECUTE FUNCTION actualizar_stock_producto();

d) Trigger para actualizar el saldo del cliente tras una venta

sql

-- Trigger para actualizar el saldo del cliente tras una venta
CREATE OR REPLACE FUNCTION actualizar_saldo_cliente()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE clientes 
    SET saldo = saldo - NEW.total
    WHERE id_cliente = NEW.id_cliente;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tg_actualizar_saldo
AFTER INSERT ON ventas
FOR EACH ROW
EXECUTE FUNCTION actualizar_saldo_cliente();

3. Consultas de ejemplo
a) Obtener el perfume más vendido en un rango de fechas

sql

SELECT * FROM perfume_mas_vendido('2023-01-01', '2023-12-31');

b) Obtener los 3 perfumes más vendidos en un año específico

sql

SELECT * FROM top_perfumes_por_ano(2023, 3);

4. Relaciones entre tablas clave

    Relación entre clientes y ventas: Un cliente puede realizar muchas ventas, pero una venta solo puede estar asociada a un cliente.
    Relación entre productos y detalle de ventas: Cada producto puede estar en muchas ventas, y cada venta puede contener varios productos.
    Relación entre vendedores y ventas: Cada vendedor puede realizar muchas ventas.
    Relación entre productos y vendedores: Un vendedor puede tener muchos productos en su inventario, pero un producto puede pertenecer a varios vendedores.

5. Índices y optimización

    Índices para búsquedas rápidas: Los índices creados sobre cedula en la tabla clientes, código de barras en productos, y fechas en ventas aseguran que las consultas más comunes sean rápidas.
    Optimización de stock: El trigger para actualizar el stock tras una venta asegura que no se vendan más productos de los que hay en inventario.
    Seguridad e integridad: Las referencias entre tablas y las restricciones de claves ajenas mantienen la integridad de los datos, especialmente en ventas y detalles de ventas.

Este diseño proporciona una estructura sólida, elimina redundancias y facilita la gestión de clientes, productos y ventas en tu sistema. ¡Con esto ya puedes empezar la base de datos y ajustarla según las necesidades de Gabriela Fragancias!
Tú dijiste:
y las tablas, personas, cédulas, ruc, antecedentes judiciales, rutas, vehículos, maletines, ciudades, municipios, departamentos, gps
ChatGPT Plus
ChatGPT

¡Entendido! Vamos a incorporar las tablas adicionales que mencionas, como personas, cédulas, RUC, antecedentes judiciales, rutas, vehículos, maletines, ciudades, municipios, departamentos y GPS. Estas tablas se integrarán con las tablas ya definidas para mantener una estructura lógica y consistente.
1. Creación de Tablas Adicionales
a) Tabla Personas

sql

CREATE TABLE personas (
    id_persona SERIAL PRIMARY KEY,
    cedula VARCHAR(20) UNIQUE NOT NULL,
    nombre VARCHAR(100) NOT NULL,
    apellido VARCHAR(100) NOT NULL,
    fecha_nacimiento DATE NOT NULL,
    direccion TEXT NOT NULL,
    telefono VARCHAR(20),
    email VARCHAR(100) UNIQUE,
    zona VARCHAR(50),
    fecha_registro DATE DEFAULT CURRENT_DATE
);

b) Tabla Cédulas

sql

CREATE TABLE cedulas (
    numero_ci VARCHAR(20) PRIMARY KEY,
    nombre VARCHAR(100) NOT NULL,
    apellido VARCHAR(100) NOT NULL,
    fecha_nacimiento DATE NOT NULL,
    direccion TEXT NOT NULL
);

c) Tabla RUC

sql

CREATE TABLE ruc (
    id_ruc SERIAL PRIMARY KEY,
    numero_ruc VARCHAR(20) UNIQUE NOT NULL,
    digito_verificador INT NOT NULL,
    razon_social VARCHAR(100) NOT NULL
);

d) Tabla Antecedentes Judiciales

sql

CREATE TABLE antecedentes_judiciales (
    id_antecedente SERIAL PRIMARY KEY,
    numero_ci VARCHAR(20) REFERENCES cedulas(numero_ci),
    causa_penal TEXT NOT NULL
);

e) Tabla Vehículos

sql

CREATE TABLE vehiculos (
    id_vehiculo SERIAL PRIMARY KEY,
    placa VARCHAR(20) UNIQUE NOT NULL,
    marca VARCHAR(50),
    modelo VARCHAR(50),
    anio INT,
    chasis VARCHAR(50),
    motor VARCHAR(50),
    ultima_revision DATE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

f) Tabla Rutas (vendedores y geolocalización)

sql

CREATE TABLE rutas (
    id_ruta SERIAL PRIMARY KEY,
    id_vendedor INTEGER REFERENCES vendedores(id_vendedor),
    nombre_ruta VARCHAR(100) NOT NULL,
    fecha DATE DEFAULT CURRENT_DATE,
    zona VARCHAR(50),
    id_vehiculo INTEGER REFERENCES vehiculos(id_vehiculo),
    coordenadas GEOGRAPHY(POINT, 4326) -- Integración con GIS para geolocalización
);

g) Tabla Maletines

sql

CREATE TABLE maletines (
    id_maletin SERIAL PRIMARY KEY,
    descripcion VARCHAR(255) NOT NULL,
    fecha_asignacion DATE DEFAULT CURRENT_DATE
);

-- Inventario de Maletines
CREATE TABLE inventario_maletines (
    id_inventario SERIAL PRIMARY KEY,
    id_maletin INTEGER REFERENCES maletines(id_maletin),
    id_producto INTEGER REFERENCES productos(id_producto),
    id_vendedor INTEGER REFERENCES vendedores(id_vendedor),
    cantidad INTEGER NOT NULL
);

h) Tabla de Geolocalización (GPS)

sql

CREATE TABLE tracking_gps (
    id_tracking SERIAL PRIMARY KEY,
    id_vehiculo INTEGER REFERENCES vehiculos(id_vehiculo),
    coordenadas GEOGRAPHY(POINT, 4326), -- Para almacenar latitud y longitud
    latitud DECIMAL(9,6),
    longitud DECIMAL(9,6),
    fecha_hora TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

i) Tablas Ciudades, Municipios y Departamentos

sql

-- Tabla Departamento
CREATE TABLE departamentos (
    id_departamento SERIAL PRIMARY KEY,
    nombre_departamento VARCHAR(100) NOT NULL,
    codigo_departamento VARCHAR(10) UNIQUE NOT NULL
);

-- Tabla Municipio
CREATE TABLE municipios (
    id_municipio SERIAL PRIMARY KEY,
    id_departamento INTEGER REFERENCES departamentos(id_departamento),
    nombre_municipio VARCHAR(100) NOT NULL,
    codigo_municipio VARCHAR(10) UNIQUE NOT NULL
);

-- Tabla Zona o Ciudad
CREATE TABLE zonas (
    id_zona SERIAL PRIMARY KEY,
    id_municipio INTEGER REFERENCES municipios(id_municipio),
    nombre_zona VARCHAR(100) NOT NULL,
    codigo_zona VARCHAR(10) UNIQUE NOT NULL,
    geometria GEOGRAPHY(POLYGON, 4326) -- Definición de zonas geográficas
);

2. Funciones y Triggers Relacionados
a) Función para Verificar Antecedentes Judiciales

sql

-- Función para verificar si una persona tiene antecedentes judiciales
CREATE OR REPLACE FUNCTION verificar_antecedentes()
RETURNS TRIGGER AS $$
BEGIN
    IF EXISTS (SELECT 1 FROM antecedentes_judiciales WHERE numero_ci = NEW.cedula) THEN
        RAISE NOTICE 'La persona con cédula % tiene antecedentes judiciales', NEW.cedula;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger que llama a la función al insertar un cliente
CREATE TRIGGER tg_verificar_antecedentes
BEFORE INSERT ON clientes
FOR EACH ROW
EXECUTE FUNCTION verificar_antecedentes();

b) Trigger para Registrar Ubicación GPS

sql

-- Función para registrar ubicaciones GPS
CREATE OR REPLACE FUNCTION registrar_gps()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO tracking_gps (id_vehiculo, coordenadas, latitud, longitud)
    VALUES (NEW.id_vehiculo, ST_SetSRID(ST_MakePoint(NEW.longitud, NEW.latitud), 4326), NEW.latitud, NEW.longitud);
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger que se ejecuta tras registrar una ubicación GPS
CREATE TRIGGER tg_registrar_gps
AFTER INSERT ON tracking_gps
FOR EACH ROW
EXECUTE FUNCTION registrar_gps();

3. Relaciones Clave

    Clientes y Personas: La tabla personas puede utilizarse para almacenar información adicional sobre las personas, como sus cédulas y contactos. Los clientes pueden estar relacionados con personas si hay un esquema más complejo.
    Rutas y Vehículos: Los vendedores pueden estar asignados a rutas, y cada ruta puede tener asociado un vehículo para facilitar la movilidad y el seguimiento GPS.
    Antecedentes Judiciales: Se verifica si los clientes tienen antecedentes judiciales antes de ser ingresados, lo que podría afectar las decisiones comerciales.
    Geolocalización: Las rutas están asociadas con zonas geográficas (ciudades, municipios, departamentos) para un mejor control territorial.

4. Consultas de Ejemplo
a) Consulta de Clientes con Antecedentes Judiciales

sql

SELECT p.nombre, p.apellido, a.causa_penal
FROM personas p
INNER JOIN antecedentes_judiciales a ON p.cedula = a.numero_ci;

b) Consulta de Vehículos Asignados a Vendedores

sql

SELECT v.nombre, v.apellido, veh.marca, veh.modelo, veh.placa
FROM vendedores v
INNER JOIN rutas r ON v.id_vendedor = r.id_vendedor
INNER JOIN vehiculos veh ON r.id_vehiculo = veh.id_vehiculo;

c) Consulta de Geolocalización de Vehículos

sql

SELECT veh.placa, t.latitud, t.longitud, t.fecha_hora
FROM vehiculos veh
INNER JOIN tracking_gps t ON veh.id_vehiculo = t.id_vehiculo
ORDER BY t.fecha_hora DESC;

5. Índices y Optimización

    Índices Geográficos: Utiliza índices de tipo GEOGRAPHY para optimizar consultas relacionadas con geolocalización.
    Índices por CI y RUC: Crea índices en las tablas cedulas y ruc para mejorar las búsquedas basadas en esos números únicos.

Resumen

Este diseño completo incorpora las tablas adicionales que mencionaste, manteniendo una estructura bien organizada y lógica. Cada tabla tiene relaciones claras con las demás, y los triggers y funciones aseguran que las reglas de negocio (como el manejo de antecedentes judiciales y geolocalización) se manejen automáticamente. Este esquema te permitirá gestionar clientes, ventas, rutas, vehículos, y mucho más de manera eficiente.

CREATE DATABASE Gabriela_Fragancias;
-- Tabla Empresa
CREATE TABLE Empresa (
    id_empresa SERIAL PRIMARY KEY,
    ruc VARCHAR(20) UNIQUE NOT NULL,
    razon_social VARCHAR(100) NOT NULL,
    -- Otros campos específicos para Empresa
);

-- Tabla Usuario
CREATE TABLE Usuario (
    id_usuario SERIAL PRIMARY KEY,
    nombre_usuario VARCHAR(100) NOT NULL,
    contrasena VARCHAR(100) NOT NULL,
    rol VARCHAR(50) NOT NULL,
    -- Otros campos específicos para Usuario
);

-- Tabla Personas (con alerta de defunción)
CREATE TABLE Personas (
    id_persona SERIAL PRIMARY KEY,
    cedula VARCHAR(20) UNIQUE NOT NULL,
    nombre VARCHAR(100) NOT NULL,
    apellido VARCHAR(100) NOT NULL,
    fecha_nacimiento DATE NOT NULL,
    direccion TEXT NOT NULL,
    departamento VARCHAR(100),
    distrito_municipio VARCHAR(100),
    barrio_localidad VARCHAR(100),
    zona VARCHAR(100),
    telefono VARCHAR(20),
    email VARCHAR(100) UNIQUE,
    orden_captura INTEGER,
    causa TEXT,
    observacion TEXT,
    descripcion_estado TEXT,
    tipo_pol_mil VARCHAR(50),
    grado_pol_mil VARCHAR(50),	
    fecha_defuncion DATE,  -- Campo para gestionar defunciones
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- Trigger para alerta de defunción
CREATE OR REPLACE FUNCTION verificar_defuncion() 
RETURNS TRIGGER AS $$
BEGIN
    IF (NEW.fecha_defuncion IS NOT NULL) THEN
        RAISE NOTICE 'La persona con cédula % ha sido marcada como fallecida.', NEW.cedula;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tg_verificar_defuncion
AFTER INSERT OR UPDATE ON Personas
FOR EACH ROW
EXECUTE FUNCTION verificar_defuncion();

-- Tabla de Clientes
CREATE TABLE Clientes (
    id_cliente SERIAL PRIMARY KEY,
	tarjeta VARCHAR(7) UNIQUE NOT NULL,  -- Número de tarjeta obligatorio y valor reemplazado por otro cliente y zona
    id_persona INTEGER REFERENCES Persona(id_persona),
    cedula VARCHAR(20) UNIQUE NOT NULL,
    nombre VARCHAR(100) NOT NULL,
    apellido VARCHAR(100) NOT NULL,
    telefono VARCHAR(20),
    direccion TEXT,
    email VARCHAR(100),
    ruc VARCHAR(20) UNIQUE,
    fecha_registro DATE DEFAULT CURRENT_DATE,
    tipo_pago VARCHAR(20) CHECK (tipo_pago IN ('SEM', 'QUIN', 'MENS')),  -- SEM (semanal), QUIN (quincenal), MENS (mensual)
    saldo DECIMAL(10, 2) DEFAULT 0
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- Tabla Productos
CREATE TABLE Productos (
    id_producto SERIAL PRIMARY KEY,
    codigo_barras VARCHAR(50) UNIQUE NOT NULL,
    nombre VARCHAR(100) NOT NULL,
    id_marca INTEGER REFERENCES Marcas(id_marca),
    precio_contado DECIMAL(10, 2) NOT NULL,
    precio_credito DECIMAL(10, 2) NOT NULL,
    stock INTEGER NOT NULL,
    descripcion TEXT,
    presentacion VARCHAR(50),
    volumen INT CHECK (volumen BETWEEN 5 AND 200),
    es_kit BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- Trigger para actualizar el stock de productos después de una venta
CREATE OR REPLACE FUNCTION actualizar_stock_producto() 
RETURNS TRIGGER AS $$
BEGIN
    IF (NEW.cantidad > (SELECT stock FROM Productos WHERE id_producto = NEW.id_producto)) THEN
        RAISE EXCEPTION 'No hay suficiente stock para este producto';
    ELSE
        UPDATE Productos 
        SET stock = stock - NEW.cantidad 
        WHERE id_producto = NEW.id_producto;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tg_actualizar_stock
AFTER INSERT ON Ventas
FOR EACH ROW
EXECUTE FUNCTION actualizar_stock_producto();

-- Tabla de Marcas
CREATE TABLE Marcas (
    ID_Marca INT PRIMARY KEY AUTO_INCREMENT,
    Nombre VARCHAR(100) NOT NULL,
    Año_Fundacion INT,
    Sede VARCHAR(100),
    Sitio_Web VARCHAR(255),
    UNIQUE (Nombre)
);

-- Tabla de Perfumistas
CREATE TABLE Perfumistas (
    ID_Perfumista INT PRIMARY KEY AUTO_INCREMENT,
    Nombre VARCHAR(100) NOT NULL,
    Apellido VARCHAR(100) NOT NULL,
    Nacionalidad VARCHAR(50),
    UNIQUE (Nombre, Apellido)
);

-- Tabla de Notas Olfativas
CREATE TABLE Notas_Olfativas (
    ID_Nota INT PRIMARY KEY AUTO_INCREMENT,
    Nombre VARCHAR(50) NOT NULL,
    Descripcion TEXT,
    UNIQUE (Nombre)
);

-- Tabla de relación entre Productos y Notas Olfativas
CREATE TABLE Producto_Notas (
    ID_Producto INT,
    ID_Nota INT,
    Tipo_Nota ENUM('Alta', 'Media', 'Base'),
    PRIMARY KEY (ID_Producto, ID_Nota, Tipo_Nota),
    FOREIGN KEY (ID_Producto) REFERENCES Productos(ID_Producto),
    FOREIGN KEY (ID_Nota) REFERENCES Notas_Olfativas(ID_Nota)
);

-- Tabla de Productos (Perfumes)
CREATE TABLE Productos (
    ID_Producto INT PRIMARY KEY AUTO_INCREMENT,
    ID_Marca INT,
    Nombre VARCHAR(100) NOT NULL,
	Año_Lanzamiento INT,
    ID_Perfumista INT,
    Codigo_Barras VARCHAR(13) UNIQUE,
    Precio_Costo DECIMAL(10, 2),
    Precio_Venta DECIMAL(10, 2),
    Duracion_Horas INT,
    Stock INT DEFAULT 0,
    FOREIGN KEY (ID_Marca) REFERENCES Marcas(ID_Marca),
    FOREIGN KEY (ID_Perfumista) REFERENCES Perfumistas(ID_Perfumista)
);

-- Tabla Presentacion
CREATE TABLE Presentacion (
    id_presentacion SERIAL PRIMARY KEY,
    id_perfume INTEGER REFERENCES Perfume(id_perfume) ON DELETE CASCADE,
    codigo_barra VARCHAR(50) UNIQUE NOT NULL,
    tamano_ml INTEGER CHECK (tamano_ml > 0),
    imagen_url VARCHAR(255)
);

-- Tabla de Vendedores
CREATE TABLE Vendedores (
    id_vendedor SERIAL PRIMARY KEY,
    id_zona INTEGER REFERENCES Zona(id_zona);
	nombre VARCHAR(100) NOT NULL,
    zona VARCHAR(50) NOT NULL,
    comision DECIMAL(10, 2) DEFAULT 50000
);

-- Tabla de Inventario por Vendedora
CREATE TABLE Inventario (
    id_inventario SERIAL PRIMARY KEY,
    id_vendedor INTEGER REFERENCES Vendedores(id_vendedor),
    id_producto INTEGER REFERENCES Productos(id_producto),
    cantidad INTEGER NOT NULL
);

-- Tabla Ventas
CREATE TABLE Ventas (
    id_venta SERIAL PRIMARY KEY,
    id_cliente INTEGER REFERENCES Clientes(id_cliente),
    id_producto INTEGER REFERENCES Productos(id_producto),
    fecha DATE DEFAULT CURRENT_DATE,
    forma_pago VARCHAR(20) CHECK (forma_pago IN ('Contado', 'Crédito')),  -- Contado, Crédito (SEM, QUIN, MENS)
    total DECIMAL(10, 2) NOT NULL,
    saldo DECIMAL(10, 2) DEFAULT 0,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- Trigger para actualizar el saldo de los clientes tras una venta
CREATE OR REPLACE FUNCTION actualizar_saldo_cliente() 
RETURNS TRIGGER AS $$
BEGIN
    UPDATE Clientes 
    SET saldo = saldo - NEW.total
    WHERE id_cliente = NEW.id_cliente;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tg_actualizar_saldo
AFTER INSERT ON Ventas
FOR EACH ROW
EXECUTE FUNCTION actualizar_saldo_cliente();

-- Tabla Pagos
CREATE TABLE Pagos (
    id_pago SERIAL PRIMARY KEY,
    id_cliente INTEGER REFERENCES Clientes(id_cliente),
    id_venta INTEGER REFERENCES Ventas(id_venta),
    fecha_pago DATE DEFAULT CURRENT_DATE,
    monto DECIMAL(10, 2) NOT NULL,
    metodo_pago VARCHAR(20) CHECK (metodo_pago IN ('Efectivo', 'Tarjeta', 'Transferencia')),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- Tabla Cédula
CREATE TABLE Cedula (
    numero_ci VARCHAR(20) PRIMARY KEY,
    nombre VARCHAR(100) NOT NULL,
    apellido VARCHAR(100) NOT NULL,
    fecha_nacimiento DATE NOT NULL,
    direccion TEXT NOT NULL
);

-- Tabla AntecedentesJudiciales
CREATE TABLE AntecedentesJudiciales (
    id_antecedente SERIAL PRIMARY KEY,
    numero_ci VARCHAR(20) REFERENCES Cedula(numero_ci),
    causa_penal TEXT
);

-- Tabla de RUC
CREATE TABLE ruc (
    id_ruc SERIAL PRIMARY KEY,
    numero_ruc VARCHAR(20) UNIQUE NOT NULL,
    digito_verificador INT NOT NULL,
    razon_social VARCHAR(100) NOT NULL
);

-- Tabla Inventario_Maletines (para manejar los productos en los maletines de vendedoras)
CREATE TABLE Inventario_Maletines (
    id_inventario SERIAL PRIMARY KEY,
    id_maletin INTEGER REFERENCES Maletines(id_maletin),
    id_producto INTEGER REFERENCES Productos(id_producto),
    id_vendedor INTEGER REFERENCES Vendedores(id_vendedor),
    fecha_carga DATE DEFAULT CURRENT_DATE,
	cantidad INTEGER NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- Tabla Productos de Maletines
CREATE TABLE productos_maletin (
    id_maletin INT REFERENCES maletines(id_maletin),
    id_producto INT REFERENCES productos(id_producto),
    cantidad INT,
    PRIMARY KEY (id_maletin, id_producto)
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP NULL DEFAULT NULL
);

-- Tabla de Liquidaciones
CREATE TABLE liquidaciones (
    id_liquidacion SERIAL PRIMARY KEY,
    id_empleado INT REFERENCES empleados(id_empleado),
    fecha_liquidacion DATE DEFAULT CURRENT_DATE,
    total_ventas DECIMAL(10, 2),
    comision DECIMAL(10, 2),
    total_pagar DECIMAL(10, 2)
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP NULL DEFAULT NULL
);

-- Tabla de Vehículos
CREATE TABLE vehiculos (
    id_vehiculo SERIAL PRIMARY KEY,
    placa VARCHAR(20) UNIQUE,
    marca VARCHAR(50), CHARACTER SET utf8mb4;
    modelo VARCHAR(50), CHARACTER SET utf8mb4;
    año INT,
	chassis VARCHAR(50), CHARACTER SET utf8mb4;
	motor VARCHAR(50), CHARACTER SET utf8mb4;
    ultima_revision DATE
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP NULL DEFAULT NULL
);

-- Tabla de Gastos de Vehículos
CREATE TABLE gastos_vehiculos (
    id_gasto SERIAL PRIMARY KEY,
    id_vehiculo INT REFERENCES vehiculos(id_vehiculo),
    tipo_gasto VARCHAR(50) CHECK (tipo_gasto IN ('Combustible', 'Lubricantes', 'Gomería', 'Mecánica', 'Electricidad', 'Otro')); CHARACTER SET utf8mb4;
    monto DECIMAL(10, 2),
    fecha DATE DEFAULT CURRENT_DATE
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP NULL DEFAULT NULL
);

-- Tabla Rutas (para vendedores y manejo de geolocalización)
CREATE TABLE Rutas (
    id_ruta SERIAL PRIMARY KEY,
    id_vendedor INTEGER REFERENCES Vendedores(id_vendedor),
    nombre_ruta VARCHAR(100) NOT NULL,
    fecha DATE DEFAULT CURRENT_DATE,
    zona VARCHAR(50),
    id_vehiculo INTEGER REFERENCES Vehiculo(id_vehiculo),
	coordenadas GEOGRAPHY(POINT, 4326)  -- Integración con GIS
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- Tabla de Tracking GPS
CREATE TABLE tracking_gps (
    id_tracking SERIAL PRIMARY KEY,
    id_vehiculo INT REFERENCES vehiculos(id_vehiculo),
	coordenadas GEOGRAPHY(Point, 4326);
    latitud DECIMAL(9, 6),
    longitud DECIMAL(9, 6),
    fecha_hora TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Tabla de Proveedores
CREATE TABLE proveedores (
    id_proveedor SERIAL PRIMARY KEY,
    ruc VARCHAR(20) UNIQUE,
    nombre VARCHAR(100) NOT NULL, CHARACTER SET utf8mb4;
    direccion TEXT, CHARACTER SET utf8mb4;
    telefono VARCHAR(20),
    email VARCHAR(100) CHARACTER SET utf8mb4;
);

-- Tabla de Compras a Proveedores
CREATE TABLE compras_proveedores (
    id_compra SERIAL PRIMARY KEY,
    id_proveedor INT REFERENCES proveedores(id_proveedor),
    fecha_compra DATE DEFAULT CURRENT_DATE,
    total DECIMAL(10, 2)
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP NULL DEFAULT NULL
);

-- Tabla de Detalles de Compra
CREATE TABLE detalles_compra (
    id_detalle SERIAL PRIMARY KEY,
    id_compra INT REFERENCES compras_proveedores(id_compra),
    id_producto INT REFERENCES productos(id_producto),
    cantidad INT,
    precio_unitario DECIMAL(10, 2),
    subtotal DECIMAL(10, 2)
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP NULL DEFAULT NULL
);

-- Tabla Departamento
CREATE TABLE Departamento (
    id_departamento SERIAL PRIMARY KEY,
    nombre_departamento VARCHAR(100) NOT NULL, CHARACTER SET utf8mb4;
    codigo_departamento VARCHAR(10) UNIQUE NOT NULL
);

-- Tabla Municipio
CREATE TABLE Municipio (
    id_municipio SERIAL PRIMARY KEY,
    id_departamento INTEGER REFERENCES Departamento(id_departamento),
    nombre_municipio VARCHAR(100) NOT NULL, CHARACTER SET utf8mb4;
    codigo_municipio VARCHAR(10) UNIQUE NOT NULL
);

-- Tabla Zona
CREATE TABLE Zona (
    id_zona SERIAL PRIMARY KEY,
    id_municipio INTEGER REFERENCES Municipio(id_municipio),
    nombre_zona VARCHAR(100) NOT NULL, CHARACTER SET utf8mb4;
    codigo_zona VARCHAR(10) UNIQUE NOT NULL,
    geometria GEOGRAPHY(POLYGON, 4326)
);

-- Tabla Ubicacion
CREATE TABLE Ubicacion (
    id_ubicacion SERIAL PRIMARY KEY,
    id_vendedor INTEGER REFERENCES Vendedor(id_vendedor),
    fecha_hora TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    coordenadas GEOGRAPHY(POINT, 4326)
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP NULL DEFAULT NULL
);

-- Tabla de Equipos (para manejar lectores de códigos, impresoras, etc.)
CREATE TABLE equipos (
    id_equipo SERIAL PRIMARY KEY,
    tipo VARCHAR(50) CHECK (tipo IN ('Lector Código Barras', 'Impresora Ticket', 'Impresora Matricial', 'Impresora Láser', 'Impresora Inyección')),
    marca VARCHAR(50), CHARACTER SET utf8mb4;
    modelo VARCHAR(50), CHARACTER SET utf8mb4;
    fecha_adquisicion DATE
);

-- Índices para optimizar consultas frecuentes
CREATE INDEX idx_productos_marca ON Productos(ID_Marca);
CREATE INDEX idx_ventas_cliente ON Ventas(ID_Cliente);
CREATE INDEX idx_ventas_fecha ON Ventas(Fecha_Venta);
CREATE INDEX idx_inventario_producto ON Inventario(ID_Producto);

-- Índices para mejorar el rendimiento
CREATE INDEX idx_clientes_cedula ON clientes(cedula);
CREATE INDEX idx_clientes_ruc ON clientes(ruc);
CREATE INDEX idx_productos_codigo_barras ON productos(codigo_barras);
CREATE INDEX idx_ventas_fecha ON ventas(fecha_venta);
CREATE INDEX idx_empleados_cargo ON empleados(cargo);
CREATE INDEX idx_cliente_cedula ON Cliente(cedula);

-- Trigger que ejecuta la función al insertar una venta
CREATE TRIGGER tg_actualizar_saldo
AFTER INSERT ON Ventas
FOR EACH ROW
EXECUTE FUNCTION actualizar_saldo_cliente();
CREATE OR REPLACE FUNCTION actualizar_stock_producto() 
RETURNS TRIGGER AS $$
BEGIN
    IF (NEW.cantidad > (SELECT stock FROM Productos WHERE id_producto = NEW.id_producto)) THEN
        RAISE EXCEPTION 'No hay suficiente stock para este producto';
    ELSE
        UPDATE Productos 
        SET stock = stock - NEW.cantidad 
        WHERE id_producto = NEW.id_producto;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION actualizar_saldo_cliente() 
RETURNS TRIGGER AS $$
BEGIN
    UPDATE Clientes 
    SET saldo = saldo - NEW.total
    WHERE id_cliente = NEW.id_cliente;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger que ejecuta la función al insertar una venta
CREATE TRIGGER tg_actualizar_stock
AFTER INSERT ON Ventas
FOR EACH ROW
EXECUTE FUNCTION actualizar_stock_producto();

-- Función para verificar antecedentes judiciales al insertar un cliente
CREATE OR REPLACE FUNCTION verificar_antecedentes_judiciales()
RETURNS TRIGGER AS $$
BEGIN
    IF EXISTS (
        SELECT 1 FROM AntecedentesJudiciales
        WHERE numero_ci = NEW.cedula
    ) THEN
        RAISE NOTICE 'El cliente con cédula % tiene antecedentes judiciales', NEW.cedula;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger para llamar a la función al insertar un cliente
CREATE TRIGGER tg_verificar_antecedentes_judiciales
BEFORE INSERT ON Clientes
FOR EACH ROW
EXECUTE FUNCTION verificar_antecedentes_judiciales();

-- Trigger para actualizar el stock al vender
CREATE OR REPLACE FUNCTION actualizar_stock() RETURNS TRIGGER AS $$
BEGIN
    IF NEW.cantidad > OLD.stock THEN
        RAISE EXCEPTION 'No hay suficiente stock';
    ELSE
        UPDATE Inventario SET stock = stock - NEW.cantidad WHERE id_presentacion = NEW.id_presentacion;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tg_actualizar_stock
AFTER INSERT ON DetalleVenta
FOR EACH ROW EXECUTE FUNCTION actualizar_stock();

CREATE OR REPLACE FUNCTION actualizar_saldo_cliente() 
RETURNS TRIGGER AS $$
BEGIN
    UPDATE Clientes 
    SET saldo = saldo - NEW.total
    WHERE id_cliente = NEW.id_cliente;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Vistas para reportes comunes
CREATE VIEW VW_Ventas_Por_Cliente AS
SELECT 
    c.ID_Cliente, 
    c.Nombre, 
    c.Apellido, 
    COUNT(v.ID_Venta) AS Total_Ventas, 
    SUM(v.Total) AS Monto_Total
FROM 
    Clientes c
LEFT JOIN 
    Ventas v ON c.ID_Cliente = v.ID_Cliente
GROUP BY 
    c.ID_Cliente;

CREATE VIEW VW_Stock_Productos AS
SELECT 
    p.ID_Producto, 
    p.Nombre, 
    m.Nombre AS Marca, 
    p.Stock, 
    p.Precio_Venta
FROM 
    Productos p
JOIN 
    Marcas m ON p.ID_Marca = m.ID_Marca;

-- Trigger para verificar si un cliente tiene antecedentes judiciales
CREATE OR REPLACE FUNCTION verificar_antecedentes() 
RETURNS TRIGGER AS $$
BEGIN
    IF EXISTS (SELECT 1 FROM AntecedentesJudiciales WHERE cedula = NEW.cedula) THEN
        RAISE NOTICE 'El cliente con cédula % tiene antecedentes judiciales', NEW.cedula;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tg_verificar_antecedentes
BEFORE INSERT ON Clientes
FOR EACH ROW
EXECUTE FUNCTION verificar_antecedentes();

-- Trigger para actualizar la comisión de las vendedoras tras una venta
CREATE OR REPLACE FUNCTION actualizar_comision_vendedora() 
RETURNS TRIGGER AS $$
BEGIN
    UPDATE Liquidaciones 
    SET total_ventas = total_ventas + NEW.total,
        comision = comision + (50000 * NEW.cantidad)  -- Comisión por producto
    WHERE id_vendedor = NEW.id_vendedor;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tg_actualizar_comision
AFTER INSERT ON Ventas
FOR EACH ROW
EXECUTE FUNCTION actualizar_comision_vendedora();

-- Índices faltantes para optimización de consultas
CREATE INDEX idx_rutas_vendedor_fecha ON Rutas(id_vendedor, fecha);
CREATE INDEX idx_pagos_cliente_metodo ON Pagos(id_cliente, metodo_pago);
CREATE INDEX idx_antecedentes_cedula ON AntecedentesJudiciales(cedula);
CREATE INDEX idx_inventario_maletines_producto ON Inventario_Maletines(id_maletin, id_producto);
CREATE INDEX idx_vehiculos_motor_chasis_placa ON Vehiculos(numero_motor, numero_chasis, placa);

-- Trigger para verificar si un cliente tiene antecedentes judiciales

CREATE OR REPLACE FUNCTION verificar_antecedentes() 

RETURNS TRIGGER AS $$

BEGIN

    IF EXISTS (SELECT 1 FROM AntecedentesJudiciales WHERE cedula = NEW.cedula) THEN

        RAISE NOTICE 'El cliente con cédula % tiene antecedentes judiciales', NEW.cedula;

    END IF;

    RETURN NEW;

END;

$$ LANGUAGE plpgsql;


CREATE TRIGGER tg_verificar_antecedentes

BEFORE INSERT ON Clientes

FOR EACH ROW

EXECUTE FUNCTION verificar_antecedentes();


-- Trigger para actualizar la comisión de las vendedoras tras una venta

CREATE OR REPLACE FUNCTION actualizar_comision_vendedora() 

RETURNS TRIGGER AS $$

BEGIN

    UPDATE Liquidaciones 

    SET total_ventas = total_ventas + NEW.total,

        comision = comision + (50000 * NEW.cantidad)  -- Comisión por producto

    WHERE id_vendedor = NEW.id_vendedor;

    RETURN NEW;

END;

$$ LANGUAGE plpgsql;


CREATE TRIGGER tg_actualizar_comision

AFTER INSERT ON Ventas

FOR EACH ROW

EXECUTE FUNCTION actualizar_comision_vendedora();


-- Índices faltantes para optimización de consultas

CREATE INDEX idx_rutas_vendedor_fecha ON Rutas(id_vendedor, fecha);

CREATE INDEX idx_pagos_cliente_metodo ON Pagos(id_cliente, metodo_pago);

CREATE INDEX idx_antecedentes_cedula ON AntecedentesJudiciales(cedula);

CREATE INDEX idx_inventario_maletines_producto ON Inventario_Maletines(id_maletin, id_producto);

CREATE INDEX idx_vehiculos_motor_chasis_placa ON Vehiculos(numero_motor, numero_chasis, placa);

Trigger verificar_antecedentes

    Función: Verifica si un cliente tiene antecedentes judiciales al momento de registrarse.
    Observación: Es una función sencilla y efectiva para su propósito. El uso de RAISE NOTICE es útil para informar sobre la existencia de antecedentes, pero en un entorno productivo, podrías considerar registrar esta información en un log o enviar una notificación a un usuario específico.

Trigger actualizar_comision_vendedora

    Función: Actualiza la comisión de una vendedora cada vez que se registra una nueva venta.
    Observaciones:
        Cálculo de la comisión: La fórmula (50000 * NEW.cantidad) asume que la comisión es fija por producto. Si la comisión varía según el producto o la vendedora, deberías ajustar esta lógica.
        Tabla Liquidaciones: ¿La tabla Liquidaciones se actualiza con cada venta o se utiliza para calcular comisiones periódicamente? Si se actualiza con cada venta, podrías considerar agrupar las ventas por vendedor y periodo para generar un resumen más preciso de las comisiones.
        Concurrencia: Si hay múltiples transacciones simultáneas, este trigger podría generar problemas de concurrencia al actualizar la misma fila en la tabla Liquidaciones. Podrías utilizar transacciones o bloqueos para evitar esto.

Análisis de los Índices

    Función: Los índices mejoran el rendimiento de las consultas al reducir la cantidad de datos que deben ser escaneados.
    Observaciones:
        Selección de columnas: Los índices creados parecen estar bien seleccionados, considerando las columnas más utilizadas en las consultas.
        Cardinalidad: Es importante monitorear la cardinalidad de los índices (cantidad de valores únicos) para asegurar que estén siendo utilizados de manera eficiente.
        Tamaño de la tabla: Si las tablas son muy grandes, podrías considerar crear índices compuestos o particionar las tablas para mejorar el rendimiento.

Sugerencias Adicionales

    Redundancia: Revisa si hay columnas que contienen información redundante. Por ejemplo, si el nombre y apellido del cliente están almacenados tanto en la tabla Clientes como en la tabla Ventas, podrías eliminar esta redundancia para reducir el espacio de almacenamiento y mejorar la integridad de los datos.
    Normalización: Asegúrate de que las tablas estén normalizadas para evitar anomalías de datos y mejorar la integridad.
    Optimización de consultas: Analiza las consultas más frecuentes y utiliza herramientas como EXPLAIN para identificar cuellos de botella y optimizar el rendimiento.
    Pruebas: Realiza pruebas exhaustivas para verificar que los triggers y funciones funcionen correctamente y no introduzcan errores en la base de datos.

Preguntas para Aclarar

    ¿Cuál es la estructura completa de las tablas involucradas (campos, tipos de datos, relaciones)?
    ¿Qué tipo de consultas se realizan con mayor frecuencia?
    ¿Hay algún requisito específico de rendimiento o escalabilidad?
    ¿Se utilizan otras herramientas de base de datos, como vistas o funciones materializadas?

Ejemplo de Optimización del Trigger actualizar_comision_vendedora:
SQL

CREATE OR REPLACE FUNCTION actualizar_comision_vendedora() 
RETURNS TRIGGER AS $$
BEGIN
    -- Utilizar una transacción para garantizar la consistencia de los datos
    BEGIN
        UPDATE Liquidaciones 
        SET total_ventas = total_ventas + NEW.total,
            comision = comision + (SELECT comisión_por_producto FROM Productos WHERE id_producto = NEW.id_producto) * NEW.cantidad
        WHERE id_vendedor = NEW.id_vendedor;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE NOTICE 'Error al actualizar la comisión: %', SQLERRM;
    END;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

Usa el código con precaución.

Este ejemplo muestra cómo calcular la comisión de forma más flexible, utilizando una tabla Productos para obtener la comisión por producto. También incluye una transacción para garantizar la consistencia de los datos en caso de errores.

Espero que estas observaciones y sugerencias te sean útiles. ¡No dudes en hacer más preguntas!

Basándome en el análisis anterior y las sugerencias proporcionadas, aquí te presento una versión mejorada del código, incorporando las mejoras discutidas y adaptándolo a un escenario más completo:

Consideraciones Adicionales:

    Estructura de tablas: Asumí una estructura de tablas simplificada para este ejemplo. Adapta las tablas y relaciones a tu modelo de datos real.
    Cálculo de comisiones: Se ha introducido una tabla Comisiones para almacenar las comisiones por producto, lo que permite una mayor flexibilidad en el cálculo.
    Logueo de eventos: Se ha agregado un log para registrar los eventos importantes, como la detección de antecedentes judiciales o errores en la actualización de comisiones.
    Manejo de errores: Se han incluido bloques EXCEPTION para manejar errores de manera más robusta.
    Optimizaciones adicionales: Se pueden realizar más optimizaciones dependiendo de la complejidad de tu aplicación y las características del sistema de base de datos.

Código Mejorado:
SQL

-- Tabla para almacenar las comisiones por producto
CREATE TABLE Comisiones (
    id_producto INTEGER,
    comision NUMERIC,
    PRIMARY KEY (id_producto),
    FOREIGN KEY (id_producto) REFERENCES Productos(id_producto)
);

-- Función para registrar eventos en un log
CREATE OR REPLACE FUNCTION registrar_evento(evento TEXT)
RETURNS VOID AS $$
BEGIN
    INSERT INTO Log (fecha, evento) VALUES (NOW(), evento);
END;
$$ LANGUAGE plpgsql;

-- Trigger para verificar antecedentes judiciales y registrar en el log
CREATE OR REPLACE FUNCTION verificar_antecedentes() 
RETURNS TRIGGER AS $$
BEGIN
    IF EXISTS (SELECT 1 FROM AntecedentesJudiciales WHERE cedula = NEW.cedula) THEN
        RAISE NOTICE 'El cliente con cédula % tiene antecedentes judiciales', NEW.cedula;
        PERFORM registrar_evento('Cliente con antecedentes: ' || NEW.cedula);
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger para actualizar la comisión de las vendedoras tras una venta
CREATE OR REPLACE FUNCTION actualizar_comision_vendedora() 
RETURNS TRIGGER AS $$
BEGIN
    BEGIN
        UPDATE Liquidaciones 
        SET total_ventas = total_ventas + NEW.total,
            comision = comision + (SELECT comision FROM Comisiones WHERE id_producto = NEW.id_producto) * NEW.cantidad
        WHERE id_vendedor = NEW.id_vendedor;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            PERFORM registrar_evento('Error al actualizar comisión: ' || SQLERRM);
    END;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Índices adicionales (adapta según tu esquema)
CREATE INDEX idx_liquidaciones_vendedor ON Liquidaciones(id_vendedor);
CREATE INDEX idx_comisiones_producto ON Comisiones(id_producto);

Usa el código con precaución.

Explicación de los cambios:

    Tabla Comisiones: Esta tabla almacena la comisión por producto, permitiendo una gestión más flexible y escalable de las comisiones.
    Función registrar_evento: Esta función simplifica el registro de eventos en un log, lo que puede ser útil para la auditoría y la resolución de problemas.
    Trigger verificar_antecedentes: Se ha agregado una llamada a registrar_evento para documentar la detección de antecedentes judiciales.
    Trigger actualizar_comision_vendedora: Se utiliza la tabla Comisiones para obtener la comisión por producto y se ha mejorado el manejo de errores con un bloque EXCEPTION.
    Índices adicionales: Se ha agregado un índice en la tabla Liquidaciones para mejorar el rendimiento de las actualizaciones de comisiones.

Consideraciones Futuras:

    Optimización de consultas: Utiliza herramientas como EXPLAIN para identificar consultas lentas y optimizarlas.
    Particionamiento: Si las tablas son muy grandes, considera particionarlas para mejorar el rendimiento de las consultas.
    Materialización de vistas: Si hay consultas que se ejecutan con frecuencia, puedes considerar materializarlas como vistas para mejorar el rendimiento.
    Monitoreo: Implementa un sistema de monitoreo para identificar problemas de rendimiento y detectar anomalías en los datos.

Adaptación a tu Esquema:

    Ajuste de tablas y columnas: Asegúrate de que las tablas y columnas coincidan con tu esquema de base de datos.
    Modificación de funciones y triggers: Adapta las funciones y triggers para que se ajusten a tu lógica de negocio específica.
    Creación de índices: Crea índices en las columnas que se utilizan frecuentemente en las cláusulas WHERE, JOIN y ORDER BY de tus consultas.

Recuerda: Esta es solo una propuesta. La optimización de una base de datos es un proceso iterativo que requiere un profundo conocimiento de tu aplicación y de las características del sistema de base de datos que estás utilizando.

Basándome en el código que hemos analizado, puedo inferir una estructura de tablas general para Gabriela Fragancias. Sin embargo, para poder ofrecerte una respuesta más precisa y personalizada, te pediría que me confirmes o corrijas la siguiente estructura:

Posible estructura de tablas:

    Clientes: id_cliente (PK), nombre, apellido, cedula, dirección, teléfono
    Ventas: id_venta (PK), fecha, total, id_cliente (FK), id_vendedor (FK)
    Productos: id_producto (PK), nombre, precio
    Ventas_Detalle: id_venta_detalle (PK), cantidad, id_venta (FK), id_producto (FK)
    Vendedores: id_vendedor (PK), nombre, apellido, comisión_base
    Liquidaciones: id_liquidacion (PK), fecha_inicio, fecha_fin, total_ventas, comision, id_vendedor (FK)
    AntecedentesJudiciales: id_antecedente (PK), descripcion, cedula (FK)
    Rutas: id_ruta (PK), fecha, id_vendedor (FK)
    Pagos: id_pago (PK), fecha, monto, metodo_pago, id_venta (FK)
    Inventario_Maletines: id_inventario_maletin (PK), cantidad, id_maletin (FK), id_producto (FK)
    Maletines: id_maletin (PK), descripcion
    Vehiculos: id_vehiculo (PK), numero_motor, numero_chasis, placa

Relaciones:

    Una venta puede tener muchos productos (relación muchos a muchos a través de Ventas_Detalle).
    Un cliente puede realizar muchas ventas.
    Un vendedor puede realizar muchas ventas y tener muchas rutas.
    Un pago está asociado a una venta.
    Un inventario de maletines contiene varios productos.

Si esta estructura es correcta, podemos profundizar en las siguientes áreas:

    Optimización de consultas: ¿Qué tipo de consultas realizas con mayor frecuencia? Podemos analizarlas y sugerir índices adicionales o ajustes en las consultas para mejorar el rendimiento.
    Diseño de reportes: ¿Qué tipo de reportes necesitas generar? Podemos diseñar vistas o procedimientos almacenados para facilitar la generación de informes personalizados.
    Escalabilidad: ¿Esperas un crecimiento significativo en la cantidad de datos? Podemos evaluar si es necesario realizar particionamiento o replicación de la base de datos.
    Seguridad: ¿Qué medidas de seguridad deseas implementar? Podemos discutir sobre permisos, encriptación de datos y otras medidas para proteger la información.

Por favor, confirma si esta estructura de tablas es correcta y si tienes alguna pregunta adicional.

Además, si puedes proporcionar información sobre:

    El sistema de base de datos que estás utilizando: (MySQL, PostgreSQL, SQL Server, etc.)
    El lenguaje de programación que utilizas: (Python, Java, etc.)
    Las consultas más frecuentes que realizas:

la interfaz será en python, la base en postgresql, las tablas son así como detallas, las consultas más frecuentes son de clientes y saldo, los clientes pueden tener el mismo número de tarjeta pero distinta zona, o a veces se reemplaza un cliente que ha cancelado por uno nuevo, los gráficos que se necesitan son sobre las ventas y zonas

Análisis y Sugerencias Basado en tus Necesidades
Estructura de Tablas y Relación con Python

La estructura de tablas que has propuesto es sólida y cubre los aspectos básicos de un sistema de gestión de clientes y ventas. Para interactuar con esta base de datos desde Python, te recomiendo utilizar un ORM (Object-Relational Mapper) como SQLAlchemy. Esto te permitirá trabajar con los datos de la base de datos como si fueran objetos de Python, simplificando significativamente tu código.
Consultas Frecuentes y Optimización

Dado que las consultas más frecuentes son sobre clientes y saldos, es fundamental crear índices adecuados en las columnas que se utilizan con frecuencia en los criterios de búsqueda (e.g., cedula, nombre, apellido).

Índices Sugeridos:

    Clientes: cedula, nombre, apellido, zona
    Ventas: id_cliente, fecha
    Pagos: id_cliente, fecha

Consideraciones Adicionales:

    Clientes con mismo número de tarjeta y distinta zona: Para manejar esta situación, podrías agregar una columna id_cliente_original en la tabla Clientes para rastrear los reemplazos. Esto te permitirá realizar análisis históricos y comprender mejor la evolución de la base de cliente.
    Gráficos de ventas y zonas: Para generar gráficos, necesitarás agrupar los datos por zona y periodo. Utiliza las funciones de agregación de SQL (SUM, COUNT, etc.) para calcular los totales de ventas por zona.

Código de Ejemplo con SQLAlchemy
Python

from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy import Column, Integer, String,  

 ForeignKey

# Crear una conexión a la base de datos PostgreSQL
engine = create_engine('postgresql://usuario:contraseña@localhost/tu_base_de_datos')
Base = declarative_base()

# Definir las clases que representan las tablas
class Cliente(Base):
    __tablename__ = 'clientes'
    id_cliente = Column(Integer, primary_key=True)
    nombre = Column(String)
    # ... otros campos

class Venta(Base):
    __tablename__ = 'ventas'
    id_venta = Column(Integer, primary_key=True)
    fecha = Column(Date)
    # ... otros campos
    id_cliente = Column(Integer, ForeignKey('clientes.id_cliente'))
    cliente = relationship("Cliente")

# Crear las tablas en la base de datos
Base.metadata.create_all(engine)

# Ejemplo de consulta para obtener el total de ventas por zona en un mes
session = Session(engine)
resultado = session.query(Cliente.zona, func.sum(Venta.total)).join(Venta).group_by(Cliente.zona).all()

Usa el código con precaución.
Visualización de Datos

Para generar los gráficos, puedes utilizar bibliotecas como:

    Matplotlib: Para gráficos básicos y personalizados.
    Seaborn: Para gráficos estadísticos de alta calidad.
    Plotly: Para gráficos interactivos y dashboards.

Ejemplo con Matplotlib:
Python

import matplotlib.pyplot as plt

# Suponiendo que 'resultado' contiene los datos obtenidos de la consulta anterior
zonas = [row[0] for row in resultado]
totales = [row[1] for row in resultado]

plt.bar(zonas, totales)
plt.xlabel('Zona')
plt.ylabel('Total de Ventas')
plt.title('Ventas por Zona')
plt.show()

Usa el código con precaución.
Próximos Pasos

    Refina la estructura de tus tablas: Asegúrate de que incluyan todos los campos necesarios para tu aplicación y que las relaciones entre las tablas sean correctas.
    Crea los índices adecuados: Basándote en las consultas más frecuentes, crea índices para mejorar el rendimiento.
    Implementa las consultas: Utiliza SQLAlchemy para escribir consultas eficientes y flexibles.
    Visualiza los datos: Elige la biblioteca de visualización que mejor se adapte a tus necesidades y crea gráficos informativos.

Preguntas Adicionales:

    ¿Qué tipo de análisis estadístico deseas realizar? (e.g., tendencias de ventas, análisis de clientes)
    ¿Necesitas generar reportes personalizados?
    ¿Quieres implementar un panel de control para visualizar los datos de forma interactiva?

Con esta información adicional, podré brindarte un soporte más específico.
www.dataquest.io

excelente, ahora escribe todo el sql

¡Absolutamente! Para proporcionarte el código SQL completo, necesitaré un poco más de contexto sobre tus requerimientos específicos.

Consideraciones a tener en cuenta:

    Consultas específicas: ¿Qué tipo de información deseas obtener de la base de datos? Por ejemplo:
        ¿Quieres saber el total de ventas por producto en un rango de fechas?
        ¿Deseas identificar a los clientes que más han gastado?
        ¿Necesitas calcular el promedio de ventas por vendedor?
    Filtros y agrupamientos: ¿Qué criterios de búsqueda utilizarás? ¿Necesitarás agrupar los datos por alguna dimensión (e.g., zona, producto, vendedor)?
    Uniones entre tablas: ¿Qué relaciones existen entre las tablas y cómo quieres utilizarlas en tus consultas?

Ejemplo de Consulta Básica:
Supongamos que quieres obtener una lista de todos los clientes con su información de contacto. La consulta SQL sería:
SQL

SELECT * FROM clientes;

Usa el código con precaución.

Ejemplo de Consulta Más Compleja:
Si deseas conocer el total de ventas por producto en el mes de enero de 2023, la consulta podría ser:
SQL

SELECT productos.nombre, SUM(ventas_detalle.cantidad) AS total_vendido
FROM ventas
INNER JOIN ventas_detalle ON ventas.id_venta = ventas_detalle.id_venta
INNER JOIN productos ON ventas_detalle.id_producto = productos.id_producto
WHERE ventas.fecha BETWEEN '2023-01-01' AND '2023-01-31'
GROUP BY productos.nombre;

Usa el código con precaución.

Estructura de una Consulta SQL típica:
SQL

SELECT columna1, columna2, ...
FROM tabla1
INNER JOIN tabla2 ON tabla1.id = tabla2.id  -- Ejemplo de unión
WHERE condición
GROUP BY columna_agrupación
ORDER BY columna_ordenación;

Usa el código con precaución.

Claves para escribir buenas consultas SQL:

    Sé específico: Indica claramente qué datos quieres obtener.
    Utiliza alias: Asigna nombres cortos y descriptivos a las columnas y tablas para mejorar la legibilidad.
    Agrupa y ordena: Utiliza las cláusulas GROUP BY y ORDER BY para organizar los resultados de la consulta.
    Utiliza funciones de agregación: SUM, AVG, COUNT, MIN, MAX para realizar cálculos sobre los datos.
    Optimiza tus consultas: Utiliza índices para acelerar la ejecución de consultas que involucran grandes volúmenes de datos.

Una vez que me proporciones más detalles sobre tus necesidades específicas, podré ayudarte a crear las consultas SQL exactas que necesitas.

Por favor, responde a las siguientes preguntas:

    ¿Qué tipo de informes o análisis deseas realizar con los datos?
    ¿Qué métricas son importantes para tu negocio?
    ¿Hay alguna restricción de rendimiento o escalabilidad?

Con esta información, podremos trabajar juntos para crear un conjunto completo de consultas SQL que te permitan obtener la información que necesitas de manera eficiente y precisa.

Vamos a crear algunas consultas SQL que te permitan obtener información detallada sobre las ventas, incluyendo el perfume más vendido.

Consideraciones adicionales:

    Tabla de productos: Asumiremos que tienes una tabla productos con al menos los campos id_producto y nombre.
    Tabla de ventas_detalle: Esta tabla detallará las ventas, incluyendo la cantidad vendida de cada producto por venta. Tendremos los campos id_venta_detalle, cantidad, id_venta (FK a la tabla ventas) y id_producto (FK a la tabla productos).

Consultas SQL:

    Perfume más vendido en general:
    SQL

    SELECT p.nombre AS perfume, SUM(vd.cantidad) AS total_vendido
    FROM ventas_detalle vd
    INNER JOIN productos p ON vd.id_producto = p.id_producto
    GROUP BY p.nombre
    ORDER BY total_vendido DESC
    LIMIT 1;

    Usa el código con precaución.

Esta consulta te dará el nombre del perfume y la cantidad total vendida. El LIMIT 1 asegura que solo se muestre el primer resultado (el perfume más vendido).

Perfume más vendido por mes:
SQL

SELECT p.nombre, EXTRACT(MONTH FROM v.fecha) AS mes, SUM(vd.cantidad) AS total_vendido
FROM ventas v
INNER JOIN ventas_detalle vd ON v.id_venta = vd.id_venta
INNER JOIN productos p ON vd.id_producto = p.id_producto
GROUP BY p.nombre, EXTRACT(MONTH FROM v.fecha)
ORDER BY total_vendido DESC;

Usa el código con precaución.

Esta consulta te dará el perfume más vendido por cada mes. La función EXTRACT(MONTH FROM v.fecha) te permite agrupar los datos por mes.

Top 5 perfumes más vendidos por año:
SQL

SELECT p.nombre, EXTRACT(YEAR FROM v.fecha) AS año, SUM(vd.cantidad) AS total_vendido
FROM ventas v
INNER JOIN ventas_detalle vd ON v.id_venta = vd.id_venta
INNER JOIN productos p ON vd.id_producto = p.id_producto
GROUP BY p.nombre, EXTRACT(YEAR FROM v.fecha)
ORDER BY año, total_vendido DESC
LIMIT 5;

Usa el código con precaución.

    Esta consulta te dará los 5 perfumes más vendidos por cada año.

Personalizando las consultas:

    Rango de fechas: Puedes agregar una cláusula WHERE para filtrar las ventas por un rango de fechas específico.
    Agrupación por vendedor: Si quieres conocer el perfume más vendido por vendedor, agrega id_vendedor a la cláusula GROUP BY.
    Otros criterios: Puedes agregar más condiciones a la cláusula WHERE para filtrar los resultados según tus necesidades (e.g., por zona geográfica, tipo de cliente, etc.).

Ejemplo con rango de fechas y agrupación por vendedor:
SQL

SELECT p.nombre, v.id_vendedor, EXTRACT(YEAR FROM v.fecha) AS año, SUM(vd.cantidad) AS total_vendido
FROM ventas v
INNER JOIN ventas_detalle vd ON v.id_venta = vd.id_venta
INNER JOIN productos p ON vd.id_producto = p.id_producto
WHERE v.fecha BETWEEN '2023-01-01' AND '2023-12-31'
GROUP BY p.nombre, v.id_vendedor, EXTRACT(YEAR FROM v.fecha)
ORDER BY año, total_vendido DESC;

Usa el código con precaución.

Consideraciones adicionales para Python y SQLAlchemy:

    Ejecutar las consultas: Utiliza el método session.execute() para ejecutar las consultas SQL.
    Obtener los resultados: Utiliza el método fetchall() para obtener todos los resultados de la consulta.
    Procesar los resultados: Puedes utilizar bucles o pandas para procesar los resultados y generar informes o gráficos.

¿Necesitas más ejemplos o tienes alguna otra pregunta?

Recuerda:

    Adapta las consultas a tu esquema de base de datos: Asegúrate de que los nombres de las tablas y columnas coincidan con tu estructura.
    Utiliza índices: Crea índices en las columnas que se utilizan frecuentemente en las cláusulas WHERE, JOIN y GROUP BY para mejorar el rendimiento de las consultas.

Con estas consultas y consejos, podrás obtener información valiosa sobre las ventas de tus perfumes y tomar decisiones más informadas para tu negocio.

Aquí te presento un conjunto completo de tablas y funciones SQL para una base de datos de una perfumería, incluyendo las consultas que hemos discutido anteriormente. He asumido algunas estructuras y relaciones, pero puedes personalizarlas según tus necesidades específicas.

Estructura de la base de datos:
SQL

CREATE TABLE clientes (
    id_cliente SERIAL PRIMARY KEY,
    nombre VARCHAR(100),
    apellido VARCHAR(100),
    cedula VARCHAR(20),
    direccion TEXT,
    telefono VARCHAR(20),
    zona VARCHAR(50)
);

CREATE TABLE productos (
    id_producto SERIAL PRIMARY KEY,
    nombre VARCHAR(100),
    precio NUMERIC(10,2),
    categoria VARCHAR(50)
);

CREATE TABLE ventas (
    id_venta SERIAL PRIMARY KEY,
    fecha DATE,
    total NUMERIC(10,2),
    id_cliente INTEGER REFERENCES clientes(id_cliente),
    id_vendedor INTEGER REFERENCES vendedores(id_vendedor)
);

CREATE TABLE ventas_detalle (
    id_venta_detalle SERIAL PRIMARY KEY,
    cantidad INTEGER,
    id_venta INTEGER REFERENCES ventas(id_venta),
    id_producto INTEGER REFERENCES productos(id_producto)
);

CREATE TABLE vendedores (
    id_vendedor SERIAL PRIMARY KEY,
    nombre VARCHAR(100),
    apellido VARCHAR(100),
    comision NUMERIC(10,2)
);

Usa el código con precaución.

Funciones para calcular métricas:
SQL

-- Función para obtener el perfume más vendido en un rango de fechas
CREATE OR REPLACE FUNCTION perfume_mas_vendido(fecha_inicio DATE, fecha_fin DATE)
RETURNS TABLE (perfume VARCHAR, total_vendido NUMERIC) AS $$
BEGIN
  RETURN QUERY
  SELECT p.nombre, SUM(vd.cantidad) AS total_vendido
  FROM ventas v
  INNER JOIN ventas_detalle vd ON v.id_venta = vd.id_venta
  INNER JOIN productos p ON vd.id_producto = p.id_producto
  WHERE v.fecha BETWEEN fecha_inicio AND fecha_fin
  GROUP BY p.nombre
  ORDER BY total_vendido DESC
  LIMIT 1;
END;
$$ LANGUAGE plpgsql;

-- Función para obtener los top N perfumes vendidos por año
CREATE OR REPLACE FUNCTION top_perfumes_por_ano(ano INTEGER, n INTEGER)
RETURNS TABLE (perfume VARCHAR, total_vendido NUMERIC) AS $$
BEGIN
  RETURN QUERY
  SELECT p.nombre, SUM(vd.cantidad) AS total_vendido
  FROM ventas v
  INNER JOIN ventas_detalle vd ON v.id_venta = vd.id_venta
  INNER JOIN productos p ON vd.id_producto = p.id_producto
  WHERE EXTRACT(YEAR FROM v.fecha) = ano
  GROUP BY p.nombre
  ORDER BY total_vendido DESC
  LIMIT n;
END;
$$ LANGUAGE plpgsql;

Usa el código con precaución.

Uso de las funciones:
SQL

-- Ejemplo: Obtener el perfume más vendido en 2023
SELECT * FROM perfume_mas_vendido('2023-01-01', '2023-12-31');

-- Ejemplo: Obtener los 3 perfumes más vendidos en 2022
SELECT * FROM top_perfumes_por_ano(2022, 3);

Usa el código con precaución.

Explicación:

    Tablas: Hemos definido las tablas básicas para una perfumería, incluyendo clientes, productos, ventas, detalles de ventas y vendedores.
    Funciones:
        perfume_mas_vendido: Calcula el perfume más vendido en un rango de fechas especificado.
        top_perfumes_por_ano: Devuelve los N perfumes más vendidos en un año determinado.
    Uso de las funciones: Puedes llamar a estas funciones en tus consultas SQL para obtener los resultados deseados.

Personalización:

    Campos adicionales: Agrega campos como fecha_nacimiento en la tabla clientes, descuento en la tabla productos, etc.
    Relaciones adicionales: Puedes agregar relaciones entre tablas para representar conceptos como proveedores, marcas, etc.
    Funciones adicionales: Crea funciones para calcular métricas más complejas, como el valor promedio de una venta o el número de clientes por zona.
    Índices: Crea índices en las columnas que se utilizan frecuentemente en las cláusulas WHERE, JOIN y GROUP BY para mejorar el rendimiento de las consultas.

Recuerda:

    Adapta este esquema a tus necesidades específicas.
    Utiliza un diagrama de entidad-relación (ERD) para visualizar mejor las relaciones entre las tablas.
    Optimiza las consultas: Utiliza las herramientas de tu sistema de base de datos para analizar el rendimiento de las consultas y realizar ajustes si es necesario.

Próximos pasos:

    Crear la base de datos: Utiliza una herramienta como pgAdmin o el cliente de línea de comandos de PostgreSQL para crear la base de datos y ejecutar los scripts SQL.
    Poblar la base de datos: Ingresa datos de muestra o utiliza un script para importar datos de una fuente externa.
    Crear aplicaciones: Utiliza un lenguaje de programación como Python y un ORM como SQLAlchemy para interactuar con la base de datos y crear aplicaciones que permitan a los usuarios realizar consultas, generar informes y realizar otras tareas.

--Creación de la Base de Datos
CREATE DATABASE Gabriela_Fragancias;

--Tabla Zonas
CREATE TABLE Zonas (
    id_zona SERIAL PRIMARY KEY,
    nombre_zona VARCHAR(100) NOT NULL UNIQUE
);

--Tabla Clientes
CREATE TABLE Clientes (
    id_cliente SERIAL PRIMARY KEY,
    cedula VARCHAR(20) UNIQUE NOT NULL,
    nombre VARCHAR(100) NOT NULL,
    apellido VARCHAR(100) NOT NULL,
    telefono VARCHAR(20),
    direccion TEXT,
    email VARCHAR(100),
    ruc VARCHAR(20) UNIQUE,
    fecha_registro DATE DEFAULT CURRENT_DATE
);

--Tabla Vendedores
CREATE TABLE Vendedores (
    id_vendedor SERIAL PRIMARY KEY,
    nombre VARCHAR(100) NOT NULL,
    zona VARCHAR(50) NOT NULL,
    comision DECIMAL(10, 2) DEFAULT 50000
);

--Tabla Tarjetas
CREATE TABLE Tarjetas (
    id_tarjeta SERIAL PRIMARY KEY,
    numero_tarjeta VARCHAR(7) NOT NULL,
    id_cliente INTEGER REFERENCES Clientes(id_cliente),
    id_vendedor INTEGER REFERENCES Vendedores(id_vendedor),
    id_zona INTEGER REFERENCES Zonas(id_zona),
    total_gs DECIMAL(10, 2) NOT NULL,
    saldo DECIMAL(10, 2) DEFAULT 0,
    forma_pago VARCHAR(20) CHECK (forma_pago IN ('SEM', 'QUIN', 'MENS')),
    estado VARCHAR(20) CHECK (estado IN ('activa', 'cancelada')) DEFAULT 'activa',
    fecha_emision DATE DEFAULT CURRENT_DATE,
    id_tarjeta_anterior INTEGER REFERENCES Tarjetas(id_tarjeta)
);

--Tabla de Productos
CREATE TABLE Productos (
    id_producto SERIAL PRIMARY KEY,
    nombre VARCHAR(100) NOT NULL,
    codigo_barras VARCHAR(13) UNIQUE NOT NULL,
    precio_costo DECIMAL(10, 2),
    precio_venta DECIMAL(10, 2),
    stock INTEGER DEFAULT 0,
    descripcion TEXT
);

--Tabla Productos Vendidos
CREATE TABLE Productos_Vendidos (
    id_producto_vendido SERIAL PRIMARY KEY,
    id_tarjeta INTEGER REFERENCES Tarjetas(id_tarjeta),
    id_producto INTEGER REFERENCES Productos(id_producto),
    cantidad INTEGER CHECK (cantidad > 0),
    precio DECIMAL(10, 2)
);

--Tabla Pagos
CREATE TABLE Pagos (
    id_pago SERIAL PRIMARY KEY,
    id_tarjeta INTEGER REFERENCES Tarjetas(id_tarjeta),
    fecha_pago DATE DEFAULT CURRENT_DATE,
    monto DECIMAL(10, 2) NOT NULL,
    saldo_restante DECIMAL(10, 2) NOT NULL,
    entrega_inicial BOOLEAN DEFAULT FALSE,
    recargo BOOLEAN DEFAULT FALSE
);

--Tabla Antecedentes Judiciales
CREATE TABLE Antecedentes_Judiciales (
    id_antecedente SERIAL PRIMARY KEY,
    cedula VARCHAR(20) REFERENCES Clientes(cedula),
    causa_penal TEXT
);

--Tabla de Inventario (Maletines de Productos)
CREATE TABLE Inventario (
    id_inventario SERIAL PRIMARY KEY,
    id_vendedor INTEGER REFERENCES Vendedores(id_vendedor),
    id_producto INTEGER REFERENCES Productos(id_producto),
    cantidad INTEGER NOT NULL
);

--Tabla de Rutas
CREATE TABLE Rutas (
    id_ruta SERIAL PRIMARY KEY,
    id_vendedor INTEGER REFERENCES Vendedores(id_vendedor),
    id_zona INTEGER REFERENCES Zonas(id_zona),
    fecha DATE DEFAULT CURRENT_DATE,
    coordenadas GEOGRAPHY(POINT, 4326)  -- Integración con GIS
);

--Triggers y Funciones
CREATE OR REPLACE FUNCTION actualizar_saldo_cliente() 
RETURNS TRIGGER AS $$
BEGIN
    UPDATE Tarjetas 
    SET saldo = saldo - NEW.monto
    WHERE id_tarjeta = NEW.id_tarjeta;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

--Trigger para actualizar saldo tras un pago:
CREATE TRIGGER tg_actualizar_saldo
AFTER INSERT ON Pagos
FOR EACH ROW
EXECUTE FUNCTION actualizar_saldo_cliente();

--Función para actualizar inventario tras una venta:
CREATE OR REPLACE FUNCTION actualizar_inventario() 
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.cantidad > (SELECT stock FROM Productos WHERE id_producto = NEW.id_producto) THEN
        RAISE EXCEPTION 'No hay suficiente stock para este producto';
    ELSE
        UPDATE Productos 
        SET stock = stock - NEW.cantidad 
        WHERE id_producto = NEW.id_producto;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

--Trigger para actualizar inventario tras una venta:
CREATE TRIGGER tg_actualizar_inventario
AFTER INSERT ON Productos_Vendidos
FOR EACH ROW
EXECUTE FUNCTION actualizar_inventario();

--Vista para Reportes de Ventas
CREATE VIEW VW_Ventas_Por_Cliente AS
SELECT 
    c.id_cliente, 
    c.nombre, 
    c.apellido, 
    COUNT(v.id_tarjeta) AS total_ventas, 
    SUM(v.total_gs) AS monto_total
FROM 
    Clientes c
JOIN 
    Tarjetas v ON c.id_cliente = v.id_cliente
GROUP BY 
    c.id_cliente;

--Optimización con Índices
CREATE INDEX idx_tarjetas_cliente ON Tarjetas(id_cliente);
CREATE INDEX idx_productos_codigo_barras ON Productos(codigo_barras);
CREATE INDEX idx_pagos_fecha ON Pagos(fecha_pago);
CREATE INDEX idx_rutas_vendedor_fecha ON Rutas(id_vendedor, fecha);
CREATE INDEX idx_pagos_cliente_metodo ON Pagos(id_cliente, metodo_pago);
CREATE INDEX idx_antecedentes_cedula ON AntecedentesJudiciales(cedula);
CREATE INDEX idx_inventario_maletines_producto ON Inventario_Maletines(id_maletin, id_producto);
CREATE INDEX idx_vehiculos_motor_chasis_placa ON Vehiculos(numero_motor, numero_chasis, placa);

-- Tabla Personas (con alerta de defunción)
CREATE TABLE Personas (
    id_persona SERIAL PRIMARY KEY,
    cedula VARCHAR(20) UNIQUE NOT NULL,
    nombre VARCHAR(100) NOT NULL,
    apellido VARCHAR(100) NOT NULL,
    fecha_nacimiento DATE,
    direccion TEXT,
    departamento VARCHAR(100),
    distrito_municipio VARCHAR(100),
    barrio_localidad VARCHAR(100),
    zona VARCHAR(100),
    telefono VARCHAR(20),
    email VARCHAR(100) UNIQUE,
    fecha_defuncion DATE,  -- Campo para gestionar defunciones
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
);

-- Trigger para alerta de defunción
CREATE OR REPLACE FUNCTION verificar_defuncion() 
RETURNS TRIGGER AS $$
BEGIN
    IF (NEW.fecha_defuncion IS NOT NULL) THEN
        RAISE NOTICE 'La persona con cédula % ha sido marcada como fallecida.', NEW.cedula;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tg_verificar_defuncion
AFTER INSERT OR UPDATE ON Personas
FOR EACH ROW
EXECUTE FUNCTION verificar_defuncion();

-- Tabla Clientes
CREATE TABLE Clientes (
    id_cliente SERIAL PRIMARY KEY,
    id_persona INTEGER REFERENCES Personas(id_persona),
    tarjeta VARCHAR(7) UNIQUE NOT NULL,  -- Número de tarjeta obligatorio y único
    saldo DECIMAL(10, 2) DEFAULT 0,
    tipo_pago VARCHAR(20) CHECK (tipo_pago IN ('SEM', 'QUIN', 'MENS')),
    fecha_registro DATE DEFAULT CURRENT_DATE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- Tabla Marcas
CREATE TABLE Marcas (
    id_marca SERIAL PRIMARY KEY,
    nombre VARCHAR(100) UNIQUE NOT NULL,
    año_fundacion INT
);

-- Tabla Productos
CREATE TABLE Productos (
    id_producto SERIAL PRIMARY KEY,
    codigo_barras VARCHAR(50) UNIQUE NOT NULL,
    nombre VARCHAR(100) NOT NULL,
    id_marca INTEGER REFERENCES Marcas(id_marca),
    precio_contado DECIMAL(10, 2) NOT NULL,
    precio_credito DECIMAL(10, 2) NOT NULL,
    stock INTEGER NOT NULL,
    descripcion TEXT,
    presentacion VARCHAR(50),
    volumen INT CHECK (volumen BETWEEN 5 AND 200),
    es_kit BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- Trigger para actualizar el stock de productos después de una venta
CREATE OR REPLACE FUNCTION actualizar_stock_producto() 
RETURNS TRIGGER AS $$
BEGIN
    IF (NEW.cantidad > (SELECT stock FROM Productos WHERE id_producto = NEW.id_producto)) THEN
        RAISE EXCEPTION 'No hay suficiente stock para este producto';
    ELSE
        UPDATE Productos 
        SET stock = stock - NEW.cantidad 
        WHERE id_producto = NEW.id_producto;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tg_actualizar_stock
AFTER INSERT ON Ventas
FOR EACH ROW
EXECUTE FUNCTION actualizar_stock_producto();

-- Tabla Ventas
CREATE TABLE Ventas (
    id_venta SERIAL PRIMARY KEY,
    id_cliente INTEGER REFERENCES Clientes(id_cliente),
    id_producto INTEGER REFERENCES Productos(id_producto),
    fecha DATE DEFAULT CURRENT_DATE,
    forma_pago VARCHAR(20) CHECK (forma_pago IN ('Contado', 'Crédito')),
    total DECIMAL(10, 2) NOT NULL,
    saldo DECIMAL(10, 2) DEFAULT 0,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- Trigger para actualizar el saldo de los clientes tras una venta
CREATE OR REPLACE FUNCTION actualizar_saldo_cliente() 
RETURNS TRIGGER AS $$
BEGIN
    UPDATE Clientes 
    SET saldo = saldo - NEW.total
    WHERE id_cliente = NEW.id_cliente;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tg_actualizar_saldo
AFTER INSERT ON Ventas
FOR EACH ROW
EXECUTE FUNCTION actualizar_saldo_cliente();

-- Tabla Pagos
CREATE TABLE Pagos (
    id_pago SERIAL PRIMARY KEY,
    id_cliente INTEGER REFERENCES Clientes(id_cliente),
    id_venta INTEGER REFERENCES Ventas(id_venta),
    fecha_pago DATE DEFAULT CURRENT_DATE,
    monto DECIMAL(10, 2) NOT NULL,
    metodo_pago VARCHAR(20) CHECK (metodo_pago IN ('Efectivo', 'Tarjeta', 'Transferencia')),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- Tabla Detalles de Venta
CREATE TABLE Detalles_Venta (
    id_detalle SERIAL PRIMARY KEY,
    id_venta INTEGER REFERENCES Ventas(id_venta) ON DELETE CASCADE,
    id_producto INTEGER REFERENCES Productos(id_producto),
    cantidad INTEGER NOT NULL,
    precio_unitario DECIMAL(10, 2),
    subtotal DECIMAL(10, 2) GENERATED ALWAYS AS (cantidad * precio_unitario) STORED,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- Tabla Vehiculos
CREATE TABLE Vehiculos (
    id_vehiculo SERIAL PRIMARY KEY,
    placa VARCHAR(20) UNIQUE NOT NULL,  -- Número de placa obligatorio y único
    marca VARCHAR(50),
    modelo VARCHAR(50),
    año INT,
    numero_motor VARCHAR(50) UNIQUE,  -- Número de motor obligatorio y único
    numero_chasis VARCHAR(50) UNIQUE, -- Número de chasis obligatorio y único
    fecha_revision DATE,  -- Fecha de última revisión técnica
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- Tabla Rutas (para vendedores y manejo de geolocalización)
CREATE TABLE Rutas (
    id_ruta SERIAL PRIMARY KEY,
    id_vendedor INTEGER REFERENCES Vendedores(id_vendedor),
    nombre_ruta VARCHAR(100) NOT NULL,
    fecha DATE DEFAULT CURRENT_DATE,
    coordenadas GEOGRAPHY(POLYGON, 4326),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- Tabla Inventario_Maletines (para manejar los productos en los maletines de vendedoras)
CREATE TABLE Inventario_Maletines (
    id_inventario SERIAL PRIMARY KEY,
    id_maletin INTEGER REFERENCES Maletines(id_maletin),
    id_producto INTEGER REFERENCES Productos(id_producto),
    cantidad INTEGER NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- Tabla Maletines (gestión de los maletines de las vendedoras)
CREATE TABLE Maletines (
    id_maletin SERIAL PRIMARY KEY,
    id_vendedor INTEGER REFERENCES Vendedores(id_vendedor),
    fecha_carga DATE DEFAULT CURRENT_DATE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- Tabla AntecedentesJudiciales (para verificar los antecedentes de los clientes)
CREATE TABLE AntecedentesJudiciales (
    id_antecedente SERIAL PRIMARY KEY,
    cedula VARCHAR(20) REFERENCES Personas(cedula),
    causa_penal TEXT
);

-- Trigger para verificar si un cliente tiene antecedentes judiciales
CREATE OR REPLACE FUNCTION verificar_antecedentes() 
RETURNS TRIGGER AS $$
BEGIN
    IF EXISTS (SELECT 1 FROM AntecedentesJudiciales WHERE cedula = NEW.cedula) THEN
        RAISE NOTICE 'El cliente con cédula % tiene antecedentes judiciales', NEW.cedula;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tg_verificar_antecedentes
BEFORE INSERT ON Clientes
FOR EACH ROW
EXECUTE FUNCTION verificar_antecedentes();

-- Trigger para actualizar la comisión de las vendedoras tras una venta
CREATE OR REPLACE FUNCTION actualizar_comision_vendedora() 
RETURNS TRIGGER AS $$
BEGIN
    UPDATE Liquidaciones 
    SET total_ventas = total_ventas + NEW.total,
        comision = comision + (50000 * NEW.cantidad)  -- Comisión por producto
    WHERE id_vendedor = NEW.id_vendedor;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tg_actualizar_comision
AFTER INSERT ON Ventas
FOR EACH ROW
EXECUTE FUNCTION actualizar_comision_vendedora();

-- Índices faltantes para optimización de consultas
CREATE INDEX idx_rutas_vendedor_fecha ON Rutas(id_vendedor, fecha);
CREATE INDEX idx_pagos_cliente_metodo ON Pagos(id_cliente, metodo_pago);
CREATE INDEX idx_antecedentes_cedula ON AntecedentesJudiciales(cedula);
CREATE INDEX idx_inventario_maletines_producto ON Inventario_Maletines(id_maletin, id_producto);
CREATE INDEX idx_vehiculos_motor_chasis_placa ON Vehiculos(numero_motor, numero_chasis, placa);


-- Relaciones Clave

Clientes y Personas: La tabla personas puede utilizarse para almacenar información adicional sobre las personas, como sus cédulas y contactos. Los clientes pueden estar relacionados con personas si hay un esquema más complejo.
Rutas y Vehículos: Los vendedores pueden estar asignados a rutas, y cada ruta puede tener asociado un vehículo para facilitar la movilidad y el seguimiento GPS.
Antecedentes Judiciales: Se verifica si los clientes tienen antecedentes judiciales antes de ser ingresados, lo que podría afectar las decisiones comerciales.
Geolocalización: Las rutas están asociadas con zonas geográficas (ciudades, municipios, departamentos) para un mejor control territorial.
A ESTA TABLA QUISIERA INGRESAR UNA COLUMNA PARA LA IMAGEN DEL LOGOTIPO
Y UNA SENTENCIA SQL
CON el RUC 4974638-3
razón social Gabriela Fragancias 

-- Tabla Empresa
CREATE TABLE Empresa (
    id_empresa SERIAL PRIMARY KEY,
    ruc VARCHAR(20) UNIQUE NOT NULL,
    razon_social VARCHAR(100) NOT NULL
	logotipo BYTEA;
);

-- Insertar los datos de la empresa con logotipo
INSERT INTO Empresa (ruc, razon_social, logotipo)
VALUES ('4974638-3', 'Gabriela Fragancias', pg_read_binary_file("D:\Gabriela Fragancias\Datos\Diseños\Gabriela Fragancias (logo torre).png"));



-- Consulta de Clientes con Antecedentes Judiciales

SELECT p.nombre, p.apellido, a.causa_penal
FROM personas p
INNER JOIN antecedentes_judiciales a ON p.cedula = a.numero_ci;

-- Consulta de Vehículos Asignados a Vendedores

SELECT v.nombre, v.apellido, veh.marca, veh.modelo, veh.placa
FROM vendedores v
INNER JOIN rutas r ON v.id_vendedor = r.id_vendedor
INNER JOIN vehiculos veh ON r.id_vehiculo = veh.id_vehiculo;

-- Consulta de Geolocalización de Vehículos

SELECT veh.placa, t.latitud, t.longitud, t.fecha_hora
FROM vehiculos veh
INNER JOIN tracking_gps t ON veh.id_vehiculo = t.id_vehiculo
ORDER BY t.fecha_hora DESC;

Para mejorar la base de datos PostgreSQL con GIS según los requerimientos y los archivos DBF indicados en el archivo "prompt final.txt", aquí está un plan para integrar datos geoespaciales y mejorar la estructura de la base de datos:
1. Revisión de las Tablas Existentes

    Tabla Zonas: Ya se tiene definida con un id_zona y nombre_zona. Agrega un campo geoespacial (GEOGRAPHY) para almacenar los polígonos de las zonas.

    sql

ALTER TABLE Zonas ADD COLUMN geom GEOGRAPHY(POLYGON, 4326);

Tabla Rutas: Ya tiene un campo coordenadas (GEOGRAPHY(POINT, 4326)), pero podrías agregar una columna para la geometría completa de la ruta.

sql

    ALTER TABLE Rutas ADD COLUMN ruta_geom GEOGRAPHY(LINESTRING, 4326);

2. Creación de Nuevas Tablas

    Tabla de Vehículos: Añadir información de vehículos (modelo, marca, número de motor y chasis).

    sql

CREATE TABLE Vehiculos (
    id_vehiculo SERIAL PRIMARY KEY,
    placa VARCHAR(20) UNIQUE NOT NULL,
    marca VARCHAR(50),
    modelo VARCHAR(50),
    numero_motor VARCHAR(50) UNIQUE,
    numero_chasis VARCHAR(50) UNIQUE,
    fecha_revision DATE
);

Tabla de Maletines: Para controlar qué productos llevan los vendedores.

sql

CREATE TABLE Maletines (
    id_maletin SERIAL PRIMARY KEY,
    id_vendedor INT REFERENCES Vendedores(id_vendedor),
    fecha_carga DATE DEFAULT CURRENT_DATE
);

Productos en Maletines: Para asociar productos con maletines.

sql

    CREATE TABLE Productos_Maletin (
        id_maletin INT REFERENCES Maletines(id_maletin),
        id_producto INT REFERENCES Productos(id_producto),
        cantidad INT NOT NULL,
        PRIMARY KEY (id_maletin, id_producto)
    );

3. Importación de Archivos DBF

Para importar los archivos DBF, usaremos Python con las bibliotecas dbfread y geopandas para manejar archivos DBF y datos geoespaciales (KML, SHP, GeoJSON).

python

import pandas as pd
from dbfread import DBF
import geopandas as gpd
import psycopg2

conn = psycopg2.connect(host="localhost", database="Gabriela_Fragancias", user="usuario", password="contraseña")
cur = conn.cursor()

# Función para leer DBF
def importar_dbf(archivo_dbf):
    table = DBF(archivo_dbf)
    df = pd.DataFrame(iter(table))
    return df

# Insertar datos de DBF en PostgreSQL
df_vehiculos = importar_dbf('ruta/vehiculos.dbf')
for _, row in df_vehiculos.iterrows():
    cur.execute(
        "INSERT INTO Vehiculos (placa, marca, modelo, numero_motor, numero_chasis) VALUES (%s, %s, %s, %s, %s)",
        (row['NROCHAPA'], row['MARCA'], row['MODELO'], row['NROMOTOR'], row['NROCHASIS'])
    )

conn.commit()
cur.close()

4. Datos Geoespaciales (GIS)

Para importar archivos geoespaciales (KML, SHP, GeoJSON):

python

gdf = gpd.read_file("ruta/zona.shp")
for _, row in gdf.iterrows():
    cur.execute(
        "INSERT INTO Zonas (nombre_zona, geom) VALUES (%s, ST_SetSRID(ST_GeomFromText(%s), 4326))",
        (row['nombre_zona'], row['geometry'].wkt)
    )
conn.commit()

5. Índices y Triggers

    Índice en Tarjetas para mejorar la búsqueda:

    sql

CREATE INDEX idx_tarjetas_numero ON Tarjetas(numero_tarjeta);

Trigger para actualizar stock:

sql

    CREATE OR REPLACE FUNCTION actualizar_stock_maletin() RETURNS TRIGGER AS $$
    BEGIN
        IF NEW.cantidad > (SELECT stock FROM Productos WHERE id_producto = NEW.id_producto) THEN
            RAISE EXCEPTION 'No hay suficiente stock';
        ELSE
            UPDATE Productos SET stock = stock - NEW.cantidad WHERE id_producto = NEW.id_producto;
        END IF;
        RETURN NEW;
    END;
    $$ LANGUAGE plpgsql;

    CREATE TRIGGER tg_actualizar_stock
    AFTER INSERT ON Productos_Maletin
    FOR EACH ROW EXECUTE FUNCTION actualizar_stock_maletin();

6. Reportes Pendientes

    Reporte de Ventas por Zona:

    sql

    CREATE VIEW VW_Ventas_Por_Zona AS
    SELECT Z.nombre_zona, SUM(T.total_gs) AS total_ventas
    FROM Zonas Z
    JOIN Rutas R ON Z.id_zona = R.id_zona
    JOIN Tarjetas T ON R.id_ruta = T.id_ruta
    GROUP BY Z.nombre_zona;

Con esto, la base de datos quedará optimizada para manejar datos geoespaciales, vehículos, productos en maletines y sus ventas.

Para integrar los datos de cédulas, RUC, antecedentes judiciales y otras fuentes desde archivos DBF y TXT en la base de datos PostgreSQL con GIS, vamos a definir las tablas necesarias. Las fuentes mencionadas incluyen archivos DBF de cédulas y antecedentes judiciales, además de registros civiles y RUC en formatos DBF y TXT.

Aquí te dejo el esquema propuesto:
1. Tabla de Cédulas (Fuente: poli01.dbf, regciv.dbf, regciv_ext.dbf)

Esta tabla almacenará la información básica de los ciudadanos provenientes de las bases de datos DBF.

sql

CREATE TABLE Cedulas (
    id_cedula SERIAL PRIMARY KEY,
    numero_cedula VARCHAR(20) UNIQUE NOT NULL,
    nombre VARCHAR(100),
    apellido VARCHAR(100),
    sexo CHAR(1),  -- M: Masculino, F: Femenino
    fecha_nacimiento DATE,
    lugar_nacimiento VARCHAR(100),
    fecha_registro DATE,
    fuente VARCHAR(50)  -- 'poli01', 'regciv', 'regciv_ext'
);

2. Tabla de RUC (Fuente: ruc.dbf, ruc.txt)

Esta tabla almacenará los números de RUC y otros datos comerciales. Los archivos RUC en DBF y TXT se integrarán en esta tabla.

sql

CREATE TABLE RUC (
    id_ruc SERIAL PRIMARY KEY,
    numero_ruc VARCHAR(20) UNIQUE NOT NULL,
    razon_social VARCHAR(255),
    direccion VARCHAR(255),
    telefono VARCHAR(20),
    tipo VARCHAR(20),  -- Tipo de entidad: 'Persona', 'Empresa'
    fuente VARCHAR(50)  -- 'ruc.dbf', 'ruc.txt'
);

3. Tabla de Antecedentes Judiciales (Fuente: capt01.dbf)

Aquí se almacenarán los antecedentes judiciales asociados a las cédulas de los ciudadanos.

sql

CREATE TABLE Antecedentes_Judiciales (
    id_antecedente SERIAL PRIMARY KEY,
    numero_cedula VARCHAR(20) REFERENCES Cedulas(numero_cedula),
    causa_penal TEXT,  -- Descripción de la causa penal
    fecha_causa DATE,
    unidad_procesadora VARCHAR(100),
    juez VARCHAR(100),
    estado_proceso VARCHAR(50),
    fuente VARCHAR(50)  -- 'capt01.dbf'
);

4. Importación de Datos desde DBF y TXT

A continuación te muestro cómo podrías importar estos datos a PostgreSQL utilizando Python. Se utilizará dbfread para los archivos DBF y pandas para manejar los archivos TXT.
a. Importación desde poli01.dbf

python

from dbfread import DBF
import psycopg2

# Conexión a la base de datos
conn = psycopg2.connect(host="localhost", database="Gabriela_Fragancias", user="usuario", password="contraseña")
cur = conn.cursor()

# Leer el archivo DBF
def importar_dbf_cedulas(archivo_dbf):
    table = DBF(archivo_dbf)
    for record in table:
        cur.execute(
            "INSERT INTO Cedulas (numero_cedula, nombre, apellido, sexo, fecha_nacimiento, lugar_nacimiento, fuente) VALUES (%s, %s, %s, %s, %s, %s, %s)",
            (record['NROCED'], record['NOMBRE'], record['APELLI'], record['SEXO'], record['FECHANAC'], record['LUGAR'], 'poli01')
        )
    conn.commit()

# Ejecutar la importación
importar_dbf_cedulas('ruta/poli01.dbf')
cur.close()
conn.close()

b. Importación desde ruc.dbf y ruc.txt

Para el archivo ruc.dbf, el proceso es similar al anterior:

python

def importar_dbf_ruc(archivo_dbf):
    table = DBF(archivo_dbf)
    for record in table:
        cur.execute(
            "INSERT INTO RUC (numero_ruc, razon_social, direccion, telefono, tipo, fuente) VALUES (%s, %s, %s, %s, %s, %s)",
            (record['RUC'], record['RAZON'], record['DIRECCION'], record['TELEFONO'], 'Persona', 'ruc.dbf')
        )
    conn.commit()

importar_dbf_ruc('ruta/ruc.dbf')

Para el archivo ruc.txt, podemos usar pandas para leerlo y luego importarlo a la base de datos:

python

import pandas as pd

# Leer archivo TXT
df_ruc = pd.read_csv('ruta/ruc.txt', sep='|', names=['numero_ruc', 'razon_social', 'direccion', 'telefono'])

# Insertar en la base de datos
for _, row in df_ruc.iterrows():
    cur.execute(
        "INSERT INTO RUC (numero_ruc, razon_social, direccion, telefono, tipo, fuente) VALUES (%s, %s, %s, %s, %s, %s)",
        (row['numero_ruc'], row['razon_social'], row['direccion'], row['telefono'], 'Empresa', 'ruc.txt')
    )
conn.commit()

c. Importación desde capt01.dbf (Antecedentes Judiciales)

python

def importar_dbf_antecedentes(archivo_dbf):
    table = DBF(archivo_dbf)
    for record in table:
        cur.execute(
            "INSERT INTO Antecedentes_Judiciales (numero_cedula, causa_penal, fecha_causa, unidad_procesadora, juez, estado_proceso, fuente) VALUES (%s, %s, %s, %s, %s, %s, %s)",
            (record['NROCED'], record['CAUSA'], record['FECNOTA'], record['UNIDAD'], record['JUEZ'], record['ESTADO'], 'capt01.dbf')
        )
    conn.commit()

importar_dbf_antecedentes('ruta/capt01.dbf')

5. Índices y Relaciones

Es importante agregar índices para optimizar las búsquedas por cédula y RUC:

sql

CREATE INDEX idx_cedulas_numero ON Cedulas(numero_cedula);
CREATE INDEX idx_ruc_numero ON RUC(numero_ruc);
CREATE INDEX idx_antecedentes_numero ON Antecedentes_Judiciales(numero_cedula);

6. Consulta de Antecedentes Judiciales

Una consulta útil para verificar si un ciudadano tiene antecedentes judiciales sería la siguiente:

sql

SELECT c.nombre, c.apellido, a.causa_penal, a.fecha_causa
FROM Cedulas c
JOIN Antecedentes_Judiciales a ON c.numero_cedula = a.numero_cedula
WHERE c.numero_cedula = '1234567890';

Con este esquema, puedes manejar los datos provenientes de los archivos DBF y TXT y asegurarte de que las cédulas, los RUC y los antecedentes judiciales se integren correctamente en la base de datos PostgreSQL. Si necesitas más ajustes, no dudes en pedírmelos.

Para cumplir con tu solicitud de agregar un dígito único a la tabla RUC, este dígito generalmente se utiliza como un verificador que sigue al número del RUC en varios países. Aquí te muestro cómo se puede agregar una columna para el dígito verificador en la tabla RUC, además de cómo calcularlo e insertarlo.
Modificación de la Tabla RUC con el Campo de Dígito Verificador

Añadimos una columna digito_verificador a la tabla RUC para almacenar el dígito único.

sql

ALTER TABLE RUC ADD COLUMN digito_verificador VARCHAR(1);

1. Generación del Dígito Verificador

El cálculo del dígito verificador depende de las reglas específicas del país, pero a menudo se usa el algoritmo Módulo 11, que es común en muchos países de Latinoamérica.

A continuación te muestro cómo calcularlo en Python e insertarlo en la base de datos.
2. Función para Calcular el Dígito Verificador (Módulo 11)

Este ejemplo en Python muestra cómo calcular el dígito verificador usando el algoritmo Módulo 11. Luego, se actualiza la base de datos con el RUC y su correspondiente dígito verificador.

python

import psycopg2

# Función para calcular el dígito verificador (Módulo 11)
def calcular_digito_verificador(ruc):
    pesos = [2, 3, 4, 5, 6, 7]
    ruc_inverso = list(map(int, ruc[::-1]))  # Invertimos el RUC
    suma = sum([ruc_inverso[i] * pesos[i % len(pesos)] for i in range(len(ruc_inverso))])
    resto = suma % 11
    digito = 11 - resto if resto > 1 else 0
    return str(digito)

# Conexión a la base de datos
conn = psycopg2.connect(host="localhost", database="Gabriela_Fragancias", user="usuario", password="contraseña")
cur = conn.cursor()

# Consultar todos los RUC sin dígito verificador
cur.execute("SELECT id_ruc, numero_ruc FROM RUC WHERE digito_verificador IS NULL")
ruc_list = cur.fetchall()

# Calcular y actualizar el dígito verificador
for ruc_record in ruc_list:
    id_ruc, numero_ruc = ruc_record
    digito = calcular_digito_verificador(numero_ruc)
    cur.execute("UPDATE RUC SET digito_verificador = %s WHERE id_ruc = %s", (digito, id_ruc))

# Confirmar cambios
conn.commit()
cur.close()
conn.close()

3. Actualización de la Base de Datos

Este script actualizará la columna digito_verificador en la tabla RUC con el dígito correspondiente, calculado para cada número de RUC que aún no lo tenga asignado.
4. Inserción de Nuevos RUC con Dígito Verificador

Cuando importes nuevos datos a la tabla RUC, también puedes calcular e insertar el dígito verificador automáticamente. Aquí te muestro cómo hacerlo durante el proceso de inserción.

python

# Al insertar nuevos RUC, calcular el dígito verificador antes de la inserción
def insertar_ruc_con_digito(numero_ruc, razon_social, direccion, telefono, tipo, fuente):
    digito = calcular_digito_verificador(numero_ruc)
    cur.execute(
        "INSERT INTO RUC (numero_ruc, digito_verificador, razon_social, direccion, telefono, tipo, fuente) VALUES (%s, %s, %s, %s, %s, %s, %s)",
        (numero_ruc, digito, razon_social, direccion, telefono, tipo, fuente)
    )

Consulta de los RUC con su Dígito Verificador

Puedes consultar la tabla RUC y verificar que los números de RUC ya tengan el dígito verificador asignado:

sql

SELECT numero_ruc, digito_verificador, razon_social FROM RUC;

Conclusión

Con esta modificación, la tabla RUC ahora incluirá una columna para el dígito verificador, calculado automáticamente al importar o registrar nuevos datos. Esto asegura que cada número de RUC tenga su dígito único correspondiente. ¿Necesitas algún ajuste adicional para este proceso o la lógica del cálculo del dígito?
Tú dijiste:
CORRIGE esta tabla, relaciones, etc.
--Tabla Clientes
CREATE TABLE Clientes (
    id_cliente SERIAL PRIMARY KEY,
    id_persona INTEGER REFERENCES Personas(id_persona),
    tarjeta VARCHAR(7) UNIQUE NOT NULL,  -- Número de tarjeta obligatorio y único
    saldo DECIMAL(10, 2) DEFAULT 0,
    tipo_pago VARCHAR(20) CHECK (tipo_pago IN ('SEM', 'QUIN', 'MENS')),
    fecha_registro DATE DEFAULT CURRENT_DATE,
	cedula VARCHAR(20) UNIQUE NOT NULL,
    nombre VARCHAR(100) NOT NULL,
    apellido VARCHAR(100) NOT NULL,
    telefono VARCHAR(20),
    direccion TEXT,
    email VARCHAR(100),
    ruc VARCHAR(20) UNIQUE,
    fecha_registro DATE DEFAULT CURRENT_DATE
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

Aquí te dejo la tabla Clientes corregida, eliminando redundancias, corrigiendo las relaciones y algunos errores menores, como la doble columna fecha_registro y la falta de una coma al final de las declaraciones. Además, ajusté la estructura para ser más consistente con las buenas prácticas de diseño de base de datos:
Tabla Clientes Corregida

sql

CREATE TABLE Clientes (
    id_cliente SERIAL PRIMARY KEY,
    id_persona INTEGER REFERENCES Personas(id_persona),  -- Relación con la tabla Personas
    tarjeta VARCHAR(7) UNIQUE NOT NULL,  -- Número de tarjeta obligatorio y único
    saldo DECIMAL(10, 2) DEFAULT 0,
    tipo_pago VARCHAR(20) CHECK (tipo_pago IN ('SEM', 'QUIN', 'MENS')),  -- Tipo de pago con restricciones
    fecha_registro DATE DEFAULT CURRENT_DATE,  -- Fecha de registro, sin duplicación
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,  -- Fecha de creación
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP  -- Fecha de actualización
);

Cambios Realizados

    Redundancia eliminada: Se eliminó la duplicación de columnas como fecha_registro, cedula, nombre, apellido, telefono, direccion, email, y ruc, ya que esos datos deben estar almacenados en la tabla Personas. La tabla Clientes solo debe almacenar información relacionada con el cliente en el contexto del negocio (como tarjeta, saldo, tipo de pago).

    Relación con la tabla Personas: Ahora se refiere correctamente a la tabla Personas a través de id_persona, asumiendo que toda la información personal, como cédula, nombre, y dirección, está almacenada en la tabla Personas.

    Campos temporales: Se corrigió la falta de coma después de la columna fecha_registro y se mantuvo la convención de usar created_at y updated_at para registrar las fechas de creación y actualización del registro.

    Campo tipo_pago: Se conserva la restricción CHECK en tipo_pago para permitir solo ciertos valores (SEM, QUIN, MENS).

Suposiciones:

    La tabla Personas debería contener los datos personales como cédula, nombre, apellido, teléfono, dirección, y RUC, ya que estos son datos comunes que se relacionan con diferentes contextos (clientes, empleados, etc.). La tabla Clientes almacena solo los datos relevantes para su comportamiento en el sistema de ventas.

Relación de la tabla Personas:

sql

CREATE TABLE Personas (
    id_persona SERIAL PRIMARY KEY,
    cedula VARCHAR(20) UNIQUE NOT NULL,
    nombre VARCHAR(100) NOT NULL,
    apellido VARCHAR(100) NOT NULL,
    telefono VARCHAR(20),
    direccion TEXT,
    email VARCHAR(100),
    ruc VARCHAR(20) UNIQUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

Con estas correcciones, ahora la tabla Clientes se enfoca en almacenar la información del cliente en relación con su cuenta y pagos, mientras que los datos personales están centralizados en la tabla Personas. Esto evita duplicidad y mantiene la integridad referencial.
1/2
Tú dijiste:
analiza si son redundantes o bien conectadas
--Tabla Cédulas
CREATE TABLE Cedulas (
    id_cedula SERIAL PRIMARY KEY,
    numero_cedula VARCHAR(20) UNIQUE NOT NULL,
    nombre VARCHAR(100),
    apellido VARCHAR(100),
    sexo CHAR(1),  -- M: Masculino, F: Femenino
    fecha_nacimiento DATE,
    lugar_nacimiento VARCHAR(100),
    fecha_registro DATE,
    fuente VARCHAR(50)  -- 'poli01', 'regciv', 'regciv_ext'
);

--Tabla RUC
CREATE TABLE RUC (
    id_ruc SERIAL PRIMARY KEY,
    numero_ruc VARCHAR(20) UNIQUE NOT NULL,
    razon_social VARCHAR(255),
    direccion VARCHAR(255),
    telefono VARCHAR(20),
    tipo VARCHAR(20),  -- Tipo de entidad: 'Persona', 'Empresa'
    fuente VARCHAR(50)  -- 'ruc.dbf', 'ruc.txt'
);

--Tabla Antecedentes Judiciales
CREATE TABLE Antecedentes_Judiciales (
    id_antecedente SERIAL PRIMARY KEY,
    numero_cedula VARCHAR(20) REFERENCES Cedulas(numero_cedula),
    causa_penal TEXT,  -- Descripción de la causa penal
    fecha_causa DATE,
    unidad_procesadora VARCHAR(100),
    juez VARCHAR(100),
    estado_proceso VARCHAR(50),
    fuente VARCHAR(50)  -- 'capt01.dbf'
);

--Tabla Personas
CREATE TABLE Personas (
    id_persona SERIAL PRIMARY KEY,
    cedula VARCHAR(20) UNIQUE NOT NULL,
    nombre VARCHAR(100) NOT NULL,
    apellido VARCHAR(100) NOT NULL,
    telefono VARCHAR(20),
    direccion TEXT,
    email VARCHAR(100),
    ruc VARCHAR(20) UNIQUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

Vamos a analizar las tablas para identificar posibles redundancias o problemas de conexión entre las mismas.
1. Tabla Cedulas vs. Tabla Personas
Redundancias:

    Ambas tablas (Cedulas y Personas) contienen datos personales como cedula, nombre, apellido, etc.
    La tabla Cedulas tiene la columna numero_cedula, mientras que la tabla Personas tiene cedula. Ambos campos son conceptualmente el mismo dato.
    La tabla Personas también almacena datos como telefono, direccion, y ruc, que podrían considerarse datos personales y podrían estar en la tabla Cedulas.

Conexiones:

    En este diseño, parecen existir dos tablas que almacenan la misma información de personas: Cedulas y Personas. Esto crea redundancia, ya que si ambas tablas deben mantenerse actualizadas, podrían surgir inconsistencias entre ellas.
    Si la tabla Cedulas se utiliza para representar un registro centralizado de ciudadanos y Personas para representar a las personas que tienen una cuenta en el sistema (como clientes o empleados), entonces podrían estar relacionadas, pero falta una conexión explícita entre ambas.

Solución propuesta:

Una mejor solución sería fusionar estas tablas en una sola tabla que contenga la información personal, evitando duplicar los datos. Podríamos mantener la información relacionada con las cédulas y otras fuentes en una tabla más centralizada de "personas".
2. Tabla RUC vs. Tabla Personas
Redundancias:

    La tabla Personas ya incluye un campo ruc, lo que implica que también se está almacenando el RUC a nivel de persona.
    Sin embargo, la tabla RUC está diseñada para manejar tanto RUC de personas como de empresas, lo cual es una razón válida para mantenerla separada.

Conexiones:

    Actualmente, no hay una conexión directa entre la tabla RUC y la tabla Personas. Si se espera que una persona tenga un RUC, sería mejor tener una referencia directa en la tabla Personas hacia la tabla RUC en lugar de duplicar el campo ruc.

Solución propuesta:

    En lugar de almacenar el ruc directamente en la tabla Personas, podrías tener una relación con la tabla RUC para enlazar los registros.

    sql

    ALTER TABLE Personas
    ADD COLUMN id_ruc INTEGER REFERENCES RUC(id_ruc);

    Esto eliminaría la redundancia del campo ruc en Personas y permitiría una estructura más normalizada.

3. Tabla Antecedentes Judiciales vs. Cedulas
Conexiones:

    La tabla Antecedentes_Judiciales está correctamente referenciada a la tabla Cedulas a través del campo numero_cedula. Esto asegura que los antecedentes judiciales se relacionan directamente con las cédulas.

Solución propuesta:

    Esta relación está bien implementada. No se observan redundancias aquí. Sin embargo, si fusionas Cedulas con Personas, la referencia en Antecedentes_Judiciales debería actualizarse para referirse a la tabla resultante.

Solución Global: Fusión de Tablas

Para reducir redundancias, sugiero fusionar las tablas Cedulas y Personas en una sola tabla que maneje la información de las personas y sus cédulas. A continuación, una tabla propuesta para esta fusión:
Tabla Personas_Cedulas

sql

CREATE TABLE Personas_Cedulas (
    id_persona SERIAL PRIMARY KEY,
    numero_cedula VARCHAR(20) UNIQUE NOT NULL,
    nombre VARCHAR(100) NOT NULL,
    apellido VARCHAR(100) NOT NULL,
    sexo CHAR(1),  -- M: Masculino, F: Femenino
    fecha_nacimiento DATE,
    lugar_nacimiento VARCHAR(100),
    telefono VARCHAR(20),
    direccion TEXT,
    email VARCHAR(100),
    id_ruc INTEGER REFERENCES RUC(id_ruc),  -- Referencia a la tabla RUC
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

Con esta estructura:

    La tabla Personas_Cedulas centraliza la información personal y elimina redundancias.
    El campo id_ruc referencia directamente la tabla RUC, evitando duplicaciones de RUC en ambas tablas.
    La tabla Antecedentes_Judiciales seguirá relacionándose con esta nueva tabla a través de numero_cedula.

Tabla Antecedentes Judiciales Ajustada

sql

CREATE TABLE Antecedentes_Judiciales (
    id_antecedente SERIAL PRIMARY KEY,
    numero_cedula VARCHAR(20) REFERENCES Personas_Cedulas(numero_cedula),
    causa_penal TEXT,  -- Descripción de la causa penal
    fecha_causa DATE,
    unidad_procesadora VARCHAR(100),
    juez VARCHAR(100),
    estado_proceso VARCHAR(50),
    fuente VARCHAR(50)  -- 'capt01.dbf'
);

Conclusión

La estructura actual contiene varias redundancias, especialmente entre las tablas Cedulas y Personas. La propuesta es fusionarlas en una sola tabla que maneje la información personal y elimine la duplicación de datos. Además, la tabla RUC debería estar relacionada con Personas mediante una referencia, en lugar de duplicar el campo ruc. Esto ayudará a mantener la integridad y normalización de los datos.

estoy en la parálisis por análisis. tengo varios modelos para la base postgresql pero quedo sin acción porque a la lógica del negocio se le suma la gran cantidad de datos que quiero tener de antemano. Ayudame con las tablas necesarias para ingresar los datos personales de diversas dbf y los ruc así como las rutas json, geojson y kml

Para ayudarte a evitar la "parálisis por análisis" y definir las tablas necesarias para tu base de datos PostgreSQL, te propongo una estructura clara que integre los datos de cédulas, RUC, antecedentes judiciales, y rutas (JSON, GeoJSON, KML). Basada en tu lógica del negocio y la información proporcionada en el archivo, aquí tienes las tablas más relevantes que podrían organizar mejor los datos.
1. Tabla Personas (Cédulas, RUC, y datos personales)

Esta tabla consolidará los datos personales, eliminando redundancias y manteniendo las relaciones claras para las cédulas y el RUC.

sql

CREATE TABLE Personas (
    id_persona SERIAL PRIMARY KEY,
    numero_cedula VARCHAR(20) UNIQUE NOT NULL,
    nombre VARCHAR(100) NOT NULL,
    apellido VARCHAR(100) NOT NULL,
    sexo CHAR(1),  -- M: Masculino, F: Femenino
    fecha_nacimiento DATE,
    lugar_nacimiento VARCHAR(100),
    telefono VARCHAR(20),
    direccion TEXT,
    email VARCHAR(100),
    id_ruc INTEGER REFERENCES RUC(id_ruc),  -- Referencia a la tabla RUC
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

2. Tabla RUC

Esta tabla gestionará los números de RUC y su relación con personas o empresas.

sql

CREATE TABLE RUC (
    id_ruc SERIAL PRIMARY KEY,
    numero_ruc VARCHAR(20) UNIQUE NOT NULL,
    digito_verificador INT NOT NULL,
    razon_social VARCHAR(255),
    direccion VARCHAR(255),
    telefono VARCHAR(20),
    tipo VARCHAR(20) CHECK (tipo IN ('Persona', 'Empresa')),
    fuente VARCHAR(50)  -- 'ruc.dbf', 'ruc.txt'
);

3. Tabla Antecedentes Judiciales

Relaciona los antecedentes judiciales con personas (usando el número de cédula).

sql

CREATE TABLE Antecedentes_Judiciales (
    id_antecedente SERIAL PRIMARY KEY,
    numero_cedula VARCHAR(20) REFERENCES Personas(numero_cedula),
    causa_penal TEXT,  -- Descripción de la causa penal
    fecha_causa DATE,
    unidad_procesadora VARCHAR(100),
    juez VARCHAR(100),
    estado_proceso VARCHAR(50),
    fuente VARCHAR(50)  -- 'capt01.dbf'
);

4. Tabla de Vehículos

Esta tabla manejará la información de los vehículos utilizados en las rutas.

sql

CREATE TABLE Vehiculos (
    id_vehiculo SERIAL PRIMARY KEY,
    placa VARCHAR(20) UNIQUE NOT NULL,
    marca VARCHAR(50),
    modelo VARCHAR(50),
    año INT,
    numero_motor VARCHAR(50) UNIQUE,
    numero_chasis VARCHAR(50) UNIQUE,
    km_recorridos DECIMAL(10, 2),
    fecha_revision DATE
);

5. Tabla de Rutas (GeoJSON, KML)

Esta tabla almacenará las rutas con la geometría para integrar con datos geoespaciales.

sql

CREATE TABLE Rutas (
    id_ruta SERIAL PRIMARY KEY,
    id_vendedor INTEGER REFERENCES Personas(id_persona),
    fecha DATE DEFAULT CURRENT_DATE,
    coordenadas GEOGRAPHY(LINESTRING, 4326),  -- Integración con GIS
    fuente VARCHAR(50)  -- JSON, GeoJSON, KML
);

6. Tabla Zonas

Almacena la información geográfica de las zonas.

sql

CREATE TABLE Zonas (
    id_zona SERIAL PRIMARY KEY,
    nombre_zona VARCHAR(100) NOT NULL UNIQUE,
    geom GEOGRAPHY(POLYGON, 4326)
);

7. Relaciones de Maletines

Almacena información sobre los productos asignados a vendedores para ser llevados en maletines.

sql

CREATE TABLE Maletines (
    id_maletin SERIAL PRIMARY KEY,
    id_vendedor INTEGER REFERENCES Personas(id_persona),
    fecha_carga DATE DEFAULT CURRENT_DATE
);

CREATE TABLE Productos_Maletin (
    id_maletin INT REFERENCES Maletines(id_maletin),
    id_producto INT REFERENCES Productos(id_producto),
    cantidad INT NOT NULL,
    PRIMARY KEY (id_maletin, id_producto)
);

8. Triggers y Funciones
a. Trigger para Verificar Antecedentes Judiciales

Este trigger verificará automáticamente si una persona tiene antecedentes judiciales al ser registrada como cliente.

sql

CREATE OR REPLACE FUNCTION verificar_antecedentes_judiciales() RETURNS TRIGGER AS $$
BEGIN
    IF EXISTS (SELECT 1 FROM Antecedentes_Judiciales WHERE numero_cedula = NEW.numero_cedula) THEN
        RAISE NOTICE 'La persona con cédula % tiene antecedentes judiciales', NEW.numero_cedula;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tg_verificar_antecedentes
BEFORE INSERT ON Personas
FOR EACH ROW
EXECUTE FUNCTION verificar_antecedentes_judiciales();

Vamos a incluir todas las tablas esenciales para Gabriela Fragancias, cubriendo las áreas de tarjetas, clientes, marcas, productos, pagos y liquidaciones. Aquí te presento una estructura más completa que abarca todos esos elementos y permite manejar las operaciones del negocio eficientemente.
1. Tabla Clientes

Esta tabla manejará los datos de los clientes, que pueden tener múltiples tarjetas.

sql

CREATE TABLE Clientes (
    id_cliente SERIAL PRIMARY KEY,
    id_persona INTEGER REFERENCES Personas(id_persona),  -- Relación con la tabla Personas
    tarjeta VARCHAR(7) UNIQUE NOT NULL,  -- Número de tarjeta obligatorio y único por cliente
    saldo DECIMAL(10, 2) DEFAULT 0,  -- Saldo del cliente
    tipo_pago VARCHAR(20) CHECK (tipo_pago IN ('SEM', 'QUIN', 'MENS')),  -- Tipo de pago: Semanal, Quincenal, Mensual
    fecha_registro DATE DEFAULT CURRENT_DATE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

2. Tabla Marcas

Almacena las marcas de los productos disponibles.

sql

CREATE TABLE Marcas (
    id_marca SERIAL PRIMARY KEY,
    nombre VARCHAR(100) UNIQUE NOT NULL,  -- Nombre único de la marca
    año_fundacion INT
);

3. Tabla Productos

Maneja los productos de la empresa, cada producto está asociado a una marca.

sql

CREATE TABLE Productos (
    id_producto SERIAL PRIMARY KEY,
    codigo_barras VARCHAR(50) UNIQUE NOT NULL,
    nombre VARCHAR(100) NOT NULL,
    id_marca INTEGER REFERENCES Marcas(id_marca),
    precio_contado DECIMAL(10, 2) NOT NULL,  -- Precio al contado
    precio_credito DECIMAL(10, 2) NOT NULL,  -- Precio a crédito
    stock INTEGER NOT NULL,
    descripcion TEXT,
    presentacion VARCHAR(50),
    volumen INT CHECK (volumen BETWEEN 5 AND 200),  -- En mililitros, entre 5ml y 200ml
    es_kit BOOLEAN DEFAULT FALSE,  -- Indica si es un producto en kit
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

4. Tabla Tarjetas

Cada cliente puede tener una o más tarjetas. Las tarjetas están vinculadas con los vendedores, zonas y productos.

sql

CREATE TABLE Tarjetas (
    id_tarjeta SERIAL PRIMARY KEY,
    numero_tarjeta VARCHAR(7) NOT NULL,
    id_cliente INTEGER REFERENCES Clientes(id_cliente),
    id_vendedor INTEGER REFERENCES Personas(id_persona),  -- Relación con la persona que actúa como vendedor
    id_zona INTEGER REFERENCES Zonas(id_zona),  -- Relación con la zona de ventas
    total_gs DECIMAL(10, 2) NOT NULL,  -- Total en guaraníes de la tarjeta
    saldo DECIMAL(10, 2) DEFAULT 0,  -- Saldo pendiente en la tarjeta
    forma_pago VARCHAR(20) CHECK (forma_pago IN ('SEM', 'QUIN', 'MENS')),  -- Periodicidad del pago
    estado VARCHAR(20) CHECK (estado IN ('activa', 'cancelada')) DEFAULT 'activa',  -- Estado de la tarjeta
    fecha_emision DATE DEFAULT CURRENT_DATE,
    id_tarjeta_anterior INTEGER REFERENCES Tarjetas(id_tarjeta)  -- Referencia a la tarjeta anterior en caso de reemplazo
);

5. Tabla Pagos

Aquí se registran los pagos que los clientes realizan para saldar sus tarjetas.

sql

CREATE TABLE Pagos (
    id_pago SERIAL PRIMARY KEY,
    id_tarjeta INTEGER REFERENCES Tarjetas(id_tarjeta),
    fecha_pago DATE DEFAULT CURRENT_DATE,
    monto DECIMAL(10, 2) NOT NULL,  -- Monto pagado
    saldo_restante DECIMAL(10, 2) NOT NULL,  -- Saldo pendiente después del pago
    entrega_inicial BOOLEAN DEFAULT FALSE,  -- Indica si es un pago inicial
    recargo BOOLEAN DEFAULT FALSE  -- Indica si hubo recargo por retraso
);

6. Tabla Productos Vendidos

Registra los productos que han sido vendidos en cada tarjeta.

sql

CREATE TABLE Productos_Vendidos (
    id_producto_vendido SERIAL PRIMARY KEY,
    id_tarjeta INTEGER REFERENCES Tarjetas(id_tarjeta),
    id_producto INTEGER REFERENCES Productos(id_producto),
    cantidad INTEGER CHECK (cantidad > 0),  -- Cantidad vendida
    precio DECIMAL(10, 2)  -- Precio de venta de cada producto
);

7. Tabla de Liquidaciones

Esta tabla almacena las liquidaciones de los empleados (vendedores) basadas en las ventas realizadas.

sql

CREATE TABLE Liquidaciones (
    id_liquidacion SERIAL PRIMARY KEY,
    id_vendedor INT REFERENCES Personas(id_persona),  -- Vendedor que recibe la liquidación
    fecha_liquidacion DATE DEFAULT CURRENT_DATE,
    total_ventas DECIMAL(10, 2),  -- Total de ventas del periodo
    comision DECIMAL(10, 2),  -- Comisión por las ventas realizadas
    total_pagar DECIMAL(10, 2)  -- Total a pagar al vendedor
);

8. Triggers y Funciones
a. Trigger para Actualizar Saldo después de un Pago

Este trigger actualizará el saldo de la tarjeta una vez que el cliente haga un pago.

sql

CREATE OR REPLACE FUNCTION actualizar_saldo_cliente() RETURNS TRIGGER AS $$
BEGIN
    UPDATE Tarjetas 
    SET saldo = saldo - NEW.monto
    WHERE id_tarjeta = NEW.id_tarjeta;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tg_actualizar_saldo
AFTER INSERT ON Pagos
FOR EACH ROW
EXECUTE FUNCTION actualizar_saldo_cliente();

b. Trigger para Actualizar Inventario después de una Venta

Este trigger se asegura de que el stock de los productos sea reducido después de una venta.

sql

CREATE OR REPLACE FUNCTION actualizar_inventario() RETURNS TRIGGER AS $$
BEGIN
    IF NEW.cantidad > (SELECT stock FROM Productos WHERE id_producto = NEW.id_producto) THEN
        RAISE EXCEPTION 'No hay suficiente stock para este producto';
    ELSE
        UPDATE Productos 
        SET stock = stock - NEW.cantidad 
        WHERE id_producto = NEW.id_producto;
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tg_actualizar_inventario
AFTER INSERT ON Productos_Vendidos
FOR EACH ROW
EXECUTE FUNCTION actualizar_inventario();

Conclusión

Esta estructura de tablas cubre las principales áreas de negocio para Gabriela Fragancias, incluyendo la gestión de clientes, productos, marcas, ventas, pagos y liquidaciones. Las relaciones entre las tablas están claras y optimizadas para reflejar los procesos del negocio, y los triggers aseguran que los saldos y el inventario se mantengan actualizados automáticamente.

Con mucho gusto, basándome en mi experiencia en el diseño de bases de datos y optimización de procesos, aquí te doy algunas recomendaciones clave que pueden ser útiles para Gabriela Fragancias:
1. Diseño Escalable y Normalizado

La estructura que propusimos sigue las reglas de normalización para evitar redundancias. Esto es especialmente importante cuando trabajas con muchos clientes, productos y transacciones. La idea es que cada entidad (cliente, producto, venta) tenga una tabla dedicada y que las relaciones se manejen a través de claves foráneas.

Recomendación:

    Mantén la normalización, pero si detectas que ciertas consultas se vuelven lentas debido a muchas relaciones, podrías desnormalizar algunas tablas o crear vistas materializadas para consultas frecuentes.
    La tabla de Tarjetas puede ser crítica por el volumen de datos que manejarás, así que asegúrate de crear índices sobre los campos que más consultarás (e.g., numero_tarjeta, id_cliente).

2. Optimización para Transacciones y Consultas

Es fundamental optimizar las transacciones relacionadas con pagos, ventas y liquidaciones, ya que estas operaciones serán frecuentes y afectan múltiples tablas.

Recomendación:

    Crea índices en las columnas claves como id_cliente, id_producto, id_tarjeta, y id_vendedor. Esto mejorará el rendimiento de las consultas que involucran estas claves.
    Utiliza transacciones para asegurar que las operaciones se completen en su totalidad. Por ejemplo, al realizar una venta, podrías reducir el inventario y aumentar el saldo en la tarjeta del cliente, todo en una transacción atómica que asegure la consistencia.

3. Manejo de Saldos y Liquidaciones

El cálculo de saldo de las tarjetas y las liquidaciones de los vendedores es esencial para el negocio. Aquí se debe tener cuidado con el cálculo de comisiones, actualización de saldos y control de pagos.

Recomendación:

    Implementa una lógica de cálculo de comisiones que sea flexible. Puedes usar una tabla adicional que almacene las tasas de comisión por producto o vendedor.
    Triggers bien implementados como los que propusimos para el inventario y los pagos te ayudarán a mantener la base de datos siempre actualizada sin errores.
    Para las liquidaciones, usa una función que calcule las comisiones a partir de las ventas asociadas al vendedor, y asegúrate de que este proceso sea auditable, manteniendo registros de los periodos de liquidación.

4. Consultas y Reportes

Al manejar un negocio de ventas como este, necesitarás informes sobre ventas, pagos y rendimiento de los vendedores. Las consultas para generar estos informes pueden ser complejas si los datos crecen, pero con un buen diseño puedes optimizarlas.

Recomendación:

    Crea vistas que te permitan obtener rápidamente información resumida, como el total de ventas por cliente, zona o vendedor. Estas vistas se pueden consultar directamente para generar reportes.
    Para gráficos y análisis más avanzados (como el rendimiento de ventas por zona), integra tu base de datos con herramientas como Python (usando bibliotecas como Pandas y Matplotlib) para generar gráficos interactivos.

Ejemplo de consulta para ventas por zona:

sql

SELECT Z.nombre_zona, SUM(T.total_gs) AS total_ventas
FROM Zonas Z
JOIN Tarjetas T ON Z.id_zona = T.id_zona
GROUP BY Z.nombre_zona;

5. Manejo de Reemplazos y Clientes con Múltiples Tarjetas

Como mencionaste, los clientes pueden tener varias tarjetas o pueden ser reemplazados por otros clientes. Este es un escenario común, pero también puede complicar la integridad de los datos.

Recomendación:

    Usa la columna id_tarjeta_anterior en la tabla de Tarjetas para hacer un seguimiento histórico de las tarjetas reemplazadas. Esto te permitirá tener un registro claro de qué tarjeta estaba asignada a qué cliente en un momento determinado.
    Implementa un sistema de auditoría simple para guardar el historial de cambios en las tarjetas y los clientes.

6. Seguridad y Permisos

Debido a la naturaleza de los datos sensibles (información personal, detalles de pago), es fundamental implementar medidas de seguridad adecuadas.

Recomendación:

    Establece roles y permisos en PostgreSQL para limitar quién puede acceder a qué datos. Los vendedores no deberían tener acceso a todos los datos de clientes, solo a los suyos.
    Utiliza encriptación para los datos sensibles como contraseñas y, si es necesario, encriptación de nivel de base de datos para los detalles de tarjetas de crédito.

7. Manejo de Gran Volumen de Datos

A medida que tu base de datos crezca, el rendimiento puede verse afectado. Hay técnicas avanzadas para manejar grandes volúmenes de datos, como el particionamiento de tablas o la creación de índices adicionales.

Recomendación:

    Particionamiento de tablas: Si tu negocio crece mucho, particiona las tablas de grandes volúmenes de datos, como Tarjetas o Productos_Vendidos, por año o por mes.
    Implementa archivos históricos para datos que ya no sean críticos. Por ejemplo, puedes archivar tarjetas canceladas o pagos antiguos en una tabla de historiales para mejorar el rendimiento de las consultas activas.

8. Visualización de Datos

Al integrar el sistema con herramientas de visualización en Python, puedes generar gráficos que faciliten la toma de decisiones. Las ventas por zona o por producto pueden visualizarse fácilmente con gráficos de barras o mapas geoespaciales.

Ejemplo en Python para generar un gráfico de ventas por zona:

python

import matplotlib.pyplot as plt
import psycopg2
import pandas as pd

# Conectar a PostgreSQL
conn = psycopg2.connect("dbname=gabriela_fragancias user=tu_usuario password=tu_password")
query = "SELECT Z.nombre_zona, SUM(T.total_gs) AS total_ventas FROM Zonas Z JOIN Tarjetas T ON Z.id_zona = T.id_zona GROUP BY Z.nombre_zona"
df = pd.read_sql(query, conn)

# Graficar
df.plot(kind='bar', x='nombre_zona', y='total_ventas', legend=False)
plt.title('Ventas por Zona')
plt.show()

Conclusión

Lo esencial es que mantengas la flexibilidad en el sistema para adaptarse a los cambios futuros y que implementes buenas prácticas de seguridad, escalabilidad y optimización. Este diseño es robusto, pero puedes adaptarlo conforme aumenten los datos y las necesidades del negocio.

A continuación te presento el código SQL completo para las tablas faltantes que mencionaste, como tarjetas, clientes, marcas, productos, pagos, y liquidaciones, que forman parte del sistema de Gabriela Fragancias.
1. Tabla Clientes

Esta tabla es la base de los clientes registrados en el sistema, vinculada a la tabla de personas.

sql

CREATE TABLE Clientes (
    id_cliente SERIAL PRIMARY KEY,
    id_persona INTEGER REFERENCES Personas(id_persona),  -- Relación con la tabla Personas
    tarjeta VARCHAR(7) UNIQUE NOT NULL,  -- Número de tarjeta obligatorio y único por cliente
    saldo DECIMAL(10, 2) DEFAULT 0,  -- Saldo del cliente
    tipo_pago VARCHAR(20) CHECK (tipo_pago IN ('SEM', 'QUIN', 'MENS')),  -- Tipo de pago: Semanal, Quincenal, Mensual
    fecha_registro DATE DEFAULT CURRENT_DATE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

2. Tabla Marcas

Aquí se almacenan las marcas de los productos que maneja la empresa.

sql

CREATE TABLE Marcas (
    id_marca SERIAL PRIMARY KEY,
    nombre VARCHAR(100) UNIQUE NOT NULL,  -- Nombre único de la marca
    año_fundacion INT
);

3. Tabla Productos

Los productos disponibles en Gabriela Fragancias, con sus precios y otros detalles.

sql

CREATE TABLE Productos (
    id_producto SERIAL PRIMARY KEY,
    codigo_barras VARCHAR(50) UNIQUE NOT NULL,
    nombre VARCHAR(100) NOT NULL,
    id_marca INTEGER REFERENCES Marcas(id_marca),  -- Relación con la tabla Marcas
    precio_contado DECIMAL(10, 2) NOT NULL,  -- Precio de venta al contado
    precio_credito DECIMAL(10, 2) NOT NULL,  -- Precio de venta a crédito
    stock INTEGER NOT NULL,  -- Cantidad de productos disponibles
    descripcion TEXT,
    presentacion VARCHAR(50),  -- Formato del producto
    volumen INT CHECK (volumen BETWEEN 5 AND 200),  -- Volumen en mililitros
    es_kit BOOLEAN DEFAULT FALSE,  -- Indica si es un producto en kit
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

4. Tabla Tarjetas

Las tarjetas que tienen los clientes, vinculadas con vendedores y zonas.

sql

CREATE TABLE Tarjetas (
    id_tarjeta SERIAL PRIMARY KEY,
    numero_tarjeta VARCHAR(7) NOT NULL,
    id_cliente INTEGER REFERENCES Clientes(id_cliente),  -- Cliente al que pertenece la tarjeta
    id_vendedor INTEGER REFERENCES Personas(id_persona),  -- Vendedor que emitió la tarjeta
    id_zona INTEGER REFERENCES Zonas(id_zona),  -- Zona geográfica vinculada a la tarjeta
    total_gs DECIMAL(10, 2) NOT NULL,  -- Monto total de la tarjeta
    saldo DECIMAL(10, 2) DEFAULT 0,  -- Saldo pendiente en la tarjeta
    forma_pago VARCHAR(20) CHECK (forma_pago IN ('SEM', 'QUIN', 'MENS')),  -- Periodicidad del pago
    estado VARCHAR(20) CHECK (estado IN ('activa', 'cancelada')) DEFAULT 'activa',  -- Estado actual de la tarjeta
    fecha_emision DATE DEFAULT CURRENT_DATE,  -- Fecha de emisión de la tarjeta
    id_tarjeta_anterior INTEGER REFERENCES Tarjetas(id_tarjeta)  -- Tarjeta anterior en caso de reemplazo
);

5. Tabla Pagos

Esta tabla guarda los pagos realizados por los clientes para saldar sus tarjetas.

sql

CREATE TABLE Pagos (
    id_pago SERIAL PRIMARY KEY,
    id_tarjeta INTEGER REFERENCES Tarjetas(id_tarjeta),  -- Tarjeta sobre la que se realiza el pago
    fecha_pago DATE DEFAULT CURRENT_DATE,  -- Fecha del pago
    monto DECIMAL(10, 2) NOT NULL,  -- Monto del pago
    saldo_restante DECIMAL(10, 2) NOT NULL,  -- Saldo pendiente después del pago
    entrega_inicial BOOLEAN DEFAULT FALSE,  -- Indica si es el primer pago
    recargo BOOLEAN DEFAULT FALSE  -- Indica si hubo recargo por retraso
);

6. Tabla Productos Vendidos

Registro de los productos vendidos asociados a las tarjetas.

sql

CREATE TABLE Productos_Vendidos (
    id_producto_vendido SERIAL PRIMARY KEY,
    id_tarjeta INTEGER REFERENCES Tarjetas(id_tarjeta),  -- Relación con la tabla Tarjetas
    id_producto INTEGER REFERENCES Productos(id_producto),  -- Relación con la tabla Productos
    cantidad INTEGER CHECK (cantidad > 0),  -- Cantidad vendida de ese producto
    precio DECIMAL(10, 2)  -- Precio de venta del producto
);

7. Tabla de Liquidaciones

Esta tabla maneja las liquidaciones de los vendedores, calculadas sobre las ventas realizadas.

sql

CREATE TABLE Liquidaciones (
    id_liquidacion SERIAL PRIMARY KEY,
    id_vendedor INTEGER REFERENCES Personas(id_persona),  -- Relación con la tabla Personas
    fecha_liquidacion DATE DEFAULT CURRENT_DATE,  -- Fecha de la liquidación
    total_ventas DECIMAL(10, 2),  -- Total de ventas del vendedor
    comision DECIMAL(10, 2),  -- Comisión calculada sobre las ventas
    total_pagar DECIMAL(10, 2)  -- Total a pagar al vendedor
);

Triggers y Funciones para Actualizar Saldos y Stocks
a. Trigger para Actualizar el Saldo de la Tarjeta después de un Pago

Este trigger actualiza el saldo de la tarjeta automáticamente cuando el cliente realiza un pago.

sql

CREATE OR REPLACE FUNCTION actualizar_saldo_tarjeta() RETURNS TRIGGER AS $$
BEGIN
    UPDATE Tarjetas 
    SET saldo = saldo - NEW.monto
    WHERE id_tarjeta = NEW.id_tarjeta;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tg_actualizar_saldo
AFTER INSERT ON Pagos
FOR EACH ROW
EXECUTE FUNCTION actualizar_saldo_tarjeta();

b. Trigger para Actualizar el Inventario de Productos después de una Venta

Este trigger controla el stock de los productos cada vez que se realiza una venta.

sql

CREATE OR REPLACE FUNCTION actualizar_inventario_producto() RETURNS TRIGGER AS $$
BEGIN
    IF NEW.cantidad > (SELECT stock FROM Productos WHERE id_producto = NEW.id_producto) THEN
        RAISE EXCEPTION 'No hay suficiente stock para este producto';
    ELSE
        UPDATE Productos 
        SET stock = stock - NEW.cantidad 
        WHERE id_producto = NEW.id_producto;
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tg_actualizar_inventario
AFTER INSERT ON Productos_Vendidos
FOR EACH ROW
EXECUTE FUNCTION actualizar_inventario_producto();

Conclusión

Este código SQL completo cubre todos los elementos clave de tu sistema, integrando clientes, tarjetas, productos, ventas, pagos y liquidaciones. Con estas tablas y triggers, puedes gestionar eficientemente el inventario, los pagos, y el saldo de los clientes, asegurando que los procesos de ventas y liquidaciones se actualicen automáticamente.

¿Te gustaría agregar alguna funcionalidad o ajustar alguna parte de este esquema? ¡Estoy aquí para ayudarte!
Tú dijiste:
en la tarjeta pagos, recargo hace referencia a nueva venta, no a interés moratorio (que es del 5% mensual)
ChatGPT Plus
ChatGPT

¡Entendido! Si el campo recargo en la tabla Pagos hace referencia a una nueva venta y no a un interés moratorio, entonces sería mejor ajustar su semántica para reflejar con claridad su propósito. Además, incluiremos el manejo del interés moratorio (5% mensual) como un cálculo separado en los pagos atrasados.
Modificaciones:

    recargo será renombrado a nueva_venta para reflejar claramente que se refiere a una nueva venta realizada al cliente, asociada a ese pago.
    Agregaremos una lógica para manejar el interés moratorio del 5% mensual si el pago está en mora.

Tabla Pagos (Modificada)

sql

CREATE TABLE Pagos (
    id_pago SERIAL PRIMARY KEY,
    id_tarjeta INTEGER REFERENCES Tarjetas(id_tarjeta),  -- Relación con la tarjeta
    fecha_pago DATE DEFAULT CURRENT_DATE,  -- Fecha en que se realiza el pago
    monto DECIMAL(10, 2) NOT NULL,  -- Monto del pago realizado
    saldo_restante DECIMAL(10, 2) NOT NULL,  -- Saldo pendiente en la tarjeta después del pago
    nueva_venta BOOLEAN DEFAULT FALSE,  -- Indica si el pago está relacionado con una nueva venta
    interes_moratorio DECIMAL(10, 2) DEFAULT 0  -- Interés moratorio aplicado (5% mensual si aplica)
);

Interés Moratorio

Para calcular el interés moratorio del 5% mensual, podemos hacer lo siguiente:

    Al insertar un nuevo pago, si la fecha de vencimiento de la tarjeta es anterior a la fecha de pago, se calculará automáticamente un interés moratorio de 5% sobre el saldo pendiente.
    El campo interes_moratorio almacenará ese valor para reflejarlo en los pagos en mora.

Función para Calcular el Interés Moratorio

Crearemos una función que calcule el interés moratorio si el pago está atrasado:

sql

CREATE OR REPLACE FUNCTION calcular_interes_moratorio() RETURNS TRIGGER AS $$
DECLARE
    dias_atraso INT;
    interes DECIMAL(10, 2);
BEGIN
    -- Calcular los días de atraso
    SELECT EXTRACT(DAY FROM (NEW.fecha_pago - T.fecha_emision)) INTO dias_atraso
    FROM Tarjetas T
    WHERE T.id_tarjeta = NEW.id_tarjeta;

    -- Si el pago está en mora (más de 30 días)
    IF dias_atraso > 30 THEN
        -- Calcular el interés moratorio: 5% mensual (aproximadamente 0.1667% diario)
        interes := (T.saldo * 0.05 / 30) * dias_atraso;
        NEW.interes_moratorio := interes;
    ELSE
        NEW.interes_moratorio := 0;  -- No hay interés moratorio
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

Trigger para Aplicar el Interés Moratorio

El siguiente trigger aplicará automáticamente el interés moratorio al insertar un nuevo pago:

sql

CREATE TRIGGER tg_calcular_interes_moratorio
BEFORE INSERT ON Pagos
FOR EACH ROW
EXECUTE FUNCTION calcular_interes_moratorio();

Ejemplo del Flujo de Pagos:

    Un cliente tiene un saldo pendiente de 1,000 Gs en su tarjeta y su pago se atrasa más de 30 días.
    Al realizar un nuevo pago, si la fecha de pago es posterior al vencimiento, el sistema calcula un interés moratorio del 5% mensual y lo añade al pago.
    El campo nueva_venta indicará si el pago también está asociado a una nueva compra o simplemente es un pago de un saldo existente.

Conclusión

Con estas modificaciones, ahora el campo nueva_venta refleja si el pago está vinculado a una nueva venta, y se implementa el interés moratorio del 5% mensual automáticamente en pagos atrasados. Esto te permitirá gestionar adecuadamente las ventas adicionales y los pagos en mora sin confusión.


-- Gabriela Fragancias Database Schema

-- Creación de la base de datos
CREATE DATABASE gabriela_fragancias;

-- Tabla Clientes
CREATE TABLE Clientes (
    id_cliente SERIAL PRIMARY KEY,
    nombre VARCHAR(100) NOT NULL,
    apellido VARCHAR(100) NOT NULL,
    cedula VARCHAR(20) UNIQUE NOT NULL,
    direccion TEXT NOT NULL,
    telefono VARCHAR(20),
    email VARCHAR(100) UNIQUE,
    zona VARCHAR(50) NOT NULL,
    fecha_registro DATE DEFAULT CURRENT_DATE
);

-- Tabla Productos
CREATE TABLE Productos (
    id_producto SERIAL PRIMARY KEY,
    nombre VARCHAR(100) NOT NULL,
    precio NUMERIC(10,2) NOT NULL,
    categoria VARCHAR(50),
    codigo_barras VARCHAR(13) UNIQUE NOT NULL,
    stock INTEGER NOT NULL
);

-- Tabla Ventas
CREATE TABLE Ventas (
    id_venta SERIAL PRIMARY KEY,
    fecha DATE DEFAULT CURRENT_DATE,
    total NUMERIC(10,2) NOT NULL,
    id_cliente INTEGER REFERENCES Clientes(id_cliente),
    id_vendedor INTEGER REFERENCES Vendedores(id_vendedor)
);

-- Tabla Detalle de Ventas
CREATE TABLE Ventas_Detalle (
    id_venta_detalle SERIAL PRIMARY KEY,
    id_venta INTEGER REFERENCES Ventas(id_venta) ON DELETE CASCADE,
    id_producto INTEGER REFERENCES Productos(id_producto),
    cantidad INTEGER NOT NULL
);

-- Tabla Vendedores
CREATE TABLE Vendedores (
    id_vendedor SERIAL PRIMARY KEY,
    nombre VARCHAR(100) NOT NULL,
    apellido VARCHAR(100) NOT NULL,
    comision NUMERIC(10,2) DEFAULT 50000
);

-- Funciones y Triggers
CREATE OR REPLACE FUNCTION actualizar_stock_producto() 
RETURNS TRIGGER AS $$
BEGIN
    IF (NEW.cantidad > (SELECT stock FROM Productos WHERE id_producto = NEW.id_producto)) THEN
        RAISE EXCEPTION 'No hay suficiente stock para este producto';
    ELSE
        UPDATE Productos 
        SET stock = stock - NEW.cantidad 
        WHERE id_producto = NEW.id_producto;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tg_actualizar_stock
AFTER INSERT ON Ventas_Detalle
FOR EACH ROW
EXECUTE FUNCTION actualizar_stock_producto();

-- Trigger para actualizar el saldo de los clientes tras una venta
CREATE OR REPLACE FUNCTION actualizar_saldo_cliente() 
RETURNS TRIGGER AS $$
BEGIN
    UPDATE Clientes 
    SET saldo = saldo - NEW.total
    WHERE id_cliente = NEW.id_cliente;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tg_actualizar_saldo
AFTER INSERT ON Ventas
FOR EACH ROW
EXECUTE FUNCTION actualizar_saldo_cliente();

-- Índices para optimización de consultas
CREATE INDEX idx_clientes_cedula ON Clientes(cedula);
CREATE INDEX idx_productos_codigo_barras ON Productos(codigo_barras);
CREATE INDEX idx_ventas_fecha ON Ventas(fecha);

-- Otras tablas y relaciones relevantes

-- Más detalles en el archivo completo.
# Manual de Usuario - Base de Datos Gabriela Fragancias

## Introducción
Este manual describe la instalación, uso, y mantenimiento de la base de datos para Gabriela Fragancias, así como las consultas y reportes básicos para gestionar clientes, productos, ventas y más.

## Instalación
1. Cargar el archivo SQL `gabriela_fragancias_schema.sql` en su sistema de base de datos PostgreSQL.
2. Crear la base de datos y las tablas ejecutando el archivo SQL.

## Uso Básico de la Interfaz
### Clientes
- **Registro de Cliente:** Añada los detalles del cliente, como nombre, apellido, cédula y datos de contacto.

### Productos
- **Gestión de Productos:** Administre el inventario de productos, incluyendo el stock y el precio.

### Ventas
- **Registrar Ventas:** Añada ventas y detalles, asignando productos a cada cliente.

## Consultas y Reportes
- **Top Productos Vendidos:** Utilice la función `perfume_mas_vendido` para obtener los productos más vendidos en un rango de fechas.
- **Balance de Clientes:** Consulte el saldo restante para cada cliente usando la vista `VW_Balance_Clientes`.

## Mantenimiento
- **Respaldos y Restauración:** Realice respaldos periódicos de la base de datos para asegurar la integridad de la información.
- **Optimización:** Monitoree el rendimiento de la base de datos y ajuste índices según el uso.

**Para más detalles y ejemplos de uso, consulte el archivo completo.**
