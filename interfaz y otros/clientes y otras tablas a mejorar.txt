-- Tabla de cedulas (referencia)
CREATE TABLE gf.cedulas (
    numero_cedula VARCHAR(20) PRIMARY KEY,
    nombre VARCHAR(100) NOT NULL,
    apellido VARCHAR(100) NOT NULL,
    fecha_nacimiento DATE,
    sexo CHAR(1),
    direccion TEXT,
    id_barrio VARCHAR(3),
    id_distrito VARCHAR(2),
    id_dpto VARCHAR(2),
    zona VARCHAR(2),
    id_via VARCHAR(50),
    lugar_nacimiento VARCHAR(100),
    fecha_defuncion DATE,
    email VARCHAR(100)
);

-- Tabla de RUC
CREATE TABLE gf.ruc (
    numero_ruc VARCHAR(20) PRIMARY KEY,
    razon_social VARCHAR(200),
    direccion TEXT,
    telefono VARCHAR(20),
    estado VARCHAR(20)
);

-- Tabla de clientes modificada
CREATE TABLE gf.clientes (
    id_cliente SERIAL PRIMARY KEY,
    numero_tarjeta VARCHAR(10),  -- Número de tarjeta agregado aquí
    numero_cedula VARCHAR(20) REFERENCES gf.cedulas(numero_cedula),
    numero_ruc VARCHAR(20) REFERENCES gf.ruc(numero_ruc),
    -- Estos campos se llenarán automáticamente desde gf.cedulas
    nombre VARCHAR(100) NOT NULL,
    apellido VARCHAR(100) NOT NULL,
    celular VARCHAR(20),
    barrio VARCHAR(100),
    calle VARCHAR(100),
    numero VARCHAR(20),
    local VARCHAR(255),
    cerca_de TEXT,
    domicilio_particular TEXT,
    estado VARCHAR(20) DEFAULT 'activo' CHECK (estado IN ('activo', 'inactivo', 'moroso')),
    fecha_registro TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- Trigger para auto-completar datos desde la tabla cedulas
CREATE OR REPLACE FUNCTION gf.autocompletar_datos_cedula()
RETURNS TRIGGER AS $$
BEGIN
    -- Si se ingresa un número de cédula, completar datos automáticamente
    IF NEW.numero_cedula IS NOT NULL THEN
        SELECT 
            nombre,
            apellido,
            direccion
        INTO 
            NEW.nombre,
            NEW.apellido,
            NEW.domicilio_particular
        FROM gf.cedulas
        WHERE numero_cedula = NEW.numero_cedula;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tg_autocompletar_cedula
BEFORE INSERT OR UPDATE ON gf.clientes
FOR EACH ROW
EXECUTE FUNCTION gf.autocompletar_datos_cedula();

-- Trigger para auto-completar datos desde RUC
CREATE OR REPLACE FUNCTION gf.autocompletar_datos_ruc()
RETURNS TRIGGER AS $$
BEGIN
    -- Si se ingresa un RUC, completar datos del negocio
    IF NEW.numero_ruc IS NOT NULL THEN
        SELECT 
            razon_social,
            direccion,
            telefono
        INTO 
            NEW.local,
            NEW.domicilio_particular,
            NEW.celular
        FROM gf.ruc
        WHERE numero_ruc = NEW.numero_ruc;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tg_autocompletar_ruc
BEFORE INSERT OR UPDATE ON gf.clientes
FOR EACH ROW
EXECUTE FUNCTION gf.autocompletar_datos_ruc();

-- Índices adicionales para optimizar búsquedas
CREATE INDEX idx_clientes_tarjeta ON gf.clientes(numero_tarjeta);
CREATE INDEX idx_clientes_cedula ON gf.clientes(numero_cedula);
CREATE INDEX idx_clientes_ruc ON gf.clientes(numero_ruc);

-- Vista para facilitar la consulta de datos completos del cliente
CREATE VIEW gf.vista_cliente_completo AS
SELECT 
    c.*,
    ced.fecha_nacimiento,
    ced.sexo,
    ced.lugar_nacimiento,
    r.razon_social,
    r.estado AS estado_ruc
FROM gf.clientes c
LEFT JOIN gf.cedulas ced ON c.numero_cedula = ced.numero_cedula
LEFT JOIN gf.ruc r ON c.numero_ruc = r.numero_ruc;

LA BASE DE DATOS es:
                host="localhost",
                database="Gabriela_Fragancias",
                user="postgres",
                password="salmos23",
				schema="gf"
				
--la tabla cliente es así actualmente:
-- Tabla Clientes
CREATE TABLE gf.clientes (
    id_cliente INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    tarjeta VARCHAR(5), --este número se puede repetir en otras zonas y en la misma con otro cliente
    numero_cedula VARCHAR(20) UNIQUE NOT NULL,
	id_ruc SERIAL PRIMARY KEY, -referencia a la tabla gf.ruc
    nombre VARCHAR(100) NOT NULL,
    apellido VARCHAR(100) NOT NULL,
    id_prefijo INTEGER REFERENCES prefijos(id_prefijo),
    numero_telefono VARCHAR(20),
	numero_celular VARCHAR(20),
    numero_tarjeta VARCHAR(20) UNIQUE,
	id_zona SERIAL PRIMARY KEY,
	id_direccion INTEGER REFERENCES direcciones(id_direccion),
    direccion GEOGRAPHY(POINT, 4326),
    saldo INTEGER DEFAULT 0,
    tipo_pago VARCHAR(20) CHECK (tipo_pago IN ('SEM', 'QUIN', 'MENS')),
    fecha_registro TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    estado VARCHAR(20) CHECK (estado IN ('activo', 'inactivo')) DEFAULT 'activo',
    ultimo_inicio_sesion TIMESTAMP WITH TIME ZONE
);
--para adaptarse a la tarjeta o ficha debería ser así:
CREATE TABLE gf.clientes (
    id_cliente integer NOT NULL,
	producto VARCHAR (100), -- referencia gf.productos nombre VARCHAR(100) NOT NULL
    tarjeta character varying(5),
    numero_cedula character varying(20),  --algunos clientes no dan su numero_cedula e ingresan solo por el nombre y apellido)
    numero_ruc character varying(20), --referencia a gf.ruc
    nombre character varying(100) NOT NULL, --estos datos deben aparecer automáticamente  al ingresar el numero_cedula
    apellido character varying(100) NOT NULL, --estos datos deben aparecer automáticamente  al ingresar el numero_cedula
    id_prefijo_telefono integer, --la idea del prefijo es facilitar y unificar el ingreso del número de teléfono o celular
    id_prefijo_celular integer, --la idea del prefijo es facilitar y unificar el ingreso del número de teléfono o celular
    numero_telefono character varying(20), --en caso de estar con el prefijo (manejar el ingreso de solo el numero y activar el prefijo)
    numero_celular character varying(20), --en caso de estar con el prefijo (manejar el ingreso de solo el numero y activar el prefijo)
    zona integer,
    barrio integer, --(referencia a gf.barrios y localidades)
    id_distrito integer, --(referencia a gf.distritos)
    id_dpto character varying(2), --(referencia a gf.departamentos)
    id_via character varying(50), --(referencia a gf.vias y gf.vias_principales)
    tipo_pago character varying(20),
	total_gs integer DEFAULT 0,
	fecha_registro timestamp with time zone DEFAULT now(),
	entrega integer DEFAULT 0,
	saldo integer DEFAULT 0,
    local character varying(255),
	cerca_de character varying(255),
	domicilio_particular character varying(255),
    estado character varying(20) DEFAULT 'activo'::character varying,
    ultimo_inicio_sesion timestamp with time zone,	
    CONSTRAINT clientes_estado_check CHECK (((estado)::text = ANY ((ARRAY['activo'::character varying, 'inactivo'::character varying])::text[]))),
    CONSTRAINT clientes_tipo_pago_check CHECK (((tipo_pago)::text = ANY ((ARRAY['SEM'::character varying, 'QUIN'::character varying, 'MENS'::character varying])::text[])))
);
--esto es muy necesario
CREATE TABLE RECIBO_CLIENTE (
  ID_COBRANZA ENTERO NOT NULL,
  ID_VENDEDOR ENTERO NOT NULL,
  ID_USUARIO ENTERO NOT NULL,
  FECHA DATE,
  COMENTARIO DIRECION,
  GUARDADO YES_NO,
  TOTAL NUMERO,
  COMISION NUMERO,
  ID_GRUPO ENTERO,
  ANA_ITEMS_CLIENTES ENTERO,
  ANA_ITEMS_CLIENTES_COBRADO ENTERO,
  TOTALACOBRAR NUMERO);


ALTER TABLE RECIBO_CLIENTE ADD CONSTRAINT PK_RECIBO_CLIENTE PRIMARY KEY (ID_COBRANZA);

/* Structure for the `RECIBO_CLIENTE_DETALLE` table :  */

CREATE TABLE RECIBO_CLIENTE_DETALLE (
  ID_COBRANZA_DETALLE ENTERO NOT NULL,
  ID_COBRANZA ENTERO NOT NULL,
  ID_CLIENTE ENTERO NOT NULL,
  MONTO NUMERO,
  COMSION NUMERO,
  NRORECIBO ENTERO);

ALTER TABLE CUENTA_CLIENTE_1 ADD CONSTRAINT PK_CUENTA_CLIENTE_1 PRIMARY KEY (ID_CUENTA_CLIENTE);

ALTER TABLE SIS ADD CONSTRAINT PK_SIS PRIMARY KEY (PRODUCTO);

/* Structure for the `CLIENTE_LLAMADA` table :  */

CREATE TABLE CLIENTE_LLAMADA (
  ID_CLIENTE_LLAMADA ENTERO NOT NULL,
  ID_CLIENTE ENTERO,
  ID_MOTIVO_LLAMADA ENTERO,
  FECHA "DATE",
  HORA HORA,
  MEMO MEMO,
  AGENDAR SI_NO_NO NOT NULL,
  AGENDAR_FECHA "DATE",
  TERMINADO SI_NO_NO NOT NULL,
  NUMERO ALIAS,
  ARCHIVO PICTURE,
  ID_USUARIO ENTERO NOT NULL);


ALTER TABLE CLIENTE_LLAMADA ADD CONSTRAINT PK_CLIENTE_LLAMADA PRIMARY KEY (ID_CLIENTE_LLAMADA);  

CREATE TABLE PEDIDO (
  ID_PEDIDO ENTERO NOT NULL,
  ID_VENDEDOR ENTERO,
  FECHA "DATE",
  CANTIDAD NUMERO,
  PRODUCTO DESCRIPCION_MEDIO,
  ID_CLIENTE ENTERO NOT NULL,
  ENTREGADO SI_NO_NO NOT NULL);

CREATE TABLE gf.cedulas (
    numero_cedula character varying(20) NOT NULL,
    nombre character varying(100) NOT NULL,
    apellido character varying(100) NOT NULL,
    fecha_nacimiento date,
    sexo character(1),
    direccion text,
    id_distrito character varying(2),
    id_dpto character varying(2),
    zona character varying(2),
    lugar_nacimiento character varying(100),
    fecha_defuncion date
);
  
CREATE TABLE gf.cedulas (
    numero_cedula character varying(20) NOT NULL,
    nombre character varying(100) NOT NULL,
    apellido character varying(100) NOT NULL,
    fecha_nacimiento date,
    sexo character(1),
    direccion text,
    id_barrio character varying(3),
    id_distrito character varying(2),
    id_dpto character varying(2),
    zona character varying(2),
    id_via character varying(50),
    lugar_nacimiento character varying(100),
    fecha_defuncion date,
    email character varying(100)
);

CREATE TABLE gf.antecedentes_judiciales (
    id_antecedente integer NOT NULL,
    numero_cedula character varying(20),
    causa_penal text,
    fecha_causa date,
    unidad_procesadora character varying(100),
    juez character varying(100),
    estado_proceso character varying(50),
    fuente character varying(50)
);

CREATE TABLE gf.calificacion_clientes (
    id_calificacion integer NOT NULL,
    descripcion character varying(50) NOT NULL,
    dias_atraso_min integer,
    dias_atraso_max integer
);

CREATE TABLE gf.grupos (
    id_grupo integer NOT NULL,
    descripcion character varying(50) NOT NULL,
    dia_semana character varying(10)
);

CREATE TABLE gf.departamentos (
    dpto character varying(2),
    dpto_desc character varying(20)
);

CREATE TABLE gf.distritos (
    dpto character varying(2),
    distrito character varying(2),
    dpto_desc character varying(20),
    dist_desc character varying(42),
    clave character varying(4)
);

CREATE TABLE gf.empleados (
    id_empleado integer NOT NULL,
    cedula character varying(20),
    nombre character varying(100) NOT NULL,
    apellido character varying(100) NOT NULL,
    telefono character varying(20),
    zona character varying(50),
    cargo character varying(50),
    fecha_contratacion date,
    salario integer,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    deleted_at timestamp without time zone,
    CONSTRAINT empleados_cargo_check CHECK (((cargo)::text = ANY (ARRAY[('Vendedor'::character varying)::text, ('Cobrador'::character varying)::text, ('Chofer'::character varying)::text])))
);

CREATE TABLE gf.productos_vendidos (
    id_tarjeta integer,
    id_producto uuid,
    id_producto_vendido integer NOT NULL,
    cantidad integer,
    precio integer,
    CONSTRAINT productos_vendidos_cantidad_check CHECK ((cantidad > 0))
);

CREATE TABLE gf.sms (
    id_sms integer NOT NULL,
    destinatario character varying(20),
    enviado boolean,
    fecha date,
    hora time without time zone,
    modulo character varying(50),
    referencia character varying(100),
    fecha_env date,
    id_cliente integer,
    id_mensaje_preestablecido integer
);

CREATE TABLE gf.usuario (
    id_usuario uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    nombre character varying(100) NOT NULL,
    apellido character varying(100) NOT NULL,
    cedula character varying(20) NOT NULL,
    email character varying(100) NOT NULL,
    password_hash character varying(255) NOT NULL,
    ultimo_inicio_sesion timestamp with time zone,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    deleted_at timestamp with time zone,
    estado gf.estado_registro DEFAULT 'activo'::gf.estado_registro
);

CREATE TABLE gf.venta (
    id_venta uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    id_cliente uuid NOT NULL,
    id_empleado uuid NOT NULL,
    fecha_venta timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    tipo_pago gf.tipo_pago NOT NULL,
    estado gf.estado_pago DEFAULT 'pendiente'::gf.estado_pago,
    total numeric(10,2) NOT NULL,
    ubicacion_venta public.geography(Point,4326),
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    estado_registro gf.estado_registro DEFAULT 'activo'::gf.estado_registro,
    CONSTRAINT venta_total_check CHECK ((total >= (0)::numeric))
);

CREATE TABLE gf.tarjetas (
    id_tarjeta integer NOT NULL,
    numero_tarjeta character varying(7) NOT NULL,
    id_cliente integer,
    id_vendedor integer,
    zona integer,
    total_gs integer NOT NULL,
    saldo integer DEFAULT 0,
    forma_pago character varying(20),
    estado character varying(20) DEFAULT 'activa'::character varying, --también puede ir 'cancelada', remitida a 'SISCO' o 'InformConf'
    fecha_emision date DEFAULT CURRENT_DATE,
    id_tarjeta_anterior integer,
    CONSTRAINT tarjetas_estado_check CHECK (((estado)::text = ANY ((ARRAY['activa'::character varying, 'cancelada'::character varying])::text[]))),
    CONSTRAINT tarjetas_forma_pago_check CHECK (((forma_pago)::text = ANY ((ARRAY['SEM'::character varying, 'QUIN'::character varying, 'MENS'::character varying])::text[])))
);

--Tabla Tarjetas
CREATE TABLE Tarjetas (
    id_tarjeta SERIAL PRIMARY KEY,
    numero_tarjeta VARCHAR(7) NOT NULL,
    id_cliente INTEGER REFERENCES Clientes(id_cliente),
    id_vendedor INTEGER REFERENCES Vendedores(id_vendedor),
    id_zona INTEGER REFERENCES Zonas(id_zona),
    total_gs INTEGER NOT NULL,
    saldo INTEGER DEFAULT 0,
    forma_pago VARCHAR(20) CHECK (forma_pago IN ('SEM', 'QUIN', 'MENS')),
    estado VARCHAR(20) CHECK (estado IN ('activa', 'cancelada')) DEFAULT 'activa',
    fecha_emision DATE DEFAULT CURRENT_DATE,
    id_tarjeta_anterior INTEGER REFERENCES Tarjetas(id_tarjeta)
);
--Tabla Pagos
CREATE TABLE Pagos (
    id_pago SERIAL PRIMARY KEY,
    id_tarjeta INTEGER REFERENCES Tarjetas(id_tarjeta),
    fecha_pago DATE DEFAULT CURRENT_DATE,
    monto INTEGER NOT NULL,
    saldo_restante INTEGER NOT NULL,
    entrega_inicial BOOLEAN DEFAULT FALSE,
    recargo BOOLEAN DEFAULT FALSE -- ES UNA NUEVA VENTA
);

CREATE TABLE Pagos (
    id_pago SERIAL PRIMARY KEY,
    id_tarjeta INTEGER REFERENCES Tarjetas(id_tarjeta),  -- Relación con la tarjeta
    fecha_pago DATE DEFAULT CURRENT_DATE,  -- Fecha en que se realiza el pago
    monto INTEGER NOT NULL,  -- Monto del pago realizado
    saldo_restante INTEGER NOT NULL,  -- Saldo pendiente en la tarjeta después del pago
    nueva_venta BOOLEAN DEFAULT FALSE,  -- Indica si el pago está relacionado con una nueva venta
    interes_moratorio INTEGER DEFAULT 0  -- Interés moratorio aplicado (5% mensual si aplica)
);

--Tabla de Productos
CREATE TABLE Productos (
    id_producto SERIAL PRIMARY KEY,
    nombre VARCHAR(100) NOT NULL,
    codigo_barras VARCHAR(13) UNIQUE NOT NULL,
    precio_costo INTEGER,
    precio_venta INTEGER,
    stock INTEGER DEFAULT 0,
    descripcion TEXT
);

--Tabla Productos Vendidos
CREATE TABLE Productos_Vendidos (
    id_producto_vendido SERIAL PRIMARY KEY,
    id_tarjeta INTEGER REFERENCES Tarjetas(id_tarjeta),
    id_producto INTEGER REFERENCES Productos(id_producto),
    cantidad INTEGER CHECK (cantidad > 0),
    precio INTEGER
);

--Tabla de Inventario (Maletines de Productos)
CREATE TABLE Inventario (
    id_inventario SERIAL PRIMARY KEY,
    id_vendedor INTEGER REFERENCES Vendedores(id_vendedor),
    id_producto INTEGER REFERENCES Productos(id_producto),
    cantidad INTEGER NOT NULL
);



-- Insertar los datos de la empresa con logotipo
INSERT INTO Empresa (ruc, razon_social, logotipo)
VALUES ('4974638-3', 'Gabriela Fragancias', pg_read_binary_file("D:\Gabriela Fragancias\Datos\Diseños\Gabriela Fragancias (logo torre).png"));

-- Insertar los datos de la empresa sin logotipo
INSERT INTO Empresa (ruc, razon_social)
VALUES ('4974638-3', 'Gabriela Fragancias');

-- Insertar un cliente
INSERT INTO Clientes (cedula, nombre, apellido, telefono, direccion, email)
VALUES ('1234567890', 'Juan', 'Pérez', '0981123456', 'Av. Siempre Viva', 'juan.perez@email.com');

-- Insertar una tarjeta para ese cliente
INSERT INTO Tarjetas (numero_tarjeta, id_cliente, id_vendedor, id_zona, total_gs, saldo, forma_pago)
VALUES ('0012345', 1, 1, 1, 150000, 150000, 'SEM');

-- Insertar un pago para la tarjeta
INSERT INTO Pagos (id_tarjeta, fecha_pago, monto, saldo_restante, entrega_inicial)
VALUES (1, '2024-10-01', 50000, 100000, TRUE);

2. Funciones y Triggers Relacionados
a) Función para Verificar Antecedentes Judiciales

sql

-- Función para verificar si una persona tiene antecedentes judiciales
CREATE OR REPLACE FUNCTION verificar_antecedentes()
RETURNS TRIGGER AS $$
BEGIN
    IF EXISTS (SELECT 1 FROM antecedentes_judiciales WHERE numero_ci = NEW.cedula) THEN
        RAISE NOTICE 'La persona con cédula % tiene antecedentes judiciales', NEW.cedula;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger que llama a la función al insertar un cliente
CREATE TRIGGER tg_verificar_antecedentes
BEFORE INSERT ON clientes
FOR EACH ROW
EXECUTE FUNCTION verificar_antecedentes();

b) Trigger para Registrar Ubicación GPS

sql

-- Función para registrar ubicaciones GPS
CREATE OR REPLACE FUNCTION registrar_gps()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO tracking_gps (id_vehiculo, coordenadas, latitud, longitud)
    VALUES (NEW.id_vehiculo, ST_SetSRID(ST_MakePoint(NEW.longitud, NEW.latitud), 4326), NEW.latitud, NEW.longitud);
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger que se ejecuta tras registrar una ubicación GPS
CREATE TRIGGER tg_registrar_gps
AFTER INSERT ON tracking_gps
FOR EACH ROW
EXECUTE FUNCTION registrar_gps();

c) CREATE OR REPLACE FUNCTION verificar_defuncion() 
RETURNS TRIGGER AS $$
BEGIN
    IF (NEW.fecha_defuncion IS NOT NULL) THEN
        RAISE NOTICE 'La persona con cédula % ha sido marcada como fallecida.', NEW.cedula;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tg_verificar_defuncion
AFTER INSERT OR UPDATE ON Personas
FOR EACH ROW
EXECUTE FUNCTION verificar_defuncion();

d) -- Trigger para actualizar el stock de productos después de una venta
CREATE OR REPLACE FUNCTION actualizar_stock_producto() 
RETURNS TRIGGER AS $$
BEGIN
    IF (NEW.cantidad > (SELECT stock FROM Productos WHERE id_producto = NEW.id_producto)) THEN
        RAISE EXCEPTION 'No hay suficiente stock para este producto';
    ELSE
        UPDATE Productos 
        SET stock = stock - NEW.cantidad 
        WHERE id_producto = NEW.id_producto;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tg_actualizar_stock
AFTER INSERT ON Ventas
FOR EACH ROW
EXECUTE FUNCTION actualizar_stock_producto();

e) -- Trigger para actualizar el saldo de los clientes tras una venta
CREATE OR REPLACE FUNCTION actualizar_saldo_cliente() 
RETURNS TRIGGER AS $$
BEGIN
    UPDATE Clientes 
    SET saldo = saldo - NEW.total
    WHERE id_cliente = NEW.id_cliente;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tg_actualizar_saldo
AFTER INSERT ON Ventas
FOR EACH ROW
EXECUTE FUNCTION actualizar_saldo_cliente();

-- Tabla de Equipos (para manejar lectores de códigos, impresoras, etc.)
CREATE TABLE equipos (
    id_equipo SERIAL PRIMARY KEY,
    tipo VARCHAR(50) CHECK (tipo IN ('Lector Código Barras', 'Impresora Ticket', 'Impresora Matricial', 'Impresora Láser', 'Impresora Inyección')),
    marca VARCHAR(50), CHARACTER SET utf8mb4;
    modelo VARCHAR(50), CHARACTER SET utf8mb4;
    fecha_adquisicion DATE
);

-- Índices para optimizar consultas frecuentes
CREATE INDEX idx_productos_marca ON Productos(ID_Marca);
CREATE INDEX idx_ventas_cliente ON Ventas(ID_Cliente);
CREATE INDEX idx_ventas_fecha ON Ventas(Fecha_Venta);
CREATE INDEX idx_inventario_producto ON Inventario(ID_Producto);

-- Índices para mejorar el rendimiento
CREATE INDEX idx_clientes_cedula ON clientes(cedula);
CREATE INDEX idx_clientes_ruc ON clientes(ruc);
CREATE INDEX idx_productos_codigo_barras ON productos(codigo_barras);
CREATE INDEX idx_ventas_fecha ON ventas(fecha_venta);
CREATE INDEX idx_empleados_cargo ON empleados(cargo);
CREATE INDEX idx_cliente_cedula ON Cliente(cedula);

-- Trigger que ejecuta la función al insertar una venta
CREATE TRIGGER tg_actualizar_saldo
AFTER INSERT ON Ventas
FOR EACH ROW
EXECUTE FUNCTION actualizar_saldo_cliente();
CREATE OR REPLACE FUNCTION actualizar_stock_producto() 
RETURNS TRIGGER AS $$
BEGIN
    IF (NEW.cantidad > (SELECT stock FROM Productos WHERE id_producto = NEW.id_producto)) THEN
        RAISE EXCEPTION 'No hay suficiente stock para este producto';
    ELSE
        UPDATE Productos 
        SET stock = stock - NEW.cantidad 
        WHERE id_producto = NEW.id_producto;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION actualizar_saldo_cliente() 
RETURNS TRIGGER AS $$
BEGIN
    UPDATE Clientes 
    SET saldo = saldo - NEW.total
    WHERE id_cliente = NEW.id_cliente;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger que ejecuta la función al insertar una venta
CREATE TRIGGER tg_actualizar_stock
AFTER INSERT ON Ventas
FOR EACH ROW
EXECUTE FUNCTION actualizar_stock_producto();

-- Función para verificar antecedentes judiciales al insertar un cliente
CREATE OR REPLACE FUNCTION verificar_antecedentes_judiciales()
RETURNS TRIGGER AS $$
BEGIN
    IF EXISTS (
        SELECT 1 FROM AntecedentesJudiciales
        WHERE numero_ci = NEW.cedula
    ) THEN
        RAISE NOTICE 'El cliente con cédula % tiene antecedentes judiciales', NEW.cedula;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger para llamar a la función al insertar un cliente
CREATE TRIGGER tg_verificar_antecedentes_judiciales
BEFORE INSERT ON Clientes
FOR EACH ROW
EXECUTE FUNCTION verificar_antecedentes_judiciales();

-- Trigger para actualizar el stock al vender
CREATE OR REPLACE FUNCTION actualizar_stock() RETURNS TRIGGER AS $$
BEGIN
    IF NEW.cantidad > OLD.stock THEN
        RAISE EXCEPTION 'No hay suficiente stock';
    ELSE
        UPDATE Inventario SET stock = stock - NEW.cantidad WHERE id_presentacion = NEW.id_presentacion;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tg_actualizar_stock
AFTER INSERT ON DetalleVenta
FOR EACH ROW EXECUTE FUNCTION actualizar_stock();

CREATE OR REPLACE FUNCTION actualizar_saldo_cliente() 
RETURNS TRIGGER AS $$
BEGIN
    UPDATE Clientes 
    SET saldo = saldo - NEW.total
    WHERE id_cliente = NEW.id_cliente;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Vistas para reportes comunes
CREATE VIEW VW_Ventas_Por_Cliente AS
SELECT 
    c.ID_Cliente, 
    c.Nombre, 
    c.Apellido, 
    COUNT(v.ID_Venta) AS Total_Ventas, 
    SUM(v.Total) AS Monto_Total
FROM 
    Clientes c
LEFT JOIN 
    Ventas v ON c.ID_Cliente = v.ID_Cliente
GROUP BY 
    c.ID_Cliente;

CREATE VIEW VW_Stock_Productos AS
SELECT 
    p.ID_Producto, 
    p.Nombre, 
    m.Nombre AS Marca, 
    p.Stock, 
    p.Precio_Venta
FROM 
    Productos p
JOIN 
    Marcas m ON p.ID_Marca = m.ID_Marca;

-- Trigger para verificar si un cliente tiene antecedentes judiciales
CREATE OR REPLACE FUNCTION verificar_antecedentes() 
RETURNS TRIGGER AS $$
BEGIN
    IF EXISTS (SELECT 1 FROM AntecedentesJudiciales WHERE cedula = NEW.cedula) THEN
        RAISE NOTICE 'El cliente con cédula % tiene antecedentes judiciales', NEW.cedula;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tg_verificar_antecedentes
BEFORE INSERT ON Clientes
FOR EACH ROW
EXECUTE FUNCTION verificar_antecedentes();

-- Trigger para actualizar la comisión de las vendedoras tras una venta
CREATE OR REPLACE FUNCTION actualizar_comision_vendedora() 
RETURNS TRIGGER AS $$
BEGIN
    UPDATE Liquidaciones 
    SET total_ventas = total_ventas + NEW.total,
        comision = comision + (50000 * NEW.cantidad)  -- Comisión por producto
    WHERE id_vendedor = NEW.id_vendedor;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tg_actualizar_comision
AFTER INSERT ON Ventas
FOR EACH ROW
EXECUTE FUNCTION actualizar_comision_vendedora();

-- Índices faltantes para optimización de consultas
CREATE INDEX idx_rutas_vendedor_fecha ON Rutas(id_vendedor, fecha);
CREATE INDEX idx_pagos_cliente_metodo ON Pagos(id_cliente, metodo_pago);
CREATE INDEX idx_antecedentes_cedula ON AntecedentesJudiciales(cedula);
CREATE INDEX idx_inventario_maletines_producto ON Inventario_Maletines(id_maletin, id_producto);
CREATE INDEX idx_vehiculos_motor_chasis_placa ON Vehiculos(numero_motor, numero_chasis, placa);

-- Trigger para verificar si un cliente tiene antecedentes judiciales

CREATE OR REPLACE FUNCTION verificar_antecedentes() 

RETURNS TRIGGER AS $$

BEGIN

    IF EXISTS (SELECT 1 FROM AntecedentesJudiciales WHERE cedula = NEW.cedula) THEN

        RAISE NOTICE 'El cliente con cédula % tiene antecedentes judiciales', NEW.cedula;

    END IF;

    RETURN NEW;

END;

$$ LANGUAGE plpgsql;


CREATE TRIGGER tg_verificar_antecedentes

BEFORE INSERT ON Clientes

FOR EACH ROW

EXECUTE FUNCTION verificar_antecedentes();


-- Trigger para actualizar la comisión de las vendedoras tras una venta

CREATE OR REPLACE FUNCTION actualizar_comision_vendedora() 

RETURNS TRIGGER AS $$

BEGIN

    UPDATE Liquidaciones 

    SET total_ventas = total_ventas + NEW.total,

        comision = comision + (50000 * NEW.cantidad)  -- Comisión por producto

    WHERE id_vendedor = NEW.id_vendedor;

    RETURN NEW;

END;

$$ LANGUAGE plpgsql;


CREATE TRIGGER tg_actualizar_comision

AFTER INSERT ON Ventas

FOR EACH ROW

EXECUTE FUNCTION actualizar_comision_vendedora();


-- Índices faltantes para optimización de consultas

CREATE INDEX idx_rutas_vendedor_fecha ON Rutas(id_vendedor, fecha);

CREATE INDEX idx_pagos_cliente_metodo ON Pagos(id_cliente, metodo_pago);

CREATE INDEX idx_antecedentes_cedula ON AntecedentesJudiciales(cedula);

CREATE INDEX idx_inventario_maletines_producto ON Inventario_Maletines(id_maletin, id_producto);

CREATE INDEX idx_vehiculos_motor_chasis_placa ON Vehiculos(numero_motor, numero_chasis, placa);

Trigger verificar_antecedentes

CREATE OR REPLACE FUNCTION actualizar_comision_vendedora() 
RETURNS TRIGGER AS $$
BEGIN
    -- Utilizar una transacción para garantizar la consistencia de los datos
    BEGIN
        UPDATE Liquidaciones 
        SET total_ventas = total_ventas + NEW.total,
            comision = comision + (SELECT comisión_por_producto FROM Productos WHERE id_producto = NEW.id_producto) * NEW.cantidad
        WHERE id_vendedor = NEW.id_vendedor;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE NOTICE 'Error al actualizar la comisión: %', SQLERRM;
    END;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Función para registrar eventos en un log
CREATE OR REPLACE FUNCTION registrar_evento(evento TEXT)
RETURNS VOID AS $$
BEGIN
    INSERT INTO Log (fecha, evento) VALUES (NOW(), evento);
END;
$$ LANGUAGE plpgsql;

-- Trigger para verificar antecedentes judiciales y registrar en el log
CREATE OR REPLACE FUNCTION verificar_antecedentes() 
RETURNS TRIGGER AS $$
BEGIN
    IF EXISTS (SELECT 1 FROM AntecedentesJudiciales WHERE cedula = NEW.cedula) THEN
        RAISE NOTICE 'El cliente con cédula % tiene antecedentes judiciales', NEW.cedula;
        PERFORM registrar_evento('Cliente con antecedentes: ' || NEW.cedula);
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger para actualizar la comisión de las vendedoras tras una venta
CREATE OR REPLACE FUNCTION actualizar_comision_vendedora() 
RETURNS TRIGGER AS $$
BEGIN
    BEGIN
        UPDATE Liquidaciones 
        SET total_ventas = total_ventas + NEW.total,
            comision = comision + (SELECT comision FROM Comisiones WHERE id_producto = NEW.id_producto) * NEW.cantidad
        WHERE id_vendedor = NEW.id_vendedor;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            PERFORM registrar_evento('Error al actualizar comisión: ' || SQLERRM);
    END;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Índices adicionales (adapta según tu esquema)
CREATE INDEX idx_liquidaciones_vendedor ON Liquidaciones(id_vendedor);
CREATE INDEX idx_comisiones_producto ON Comisiones(id_producto);

-- Función para obtener el perfume más vendido en un rango de fechas
CREATE OR REPLACE FUNCTION perfume_mas_vendido(fecha_inicio DATE, fecha_fin DATE)
RETURNS TABLE (perfume VARCHAR, total_vendido NUMERIC) AS $$
BEGIN
  RETURN QUERY
  SELECT p.nombre, SUM(vd.cantidad) AS total_vendido
  FROM ventas v
  INNER JOIN ventas_detalle vd ON v.id_venta = vd.id_venta
  INNER JOIN productos p ON vd.id_producto = p.id_producto
  WHERE v.fecha BETWEEN fecha_inicio AND fecha_fin
  GROUP BY p.nombre
  ORDER BY total_vendido DESC
  LIMIT 1;
END;
$$ LANGUAGE plpgsql;

-- Función para obtener los top N perfumes vendidos por año
CREATE OR REPLACE FUNCTION top_perfumes_por_ano(ano INTEGER, n INTEGER)
RETURNS TABLE (perfume VARCHAR, total_vendido NUMERIC) AS $$
BEGIN
  RETURN QUERY
  SELECT p.nombre, SUM(vd.cantidad) AS total_vendido
  FROM ventas v
  INNER JOIN ventas_detalle vd ON v.id_venta = vd.id_venta
  INNER JOIN productos p ON vd.id_producto = p.id_producto
  WHERE EXTRACT(YEAR FROM v.fecha) = ano
  GROUP BY p.nombre
  ORDER BY total_vendido DESC
  LIMIT n;
END;
$$ LANGUAGE plpgsql;

-- Trigger para actualizar el stock de productos después de una venta
CREATE OR REPLACE FUNCTION actualizar_stock_producto() 
RETURNS TRIGGER AS $$
BEGIN
    IF (NEW.cantidad > (SELECT stock FROM Productos WHERE id_producto = NEW.id_producto)) THEN
        RAISE EXCEPTION 'No hay suficiente stock para este producto';
    ELSE
        UPDATE Productos 
        SET stock = stock - NEW.cantidad 
        WHERE id_producto = NEW.id_producto;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tg_actualizar_stock
AFTER INSERT ON Ventas
FOR EACH ROW
EXECUTE FUNCTION actualizar_stock_producto();

5. Índices y Triggers

    Índice en Tarjetas para mejorar la búsqueda:

    sql

CREATE INDEX idx_tarjetas_numero ON Tarjetas(numero_tarjeta);

Trigger para actualizar stock:

sql

    CREATE OR REPLACE FUNCTION actualizar_stock_maletin() RETURNS TRIGGER AS $$
    BEGIN
        IF NEW.cantidad > (SELECT stock FROM Productos WHERE id_producto = NEW.id_producto) THEN
            RAISE EXCEPTION 'No hay suficiente stock';
        ELSE
            UPDATE Productos SET stock = stock - NEW.cantidad WHERE id_producto = NEW.id_producto;
        END IF;
        RETURN NEW;
    END;
    $$ LANGUAGE plpgsql;

    CREATE TRIGGER tg_actualizar_stock
    AFTER INSERT ON Productos_Maletin
    FOR EACH ROW EXECUTE FUNCTION actualizar_stock_maletin();
	
    Reporte de Ventas por Zona:

    sql

    CREATE VIEW VW_Ventas_Por_Zona AS
    SELECT Z.nombre_zona, SUM(T.total_gs) AS total_ventas
    FROM Zonas Z
    JOIN Rutas R ON Z.id_zona = R.id_zona
    JOIN Tarjetas T ON R.id_ruta = T.id_ruta
    GROUP BY Z.nombre_zona;
	
Es importante agregar índices para optimizar las búsquedas por cédula y RUC:

sql

CREATE INDEX idx_cedulas_numero ON Cedulas(numero_cedula);
CREATE INDEX idx_ruc_numero ON RUC(numero_ruc);
CREATE INDEX idx_antecedentes_numero ON Antecedentes_Judiciales(numero_cedula);

Triggers y Funciones para Actualizar Saldos y Stocks
a. Trigger para Actualizar el Saldo de la Tarjeta después de un Pago

Este trigger actualiza el saldo de la tarjeta automáticamente cuando el cliente realiza un pago.

sql

CREATE OR REPLACE FUNCTION actualizar_saldo_tarjeta() RETURNS TRIGGER AS $$
BEGIN
    UPDATE Tarjetas 
    SET saldo = saldo - NEW.monto
    WHERE id_tarjeta = NEW.id_tarjeta;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tg_actualizar_saldo
AFTER INSERT ON Pagos
FOR EACH ROW
EXECUTE FUNCTION actualizar_saldo_tarjeta();

b. Trigger para Actualizar el Inventario de Productos después de una Venta

Este trigger controla el stock de los productos cada vez que se realiza una venta.

sql

CREATE OR REPLACE FUNCTION actualizar_inventario_producto() RETURNS TRIGGER AS $$
BEGIN
    IF NEW.cantidad > (SELECT stock FROM Productos WHERE id_producto = NEW.id_producto) THEN
        RAISE EXCEPTION 'No hay suficiente stock para este producto';
    ELSE
        UPDATE Productos 
        SET stock = stock - NEW.cantidad 
        WHERE id_producto = NEW.id_producto;
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tg_actualizar_inventario
AFTER INSERT ON Productos_Vendidos
FOR EACH ROW
EXECUTE FUNCTION actualizar_inventario_producto(); 

Función para Calcular el Interés Moratorio

Crearemos una función que calcule el interés moratorio si el pago está atrasado:

sql

CREATE OR REPLACE FUNCTION calcular_interes_moratorio() RETURNS TRIGGER AS $$
DECLARE
    dias_atraso INT;
    interes INTEGER;
BEGIN
    -- Calcular los días de atraso
    SELECT EXTRACT(DAY FROM (NEW.fecha_pago - T.fecha_emision)) INTO dias_atraso
    FROM Tarjetas T
    WHERE T.id_tarjeta = NEW.id_tarjeta;

    -- Si el pago está en mora (más de 30 días)
    IF dias_atraso > 30 THEN
        -- Calcular el interés moratorio: 5% mensual (aproximadamente 0.1667% diario)
        interes := (T.saldo * 0.05 / 30) * dias_atraso;
        NEW.interes_moratorio := interes;
    ELSE
        NEW.interes_moratorio := 0;  -- No hay interés moratorio
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

Trigger para Aplicar el Interés Moratorio

El siguiente trigger aplicará automáticamente el interés moratorio al insertar un nuevo pago:

sql

CREATE TRIGGER tg_calcular_interes_moratorio
BEFORE INSERT ON Pagos
FOR EACH ROW
EXECUTE FUNCTION calcular_interes_moratorio();	

-- Configuración temporal para mejorar rendimiento
SET maintenance_work_mem = '1GB';
SET work_mem = '100MB';

-- Desactivar índices y triggers
ALTER TABLE nombre_tabla DISABLE TRIGGER ALL;
DROP INDEX IF EXISTS idx_nombre_tabla;

-- Importación de archivos
\COPY nombre_tabla(numero_cedula, nombre, apellido, fecha_nacimiento, sexo, direccion, id_distrito, id_dpto, zona) 
FROM 'D:/PADRONES/csvs/cedulas/padrón 2017 anr_w1252.csv' 
WITH (FORMAT csv, ENCODING 'LATIN1', NULL '', HEADER);

\COPY nombre_tabla(numero_cedula, nombre, apellido, fecha_nacimiento, sexo, direccion, id_distrito, id_dpto) 
FROM 'D:/PADRONES/csvs/cedulas/padrón 2021 anr_w1252.csv' 
WITH (FORMAT csv, ENCODING 'LATIN1', NULL '', HEADER);

\COPY nombre_tabla(numero_cedula, nombre, apellido, direccion, id_dpto, id_distrito, zona) 
FROM 'D:/PADRONES/csvs/cedulas/padrón_UNACE_w1252.csv' 
WITH (FORMAT csv, ENCODING 'LATIN1', NULL '', HEADER);

\COPY nombre_tabla(numero_cedula, nombre, apellido, fecha_nacimiento, sexo, direccion) 
FROM 'D:/PADRONES/csvs/cedulas/poli01_w1252.csv' 
WITH (FORMAT csv, ENCODING 'LATIN1', NULL '', HEADER);

\COPY nombre_tabla(numero_cedula, nombre, apellido, fecha_nacimiento, sexo, direccion, barrio, ciudad, pais) 
FROM 'D:/PADRONES/csvs/cedulas/regcivext_2015_w1252.csv' 
WITH (FORMAT csv, ENCODING 'LATIN1', NULL '', HEADER);

-- Reactivar índices y triggers después de la importación
CREATE INDEX idx_nombre_tabla ON nombre_tabla(numero_cedula);
ALTER TABLE nombre_tabla ENABLE TRIGGER ALL;

-- Configuración temporal para mejorar rendimiento
SET maintenance_work_mem = '1GB';
SET work_mem = '100MB';

-- Desactivar índices y triggers
ALTER TABLE gf.cedulas DISABLE TRIGGER ALL;
DROP INDEX IF EXISTS idx_gf.cedulas;

-- Importación de archivos
COPY gf.cedulas(numero_cedula, nombre, apellido, fecha_nacimiento, sexo, direccion, id_distrito, id_dpto, zona) 
FROM 'D:/PADRONES/csvs/cedulas/padrón 2017 anr_w1252.csv' 
WITH (FORMAT csv, ENCODING 'LATIN1', NULL '', HEADER);

COPY gf.cedulas(numero_cedula, nombre, apellido, fecha_nacimiento, sexo, direccion, id_distrito, id_dpto) 
FROM 'D:/PADRONES/csvs/cedulas/padrón 2021 anr_w1252.csv' 
WITH (FORMAT csv, ENCODING 'LATIN1', NULL '', HEADER);

COPY gf.cedulas(numero_cedula, nombre, apellido, direccion, id_dpto, id_distrito, zona) 
FROM 'D:/PADRONES/csvs/cedulas/padrón_UNACE_w1252.csv' 
WITH (FORMAT csv, ENCODING 'LATIN1', NULL '', HEADER);

COPY nombre_tabla(numero_cedula, nombre, apellido, fecha_nacimiento, sexo, direccion) 
FROM 'D:/PADRONES/csvs/cedulas/poli01_w1252.csv' 
WITH (FORMAT csv, ENCODING 'LATIN1', NULL '', HEADER);

COPY gf.cedulas(numero_cedula, nombre, apellido, fecha_nacimiento, sexo, direccion, barrio, ciudad, pais) 
FROM 'D:/PADRONES/csvs/cedulas/regcivext_2015_w1252.csv' 
WITH (FORMAT csv, ENCODING 'LATIN1', NULL '', HEADER);

-- Reactivar índices y triggers después de la importación
CREATE INDEX idx_gf.cedulas ON gf.cedulas(numero_cedula);
ALTER TABLE gf.cedulas ENABLE TRIGGER ALL;

-- Configuración temporal para mejorar rendimiento
SET maintenance_work_mem = '1GB';
SET work_mem = '100MB';

-- Desactivar índices y triggers
ALTER TABLE gf.cedulas DISABLE TRIGGER ALL;
DROP INDEX IF EXISTS idx_gf_cedulas;

-- Importación de archivos
COPY gf.cedulas(numero_cedula, nombre, apellido, fecha_nacimiento, sexo, direccion, id_distrito, id_dpto, zona) 
FROM 'D:/PADRONES/csvs/cedulas/padrón 2017 anr_w1252.csv' 
WITH (FORMAT csv, ENCODING 'LATIN1', NULL '', HEADER);
COMMIT;

COPY gf.cedulas(numero_cedula, nombre, apellido, fecha_nacimiento, sexo, direccion, id_distrito, id_dpto) 
FROM 'D:/PADRONES/csvs/cedulas/padrón 2021 anr_w1252.csv' 
WITH (FORMAT csv, ENCODING 'LATIN1', NULL '', HEADER);
COMMIT;

COPY gf.cedulas(numero_cedula, nombre, apellido, direccion, id_dpto, id_distrito, zona) 
FROM 'D:/PADRONES/csvs/cedulas/padrón_UNACE_w1252.csv' 
WITH (FORMAT csv, ENCODING 'LATIN1', NULL '', HEADER);
COMMIT;

COPY gf.cedulas(numero_cedula, nombre, apellido, fecha_nacimiento, sexo, direccion) 
FROM 'D:/PADRONES/csvs/cedulas/poli01_w1252.csv' 
WITH (FORMAT csv, ENCODING 'LATIN1', NULL '', HEADER);
COMMIT;

COPY gf.cedulas(numero_cedula, nombre, apellido, fecha_nacimiento, sexo, direccion, barrio, ciudad, pais) 
FROM 'D:/PADRONES/csvs/cedulas/regcivext_2015_w1252.csv' 
WITH (FORMAT csv, ENCODING 'LATIN1', NULL '', HEADER);
COMMIT;

-- Reactivar índices y triggers después de la importación
CREATE INDEX 'idx_gf_cedulas' ON gf.cedulas(numero_cedula);
ALTER TABLE gf.cedulas ENABLE TRIGGER ALL;

SET search_path TO gf;
-- Asegúrate de ajustar la configuración temporal y desactivar índices y triggers antes de la importación
SET datestyle TO 'MDY';
-- Importación de archivos
\copy gf.cedulas(numero_cedula, nombre, apellido, fecha_nacimiento, sexo, direccion, id_distrito, id_dpto, zona)  FROM 'D:\PADRONES\csvs\cedulas\padron 2017 anr_w1252.csv' WITH (FORMAT csv, ENCODING 'LATIN1', NULL '', HEADER);
COMMIT;

\copy gf.cedulas(numero_cedula, nombre, apellido, fecha_nacimiento, sexo, direccion, id_distrito, id_dpto) FROM 'D:\PADRONES\csvs\cedulas\padron 2021 anr_w1252.csv' WITH (FORMAT csv, ENCODING 'LATIN1', NULL '', HEADER);
COMMIT;

\copy gf.cedulas(numero_cedula, nombre, apellido, direccion, id_dpto, id_distrito, zona) FROM 'D:\PADRONES\csvs\cedulas\padron_UNACE_w1252.csv' WITH (FORMAT csv, ENCODING 'LATIN1', NULL '', HEADER);
COMMIT;

\copy gf.cedulas(numero_cedula, nombre, apellido, fecha_nacimiento, sexo, direccion) FROM 'D:\PADRONES\csvs\cedulas\poli01_w1252.csv' WITH (FORMAT csv, ENCODING 'LATIN1', NULL '', HEADER);
COMMIT;

\copy gf.cedulas(numero_cedula, nombre, apellido, fecha_nacimiento, sexo, direccion, barrio, ciudad, pais) FROM 'D:\PADRONES\csvs\cedulas\regcivext_2015_w1252.csv' WITH (FORMAT csv, ENCODING 'LATIN1', NULL '', HEADER);
COMMIT;

\copy gf.cedulas(numero_cedula, nombre, apellido, fecha_nacimiento, sexo, direccion, barrio, ciudad, pais) FROM 'D:\PADRONES\csvs\cedulas\regcivext_2020_w1252.csv' WITH (FORMAT csv, ENCODING 'LATIN1', NULL '', HEADER);
COMMIT;

\copy gf.cedulas(numero_cedula, nombre, apellido, fecha_nacimiento, sexo, direccion, barrio, ciudad, pais) FROM 'D:\PADRONES\csvs\cedulas\regcivext_2021_w1252.csv' WITH (FORMAT csv, ENCODING 'LATIN1', NULL '', HEADER);
COMMIT;

\copy gf.cedulas(numero_cedula, nombre, apellido, fecha_nacimiento, sexo, direccion, barrio, ciudad, pais) FROM 'D:\PADRONES\csvs\cedulas\regciv_2010_w1252.csv' WITH (FORMAT csv, ENCODING 'LATIN1', NULL '', HEADER);
COMMIT;

\copy gf.cedulas(numero_cedula, nombre, apellido, fecha_nacimiento, sexo, direccion, barrio, ciudad, pais) FROM 'D:\PADRONES\csvs\cedulas\regciv_2013_w1252.csv' WITH (FORMAT csv, ENCODING 'LATIN1', NULL '', HEADER);
COMMIT;

\copy gf.cedulas(numero_cedula, nombre, apellido, fecha_nacimiento, sexo, direccion, barrio, ciudad, pais) FROM 'D:\PADRONES\csvs\cedulas\regciv_2015_w1252.csv' WITH (FORMAT csv, ENCODING 'LATIN1', NULL '', HEADER);
COMMIT;

\copy gf.cedulas(numero_cedula, nombre, apellido, fecha_nacimiento, sexo, direccion, barrio, ciudad, pais) FROM 'D:\PADRONES\csvs\cedulas\regciv_2018_w1252.csv' WITH (FORMAT csv, ENCODING 'LATIN1', NULL '', HEADER);
COMMIT;

\copy gf.cedulas(numero_cedula, nombre, apellido, fecha_nacimiento, sexo, direccion, barrio, ciudad, pais) FROM 'D:\PADRONES\csvs\cedulas\regciv_2020_w1252.csv' WITH (FORMAT csv, ENCODING 'LATIN1', NULL '', HEADER);
COMMIT;

\copy gf.cedulas(numero_cedula, nombre, apellido, fecha_nacimiento, sexo, direccion, barrio, ciudad, pais) FROM 'D:\PADRONES\csvs\cedulas\regciv_2021_w1252.csv' WITH (FORMAT csv, ENCODING 'LATIN1', NULL '', HEADER);
COMMIT;

\copy gf.cedulas(numero_cedula, nombre, apellido, fecha_nacimiento, sexo, direccion, barrio, ciudad, pais) FROM 'D:\PADRONES\csvs\cedulas\regciv_UNACE_w1252.csv' WITH (FORMAT csv, ENCODING 'LATIN1', NULL '', HEADER);
COMMIT;

-- Reactiva los índices y triggers después de la importación