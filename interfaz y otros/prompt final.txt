estoy en la parálisis por análisis. tengo varios modelos para la base postgresql pero quedo sin acción porque a la lógica del negocio se le suma la gran cantidad de datos que quiero tener de antemano

--Creación de la Base de Datos
CREATE DATABASE Gabriela_Fragancias;
--Tabla Empresa
CREATE TABLE Empresa (
    id_empresa SERIAL PRIMARY KEY,
    ruc VARCHAR(20) UNIQUE NOT NULL,
    razon_social VARCHAR(100) NOT NULL
);

-- Tabla Usuario
CREATE TABLE Usuario (
    id_usuario SERIAL PRIMARY KEY,
    nombre_usuario VARCHAR(100) NOT NULL,
    contrasena VARCHAR(100) NOT NULL,
    rol VARCHAR(50) NOT NULL
);

--Tabla RUC
CREATE TABLE RUC (
    id_ruc SERIAL PRIMARY KEY,
    numero_ruc VARCHAR(20) UNIQUE NOT NULL,
    digito_verificador INT NOT NULL,
	razon_social VARCHAR(255),
    direccion VARCHAR(255),
    telefono VARCHAR(20),
    tipo VARCHAR(20),  -- Tipo de entidad: 'Persona', 'Empresa'
    fuente VARCHAR(50)  -- 'ruc.dbf', 'ruc.txt'
);

--Tabla Antecedentes Judiciales
CREATE TABLE Antecedentes_Judiciales (
    id_antecedente SERIAL PRIMARY KEY,
    numero_cedula VARCHAR(20) REFERENCES Cedulas(numero_cedula),
    causa_penal TEXT,  -- Descripción de la causa penal
    fecha_causa DATE,
    unidad_procesadora VARCHAR(100),
    juez VARCHAR(100),
    estado_proceso VARCHAR(50),
    fuente VARCHAR(50)  -- 'capt01.dbf'
);

--Tabla Datos Personales
CREATE TABLE Personas_Cedulas (
    id_persona SERIAL PRIMARY KEY,
    numero_cedula VARCHAR(20) UNIQUE NOT NULL,
    nombre VARCHAR(100) NOT NULL,
    apellido VARCHAR(100) NOT NULL,
    sexo CHAR(1),  -- M: Masculino, F: Femenino
    fecha_nacimiento DATE,
    lugar_nacimiento VARCHAR(100),
    telefono VARCHAR(20),
    direccion TEXT,
    email VARCHAR(100),
    id_ruc INTEGER REFERENCES RUC(id_ruc),  -- Referencia a la tabla RUC
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

--Tabla Clientes
CREATE TABLE Clientes (
    id_cliente SERIAL PRIMARY KEY,
    id_persona INTEGER REFERENCES Personas(id_persona),  -- Relación con la tabla Personas
    tarjeta VARCHAR(7) UNIQUE NOT NULL,  -- Número de tarjeta obligatorio y único
    saldo DECIMAL(10, 2) DEFAULT 0,
    tipo_pago VARCHAR(20) CHECK (tipo_pago IN ('SEM', 'QUIN', 'MENS')),  -- Tipo de pago con restricciones
    fecha_registro DATE DEFAULT CURRENT_DATE,  -- Fecha de registro, sin duplicación
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,  -- Fecha de creación
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP  -- Fecha de actualización
);

-- Tabla Marcas
CREATE TABLE Marcas (
    id_marca SERIAL PRIMARY KEY,
    nombre VARCHAR(100) UNIQUE NOT NULL,
    año_fundacion INT
);

-- Tabla Productos
CREATE TABLE Productos (
    id_producto SERIAL PRIMARY KEY,
    codigo_barras VARCHAR(50) UNIQUE NOT NULL,
    nombre VARCHAR(100) NOT NULL,
    id_marca INTEGER REFERENCES Marcas(id_marca),
    precio_contado DECIMAL(10, 2) NOT NULL,
    precio_credito DECIMAL(10, 2) NOT NULL,
    stock INTEGER NOT NULL,
    descripcion TEXT,
    presentacion VARCHAR(50),
    volumen INT CHECK (volumen BETWEEN 5 AND 200),
    es_kit BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

--Tabla Vendedores
CREATE TABLE Vendedores (
    id_vendedor SERIAL PRIMARY KEY,
    nombre VARCHAR(100) NOT NULL,
    zona VARCHAR(50) NOT NULL,
    comision DECIMAL(10, 2) DEFAULT 50000
);

--Tabla Tarjetas
CREATE TABLE Tarjetas (
    id_tarjeta SERIAL PRIMARY KEY,
    numero_tarjeta VARCHAR(7) NOT NULL,
    id_cliente INTEGER REFERENCES Clientes(id_cliente),
    id_vendedor INTEGER REFERENCES Vendedores(id_vendedor),
    id_zona INTEGER REFERENCES Zonas(id_zona),
    total_gs DECIMAL(10, 2) NOT NULL,
    saldo DECIMAL(10, 2) DEFAULT 0,
    forma_pago VARCHAR(20) CHECK (forma_pago IN ('SEM', 'QUIN', 'MENS')),
    estado VARCHAR(20) CHECK (estado IN ('activa', 'cancelada')) DEFAULT 'activa',
    fecha_emision DATE DEFAULT CURRENT_DATE,
    id_tarjeta_anterior INTEGER REFERENCES Tarjetas(id_tarjeta)
);

--Tabla de Productos
CREATE TABLE Productos (
    id_producto SERIAL PRIMARY KEY,
    nombre VARCHAR(100) NOT NULL,
    codigo_barras VARCHAR(13) UNIQUE NOT NULL,
    precio_costo DECIMAL(10, 2),
    precio_venta DECIMAL(10, 2),
    stock INTEGER DEFAULT 0,
    descripcion TEXT
);

--Tabla Productos Vendidos
CREATE TABLE Productos_Vendidos (
    id_producto_vendido SERIAL PRIMARY KEY,
    id_tarjeta INTEGER REFERENCES Tarjetas(id_tarjeta),
    id_producto INTEGER REFERENCES Productos(id_producto),
    cantidad INTEGER CHECK (cantidad > 0),
    precio DECIMAL(10, 2)
);

--Tabla Pagos
CREATE TABLE Pagos (
    id_pago SERIAL PRIMARY KEY,
    id_tarjeta INTEGER REFERENCES Tarjetas(id_tarjeta),
    fecha_pago DATE DEFAULT CURRENT_DATE,
    monto DECIMAL(10, 2) NOT NULL,
    saldo_restante DECIMAL(10, 2) NOT NULL,
    entrega_inicial BOOLEAN DEFAULT FALSE,
    recargo BOOLEAN DEFAULT FALSE
);

--Tabla de Maletines
CREATE TABLE Maletines (
    id_maletin SERIAL PRIMARY KEY,
    id_vendedor INT REFERENCES Vendedores(id_vendedor),
    fecha_carga DATE DEFAULT CURRENT_DATE
);

--Tabla de Productos en Maletines: Vincula productos con maletines, especificando la cantidad de productos asignados.
CREATE TABLE Productos_Maletin (
	id_maletin INT REFERENCES Maletines(id_maletin),
	id_producto INT REFERENCES Productos(id_producto),
	cantidad INT NOT NULL,
	PRIMARY KEY (id_maletin, id_producto)
);

--Tabla de Liquidaciones
CREATE TABLE Liquidaciones (
	id_liquidacion SERIAL PRIMARY KEY,
	id_empleado INT REFERENCES Empleados(id_empleado),
	fecha_liquidacion DATE DEFAULT CURRENT_DATE,
	total_ventas DECIMAL(10, 2),
	comision DECIMAL(10, 2),
	total_pagar DECIMAL(10, 2)
);

--Tabla de Inventario (Maletines de Productos)
CREATE TABLE Inventario (
    id_inventario SERIAL PRIMARY KEY,
    id_vendedor INTEGER REFERENCES Vendedores(id_vendedor),
    id_producto INTEGER REFERENCES Productos(id_producto),
    cantidad INTEGER NOT NULL
);

--Tabla de Vehículos
CREATE TABLE Vehiculos (
    id_vehiculo SERIAL PRIMARY KEY,
    placa VARCHAR(20) UNIQUE NOT NULL,
    marca VARCHAR(50),
    modelo VARCHAR(50),
	año INT,
    numero_motor VARCHAR(50) UNIQUE,
	numero_chasis VARCHAR(50) UNIQUE,
	km_recorridos DECIMAL(10, 2)	
    fecha_revision DATE
);

--Tabla de Rutas
CREATE TABLE Rutas (
    id_ruta SERIAL PRIMARY KEY,
    id_vendedor INTEGER REFERENCES Vendedores(id_vendedor),
    id_zona INTEGER REFERENCES Zonas(id_zona),
    fecha DATE DEFAULT CURRENT_DATE,
    coordenadas GEOGRAPHY(POINT, 4326)  -- Integración con GIS
);

--Tabla Zonas
CREATE TABLE Zonas (
    id_zona SERIAL PRIMARY KEY,
	geom GEOGRAPHY(POLYGON, 4326);
    nombre_zona VARCHAR(100) NOT NULL UNIQUE
);

--Triggers y Funciones

--Actualizar saldo del cliente
CREATE OR REPLACE FUNCTION actualizar_saldo_cliente() 
RETURNS TRIGGER AS $$
BEGIN
    UPDATE Tarjetas 
    SET saldo = saldo - NEW.monto
    WHERE id_tarjeta = NEW.id_tarjeta;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

--Trigger para actualizar saldo tras un pago:
CREATE TRIGGER tg_actualizar_saldo
AFTER INSERT ON Pagos
FOR EACH ROW
EXECUTE FUNCTION actualizar_saldo_cliente();

--Función para actualizar inventario tras una venta:
CREATE OR REPLACE FUNCTION actualizar_inventario() 
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.cantidad > (SELECT stock FROM Productos WHERE id_producto = NEW.id_producto) THEN
        RAISE EXCEPTION 'No hay suficiente stock para este producto';
    ELSE
        UPDATE Productos 
        SET stock = stock - NEW.cantidad 
        WHERE id_producto = NEW.id_producto;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

--Trigger para actualizar inventario tras una venta:
CREATE TRIGGER tg_actualizar_inventario
AFTER INSERT ON Productos_Vendidos
FOR EACH ROW
EXECUTE FUNCTION actualizar_inventario();

CREATE OR REPLACE FUNCTION actualizar_stock_maletin() RETURNS TRIGGER AS $$
BEGIN
    IF NEW.cantidad > (SELECT stock FROM Productos WHERE id_producto = NEW.id_producto) THEN
        RAISE EXCEPTION 'No hay suficiente stock';
    ELSE
        UPDATE Productos SET stock = stock - NEW.cantidad WHERE id_producto = NEW.id_producto;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

--Trigger para Actualizar Stock,
CREATE TRIGGER tg_actualizar_stock
AFTER INSERT ON Productos_Maletin
FOR EACH ROW EXECUTE FUNCTION actualizar_stock_maletin();

CREATE OR REPLACE FUNCTION actualizar_stock_producto() RETURNS TRIGGER AS $$
BEGIN
    IF (NEW.cantidad > (SELECT stock FROM Productos WHERE id_producto = NEW.id_producto)) THEN
        RAISE EXCEPTION 'No hay suficiente stock para este producto';
    ELSE
        UPDATE Productos 
        SET stock = stock - NEW.cantidad 
        WHERE id_producto = NEW.id_producto;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tg_actualizar_stock
AFTER INSERT ON DetalleVenta
FOR EACH ROW
EXECUTE FUNCTION actualizar_stock_producto();

--Trigger para Control de Stock en Maletines: Disminuye el stock de productos cuando se asignan a un maletín.

CREATE OR REPLACE FUNCTION actualizar_stock_maletin() RETURNS TRIGGER AS $$
BEGIN
    IF (NEW.cantidad > (SELECT stock FROM Productos WHERE id_producto = NEW.id_producto)) THEN
        RAISE EXCEPTION 'No hay suficiente stock para el producto %', NEW.id_producto;
    ELSE
        UPDATE Productos 
        SET stock = stock - NEW.cantidad 
        WHERE id_producto = NEW.id_producto;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tg_actualizar_stock_maletin
AFTER INSERT ON Productos_Maletin
FOR EACH ROW
EXECUTE FUNCTION actualizar_stock_maletin();

--Trigger para Actualizar Liquidación por Venta: Calcula la liquidación de la vendedora al final del día.

CREATE OR REPLACE FUNCTION calcular_liquidacion() RETURNS TRIGGER AS $$
BEGIN
	NEW.total_pagar := NEW.total_ventas * 50000;
	RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tg_calcular_liquidacion
BEFORE INSERT ON Liquidaciones
FOR EACH ROW
EXECUTE FUNCTION calcular_liquidacion();

--Trigger de antecedentes judiciales: Verificar si un cliente tiene antecedentes antes de ser registrado.

CREATE OR REPLACE FUNCTION verificar_antecedentes_judiciales() RETURNS TRIGGER AS $$
BEGIN
	IF EXISTS (SELECT 1 FROM AntecedentesJudiciales WHERE numero_ci = NEW.cedula) THEN
		RAISE NOTICE 'El cliente con cédula % tiene antecedentes judiciales', NEW.cedula;
	END IF;
	RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tg_verificar_antecedentes_judiciales
BEFORE INSERT ON Clientes
FOR EACH ROW
EXECUTE FUNCTION verificar_antecedentes_judiciales();

--Vista para Reportes de Ventas
CREATE VIEW VW_Ventas_Por_Cliente AS
SELECT 
    c.id_cliente, 
    c.nombre, 
    c.apellido, 
    COUNT(v.id_tarjeta) AS total_ventas, 
    SUM(v.total_gs) AS monto_total
FROM 
    Clientes c
JOIN 
    Tarjetas v ON c.id_cliente = v.id_cliente
GROUP BY 
    c.id_cliente;

CREATE VIEW VW_Ventas_Por_Zona AS
SELECT Z.nombre_zona, SUM(T.total_gs) AS total_ventas
FROM Zonas Z
JOIN Rutas R ON Z.id_zona = R.id_zona
JOIN Tarjetas T ON R.id_ruta = T.id_ruta
GROUP BY Z.nombre_zona;

--Optimización con Índices
CREATE INDEX idx_tarjetas_cliente ON Tarjetas(id_cliente);
CREATE INDEX idx_productos_codigo_barras ON Productos(codigo_barras);
CREATE INDEX idx_pagos_fecha ON Pagos(fecha_pago);
CREATE INDEX idx_rutas_vendedor_fecha ON Rutas(id_vendedor, fecha);
CREATE INDEX idx_pagos_cliente_metodo ON Pagos(id_cliente, metodo_pago);
CREATE INDEX idx_antecedentes_cedula ON AntecedentesJudiciales(cedula);
CREATE INDEX idx_inventario_maletines_producto ON Inventario_Maletines(id_maletin, id_producto);
CREATE INDEX idx_vehiculos_motor_chasis_placa ON Vehiculos(numero_motor, numero_chasis, placa);
CREATE INDEX idx_tarjetas_numero ON Tarjetas(numero_tarjeta);
CREATE INDEX idx_maletin_empleado ON Maletines(id_empleado);
CREATE INDEX idx_liquidacion_empleado ON Liquidaciones(id_empleado);


--15. Insertar Datos Ejemplares

-- Insertar un cliente
INSERT INTO Clientes (cedula, nombre, apellido, telefono, direccion, email)
VALUES ('1234567890', 'Juan', 'Pérez', '0981123456', 'Av. Siempre Viva', 'juan.perez@email.com');

-- Insertar una tarjeta para ese cliente
INSERT INTO Tarjetas (numero_tarjeta, id_cliente, id_vendedor, id_zona, total_gs, saldo, forma_pago)
VALUES ('0012345', 1, 1, 1, 150000, 150000, 'SEM');

-- Insertar un pago para la tarjeta
INSERT INTO Pagos (id_tarjeta, fecha_pago, monto, saldo_restante, entrega_inicial)
VALUES (1, '2024-10-01', 50000, 100000, TRUE);



4. Reportes Pendientes

    Reporte de Ganancias por Día: Resumen de ganancias diarias.
    Reporte de Pagos Realizados por Clientes: Incluye los pagos parciales y totales de los clientes.
    Reporte de Análisis de Ventas por Fecha: Un desglose de las ventas según períodos específicos.
    Reporte de Cuentas a Vencer de Proveedores: Para controlar las facturas pendientes de pago a proveedores.
    Reporte de Inventario por Marca: Para conocer el inventario desglosado por marca de productos​
	
Gabriela Fragancias, incluyendo la consulta para obtener el perfume más vendido.
1. Creación de tablas

sql

-- Tabla Clientes
CREATE TABLE clientes (
    id_cliente SERIAL PRIMARY KEY,
    nombre VARCHAR(100) NOT NULL,
    apellido VARCHAR(100) NOT NULL,
    cedula VARCHAR(20) UNIQUE NOT NULL,
    direccion TEXT NOT NULL,
    telefono VARCHAR(20),
    zona VARCHAR(50) NOT NULL,
    fecha_registro DATE DEFAULT CURRENT_DATE
);

-- Tabla Productos
CREATE TABLE productos (
    id_producto SERIAL PRIMARY KEY,
    nombre VARCHAR(100) NOT NULL,
    precio NUMERIC(10,2) NOT NULL,
    categoria VARCHAR(50),
    codigo_barras VARCHAR(13) UNIQUE
);

-- Tabla Vendedores
CREATE TABLE vendedores (
    id_vendedor SERIAL PRIMARY KEY,
    nombre VARCHAR(100) NOT NULL,
    apellido VARCHAR(100) NOT NULL,
    comision NUMERIC(10,2) DEFAULT 50000
);

-- Tabla Ventas
CREATE TABLE ventas (
    id_venta SERIAL PRIMARY KEY,
    fecha DATE DEFAULT CURRENT_DATE,
    total NUMERIC(10,2) NOT NULL,
    id_cliente INTEGER REFERENCES clientes(id_cliente),
    id_vendedor INTEGER REFERENCES vendedores(id_vendedor)
);

-- Tabla Detalle de Ventas
CREATE TABLE ventas_detalle (
    id_venta_detalle SERIAL PRIMARY KEY,
    cantidad INTEGER NOT NULL,
    id_venta INTEGER REFERENCES ventas(id_venta),
    id_producto INTEGER REFERENCES productos(id_producto)
);

-- Índices para optimización
CREATE INDEX idx_clientes_cedula ON clientes(cedula);
CREATE INDEX idx_ventas_fecha ON ventas(fecha);
CREATE INDEX idx_productos_codigo_barras ON productos(codigo_barras);

2. Funciones y Triggers
a) Perfume más vendido

sql

-- Función para obtener el perfume más vendido en un rango de fechas
CREATE OR REPLACE FUNCTION perfume_mas_vendido(fecha_inicio DATE, fecha_fin DATE)
RETURNS TABLE (perfume VARCHAR, total_vendido NUMERIC) AS $$
BEGIN
  RETURN QUERY
  SELECT p.nombre, SUM(vd.cantidad) AS total_vendido
  FROM ventas v
  INNER JOIN ventas_detalle vd ON v.id_venta = vd.id_venta
  INNER JOIN productos p ON vd.id_producto = p.id_producto
  WHERE v.fecha BETWEEN fecha_inicio AND fecha_fin
  GROUP BY p.nombre
  ORDER BY total_vendido DESC
  LIMIT 1;
END;
$$ LANGUAGE plpgsql;

b) Top perfumes por año

sql

-- Función para obtener los top N perfumes más vendidos por año
CREATE OR REPLACE FUNCTION top_perfumes_por_ano(ano INTEGER, n INTEGER)
RETURNS TABLE (perfume VARCHAR, total_vendido NUMERIC) AS $$
BEGIN
  RETURN QUERY
  SELECT p.nombre, SUM(vd.cantidad) AS total_vendido
  FROM ventas v
  INNER JOIN ventas_detalle vd ON v.id_venta = vd.id_venta
  INNER JOIN productos p ON vd.id_producto = p.id_producto
  WHERE EXTRACT(YEAR FROM v.fecha) = ano
  GROUP BY p.nombre
  ORDER BY total_vendido DESC
  LIMIT n;
END;
$$ LANGUAGE plpgsql;

c) Trigger para actualizar el saldo del cliente después de una venta

sql

-- Trigger para actualizar el saldo del cliente tras una venta
CREATE OR REPLACE FUNCTION actualizar_saldo_cliente()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE clientes 
    SET saldo = saldo - NEW.total
    WHERE id_cliente = NEW.id_cliente;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tg_actualizar_saldo
AFTER INSERT ON ventas
FOR EACH ROW
EXECUTE FUNCTION actualizar_saldo_cliente();

3. Consultas de ejemplo
a) Obtener el perfume más vendido en un rango de fechas

sql

SELECT * FROM perfume_mas_vendido('2023-01-01', '2023-12-31');

b) Obtener los 3 perfumes más vendidos en un año específico

sql

SELECT * FROM top_perfumes_por_ano(2023, 3);

Con este esquema, puedes gestionar clientes, productos, ventas y vendedores de manera eficiente, además de obtener información detallada sobre las ventas y el rendimiento de los productos.

Si necesitas personalizar alguna parte del código o agregar más funcionalidades, no dudes en indicármelo. ¡Estás listo para comenzar!
Tú dijiste:
presenta todo el código sql, eliminando redundancias y atendiendo bien la estructura y relaciones
ChatGPT Plus
ChatGPT

Aquí te dejo el código SQL completo optimizado, eliminando redundancias y mejorando la estructura de relaciones. Esta base de datos incluye las tablas necesarias para gestionar clientes, productos, ventas, vendedores y relaciones clave, con triggers y funciones que optimizan las operaciones.
1. Creación de las tablas

sql

-- Tabla Clientes
CREATE TABLE clientes (
    id_cliente SERIAL PRIMARY KEY,
    nombre VARCHAR(100) NOT NULL,
    apellido VARCHAR(100) NOT NULL,
    cedula VARCHAR(20) UNIQUE NOT NULL,
    direccion TEXT NOT NULL,
    telefono VARCHAR(20),
    email VARCHAR(100) UNIQUE,
    zona VARCHAR(50) NOT NULL,
    fecha_registro DATE DEFAULT CURRENT_DATE
);

-- Tabla Productos
CREATE TABLE productos (
    id_producto SERIAL PRIMARY KEY,
    nombre VARCHAR(100) NOT NULL,
    precio NUMERIC(10,2) NOT NULL,
    categoria VARCHAR(50),
    codigo_barras VARCHAR(13) UNIQUE NOT NULL,
    stock INTEGER NOT NULL
);

-- Tabla Vendedores
CREATE TABLE vendedores (
    id_vendedor SERIAL PRIMARY KEY,
    nombre VARCHAR(100) NOT NULL,
    apellido VARCHAR(100) NOT NULL,
    comision NUMERIC(10,2) DEFAULT 50000
);

-- Tabla Ventas
CREATE TABLE ventas (
    id_venta SERIAL PRIMARY KEY,
    fecha DATE DEFAULT CURRENT_DATE,
    total NUMERIC(10,2) NOT NULL,
    id_cliente INTEGER REFERENCES clientes(id_cliente),
    id_vendedor INTEGER REFERENCES vendedores(id_vendedor)
);

-- Tabla Detalle de Ventas
CREATE TABLE ventas_detalle (
    id_venta_detalle SERIAL PRIMARY KEY,
    id_venta INTEGER REFERENCES ventas(id_venta) ON DELETE CASCADE,
    id_producto INTEGER REFERENCES productos(id_producto),
    cantidad INTEGER NOT NULL
);

-- Tabla de Inventario por Vendedor (relaciona productos con vendedores)
CREATE TABLE inventario_vendedores (
    id_inventario SERIAL PRIMARY KEY,
    id_vendedor INTEGER REFERENCES vendedores(id_vendedor) ON DELETE CASCADE,
    id_producto INTEGER REFERENCES productos(id_producto),
    cantidad INTEGER NOT NULL
);

-- Tabla Zonas para asociar vendedores a áreas específicas
CREATE TABLE zonas (
    id_zona SERIAL PRIMARY KEY,
    nombre_zona VARCHAR(100) NOT NULL,
    id_vendedor INTEGER REFERENCES vendedores(id_vendedor),
    UNIQUE(id_zona, id_vendedor)
);

-- Índices para optimización
CREATE INDEX idx_clientes_cedula ON clientes(cedula);
CREATE INDEX idx_productos_codigo_barras ON productos(codigo_barras);
CREATE INDEX idx_ventas_fecha ON ventas(fecha);
CREATE INDEX idx_inventario_producto ON inventario_vendedores(id_producto);

2. Funciones y Triggers
a) Perfume más vendido

sql

-- Función para obtener el perfume más vendido en un rango de fechas
CREATE OR REPLACE FUNCTION perfume_mas_vendido(fecha_inicio DATE, fecha_fin DATE)
RETURNS TABLE (perfume VARCHAR, total_vendido NUMERIC) AS $$
BEGIN
  RETURN QUERY
  SELECT p.nombre, SUM(vd.cantidad) AS total_vendido
  FROM ventas v
  INNER JOIN ventas_detalle vd ON v.id_venta = vd.id_venta
  INNER JOIN productos p ON vd.id_producto = p.id_producto
  WHERE v.fecha BETWEEN fecha_inicio AND fecha_fin
  GROUP BY p.nombre
  ORDER BY total_vendido DESC
  LIMIT 1;
END;
$$ LANGUAGE plpgsql;

b) Top perfumes por año

sql

-- Función para obtener los top N perfumes más vendidos por año
CREATE OR REPLACE FUNCTION top_perfumes_por_ano(ano INTEGER, n INTEGER)
RETURNS TABLE (perfume VARCHAR, total_vendido NUMERIC) AS $$
BEGIN
  RETURN QUERY
  SELECT p.nombre, SUM(vd.cantidad) AS total_vendido
  FROM ventas v
  INNER JOIN ventas_detalle vd ON v.id_venta = vd.id_venta
  INNER JOIN productos p ON vd.id_producto = p.id_producto
  WHERE EXTRACT(YEAR FROM v.fecha) = ano
  GROUP BY p.nombre
  ORDER BY total_vendido DESC
  LIMIT n;
END;
$$ LANGUAGE plpgsql;

c) Trigger para actualizar el stock después de una venta

sql

-- Trigger para actualizar el stock de productos tras una venta
CREATE OR REPLACE FUNCTION actualizar_stock_producto() 
RETURNS TRIGGER AS $$
BEGIN
    IF (NEW.cantidad > (SELECT stock FROM productos WHERE id_producto = NEW.id_producto)) THEN
        RAISE EXCEPTION 'No hay suficiente stock para el producto %', NEW.id_producto;
    ELSE
        UPDATE productos
        SET stock = stock - NEW.cantidad
        WHERE id_producto = NEW.id_producto;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tg_actualizar_stock
AFTER INSERT ON ventas_detalle
FOR EACH ROW
EXECUTE FUNCTION actualizar_stock_producto();

d) Trigger para actualizar el saldo del cliente tras una venta

sql

-- Trigger para actualizar el saldo del cliente tras una venta
CREATE OR REPLACE FUNCTION actualizar_saldo_cliente()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE clientes 
    SET saldo = saldo - NEW.total
    WHERE id_cliente = NEW.id_cliente;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tg_actualizar_saldo
AFTER INSERT ON ventas
FOR EACH ROW
EXECUTE FUNCTION actualizar_saldo_cliente();

3. Consultas de ejemplo
a) Obtener el perfume más vendido en un rango de fechas

sql

SELECT * FROM perfume_mas_vendido('2023-01-01', '2023-12-31');

b) Obtener los 3 perfumes más vendidos en un año específico

sql

SELECT * FROM top_perfumes_por_ano(2023, 3);

4. Relaciones entre tablas clave

    Relación entre clientes y ventas: Un cliente puede realizar muchas ventas, pero una venta solo puede estar asociada a un cliente.
    Relación entre productos y detalle de ventas: Cada producto puede estar en muchas ventas, y cada venta puede contener varios productos.
    Relación entre vendedores y ventas: Cada vendedor puede realizar muchas ventas.
    Relación entre productos y vendedores: Un vendedor puede tener muchos productos en su inventario, pero un producto puede pertenecer a varios vendedores.

5. Índices y optimización

    Índices para búsquedas rápidas: Los índices creados sobre cedula en la tabla clientes, código de barras en productos, y fechas en ventas aseguran que las consultas más comunes sean rápidas.
    Optimización de stock: El trigger para actualizar el stock tras una venta asegura que no se vendan más productos de los que hay en inventario.
    Seguridad e integridad: Las referencias entre tablas y las restricciones de claves ajenas mantienen la integridad de los datos, especialmente en ventas y detalles de ventas.

Este diseño proporciona una estructura sólida, elimina redundancias y facilita la gestión de clientes, productos y ventas en tu sistema. ¡Con esto ya puedes empezar la base de datos y ajustarla según las necesidades de Gabriela Fragancias!
Tú dijiste:
y las tablas, personas, cédulas, ruc, antecedentes judiciales, rutas, vehículos, maletines, ciudades, municipios, departamentos, gps
ChatGPT Plus
ChatGPT

¡Entendido! Vamos a incorporar las tablas adicionales que mencionas, como personas, cédulas, RUC, antecedentes judiciales, rutas, vehículos, maletines, ciudades, municipios, departamentos y GPS. Estas tablas se integrarán con las tablas ya definidas para mantener una estructura lógica y consistente.
1. Creación de Tablas Adicionales
a) Tabla Personas

sql

CREATE TABLE personas (
    id_persona SERIAL PRIMARY KEY,
    cedula VARCHAR(20) UNIQUE NOT NULL,
    nombre VARCHAR(100) NOT NULL,
    apellido VARCHAR(100) NOT NULL,
    fecha_nacimiento DATE NOT NULL,
    direccion TEXT NOT NULL,
    telefono VARCHAR(20),
    email VARCHAR(100) UNIQUE,
    zona VARCHAR(50),
    fecha_registro DATE DEFAULT CURRENT_DATE
);

b) Tabla Cédulas

sql

CREATE TABLE cedulas (
    numero_ci VARCHAR(20) PRIMARY KEY,
    nombre VARCHAR(100) NOT NULL,
    apellido VARCHAR(100) NOT NULL,
    fecha_nacimiento DATE NOT NULL,
    direccion TEXT NOT NULL
);

c) Tabla RUC

sql

CREATE TABLE ruc (
    id_ruc SERIAL PRIMARY KEY,
    numero_ruc VARCHAR(20) UNIQUE NOT NULL,
    digito_verificador INT NOT NULL,
    razon_social VARCHAR(100) NOT NULL
);

d) Tabla Antecedentes Judiciales

sql

CREATE TABLE antecedentes_judiciales (
    id_antecedente SERIAL PRIMARY KEY,
    numero_ci VARCHAR(20) REFERENCES cedulas(numero_ci),
    causa_penal TEXT NOT NULL
);

e) Tabla Vehículos

sql

CREATE TABLE vehiculos (
    id_vehiculo SERIAL PRIMARY KEY,
    placa VARCHAR(20) UNIQUE NOT NULL,
    marca VARCHAR(50),
    modelo VARCHAR(50),
    anio INT,
    chasis VARCHAR(50),
    motor VARCHAR(50),
    ultima_revision DATE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

f) Tabla Rutas (vendedores y geolocalización)

sql

CREATE TABLE rutas (
    id_ruta SERIAL PRIMARY KEY,
    id_vendedor INTEGER REFERENCES vendedores(id_vendedor),
    nombre_ruta VARCHAR(100) NOT NULL,
    fecha DATE DEFAULT CURRENT_DATE,
    zona VARCHAR(50),
    id_vehiculo INTEGER REFERENCES vehiculos(id_vehiculo),
    coordenadas GEOGRAPHY(POINT, 4326) -- Integración con GIS para geolocalización
);

g) Tabla Maletines

sql

CREATE TABLE maletines (
    id_maletin SERIAL PRIMARY KEY,
    descripcion VARCHAR(255) NOT NULL,
    fecha_asignacion DATE DEFAULT CURRENT_DATE
);

-- Inventario de Maletines
CREATE TABLE inventario_maletines (
    id_inventario SERIAL PRIMARY KEY,
    id_maletin INTEGER REFERENCES maletines(id_maletin),
    id_producto INTEGER REFERENCES productos(id_producto),
    id_vendedor INTEGER REFERENCES vendedores(id_vendedor),
    cantidad INTEGER NOT NULL
);

h) Tabla de Geolocalización (GPS)

sql

CREATE TABLE tracking_gps (
    id_tracking SERIAL PRIMARY KEY,
    id_vehiculo INTEGER REFERENCES vehiculos(id_vehiculo),
    coordenadas GEOGRAPHY(POINT, 4326), -- Para almacenar latitud y longitud
    latitud DECIMAL(9,6),
    longitud DECIMAL(9,6),
    fecha_hora TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

i) Tablas Ciudades, Municipios y Departamentos

sql

-- Tabla Departamento
CREATE TABLE departamentos (
    id_departamento SERIAL PRIMARY KEY,
    nombre_departamento VARCHAR(100) NOT NULL,
    codigo_departamento VARCHAR(10) UNIQUE NOT NULL
);

-- Tabla Municipio
CREATE TABLE municipios (
    id_municipio SERIAL PRIMARY KEY,
    id_departamento INTEGER REFERENCES departamentos(id_departamento),
    nombre_municipio VARCHAR(100) NOT NULL,
    codigo_municipio VARCHAR(10) UNIQUE NOT NULL
);

-- Tabla Zona o Ciudad
CREATE TABLE zonas (
    id_zona SERIAL PRIMARY KEY,
    id_municipio INTEGER REFERENCES municipios(id_municipio),
    nombre_zona VARCHAR(100) NOT NULL,
    codigo_zona VARCHAR(10) UNIQUE NOT NULL,
    geometria GEOGRAPHY(POLYGON, 4326) -- Definición de zonas geográficas
);

2. Funciones y Triggers Relacionados
a) Función para Verificar Antecedentes Judiciales

sql

-- Función para verificar si una persona tiene antecedentes judiciales
CREATE OR REPLACE FUNCTION verificar_antecedentes()
RETURNS TRIGGER AS $$
BEGIN
    IF EXISTS (SELECT 1 FROM antecedentes_judiciales WHERE numero_ci = NEW.cedula) THEN
        RAISE NOTICE 'La persona con cédula % tiene antecedentes judiciales', NEW.cedula;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger que llama a la función al insertar un cliente
CREATE TRIGGER tg_verificar_antecedentes
BEFORE INSERT ON clientes
FOR EACH ROW
EXECUTE FUNCTION verificar_antecedentes();

b) Trigger para Registrar Ubicación GPS

sql

-- Función para registrar ubicaciones GPS
CREATE OR REPLACE FUNCTION registrar_gps()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO tracking_gps (id_vehiculo, coordenadas, latitud, longitud)
    VALUES (NEW.id_vehiculo, ST_SetSRID(ST_MakePoint(NEW.longitud, NEW.latitud), 4326), NEW.latitud, NEW.longitud);
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger que se ejecuta tras registrar una ubicación GPS
CREATE TRIGGER tg_registrar_gps
AFTER INSERT ON tracking_gps
FOR EACH ROW
EXECUTE FUNCTION registrar_gps();

3. Relaciones Clave

    Clientes y Personas: La tabla personas puede utilizarse para almacenar información adicional sobre las personas, como sus cédulas y contactos. Los clientes pueden estar relacionados con personas si hay un esquema más complejo.
    Rutas y Vehículos: Los vendedores pueden estar asignados a rutas, y cada ruta puede tener asociado un vehículo para facilitar la movilidad y el seguimiento GPS.
    Antecedentes Judiciales: Se verifica si los clientes tienen antecedentes judiciales antes de ser ingresados, lo que podría afectar las decisiones comerciales.
    Geolocalización: Las rutas están asociadas con zonas geográficas (ciudades, municipios, departamentos) para un mejor control territorial.

4. Consultas de Ejemplo
a) Consulta de Clientes con Antecedentes Judiciales

sql

SELECT p.nombre, p.apellido, a.causa_penal
FROM personas p
INNER JOIN antecedentes_judiciales a ON p.cedula = a.numero_ci;

b) Consulta de Vehículos Asignados a Vendedores

sql

SELECT v.nombre, v.apellido, veh.marca, veh.modelo, veh.placa
FROM vendedores v
INNER JOIN rutas r ON v.id_vendedor = r.id_vendedor
INNER JOIN vehiculos veh ON r.id_vehiculo = veh.id_vehiculo;

c) Consulta de Geolocalización de Vehículos

sql

SELECT veh.placa, t.latitud, t.longitud, t.fecha_hora
FROM vehiculos veh
INNER JOIN tracking_gps t ON veh.id_vehiculo = t.id_vehiculo
ORDER BY t.fecha_hora DESC;

5. Índices y Optimización

    Índices Geográficos: Utiliza índices de tipo GEOGRAPHY para optimizar consultas relacionadas con geolocalización.
    Índices por CI y RUC: Crea índices en las tablas cedulas y ruc para mejorar las búsquedas basadas en esos números únicos.

Resumen

Este diseño completo incorpora las tablas adicionales que mencionaste, manteniendo una estructura bien organizada y lógica. Cada tabla tiene relaciones claras con las demás, y los triggers y funciones aseguran que las reglas de negocio (como el manejo de antecedentes judiciales y geolocalización) se manejen automáticamente. Este esquema te permitirá gestionar clientes, ventas, rutas, vehículos, y mucho más de manera eficiente.

CREATE DATABASE Gabriela_Fragancias;
-- Tabla Empresa
CREATE TABLE Empresa (
    id_empresa SERIAL PRIMARY KEY,
    ruc VARCHAR(20) UNIQUE NOT NULL,
    razon_social VARCHAR(100) NOT NULL,
    -- Otros campos específicos para Empresa
);

-- Tabla Usuario
CREATE TABLE Usuario (
    id_usuario SERIAL PRIMARY KEY,
    nombre_usuario VARCHAR(100) NOT NULL,
    contrasena VARCHAR(100) NOT NULL,
    rol VARCHAR(50) NOT NULL,
    -- Otros campos específicos para Usuario
);

-- Tabla Personas (con alerta de defunción)
CREATE TABLE Personas (
    id_persona SERIAL PRIMARY KEY,
    cedula VARCHAR(20) UNIQUE NOT NULL,
    nombre VARCHAR(100) NOT NULL,
    apellido VARCHAR(100) NOT NULL,
    fecha_nacimiento DATE NOT NULL,
    direccion TEXT NOT NULL,
    departamento VARCHAR(100),
    distrito_municipio VARCHAR(100),
    barrio_localidad VARCHAR(100),
    zona VARCHAR(100),
    telefono VARCHAR(20),
    email VARCHAR(100) UNIQUE,
    orden_captura INTEGER,
    causa TEXT,
    observacion TEXT,
    descripcion_estado TEXT,
    tipo_pol_mil VARCHAR(50),
    grado_pol_mil VARCHAR(50),	
    fecha_defuncion DATE,  -- Campo para gestionar defunciones
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- Trigger para alerta de defunción
CREATE OR REPLACE FUNCTION verificar_defuncion() 
RETURNS TRIGGER AS $$
BEGIN
    IF (NEW.fecha_defuncion IS NOT NULL) THEN
        RAISE NOTICE 'La persona con cédula % ha sido marcada como fallecida.', NEW.cedula;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tg_verificar_defuncion
AFTER INSERT OR UPDATE ON Personas
FOR EACH ROW
EXECUTE FUNCTION verificar_defuncion();

-- Tabla de Clientes
CREATE TABLE Clientes (
    id_cliente SERIAL PRIMARY KEY,
	tarjeta VARCHAR(7) UNIQUE NOT NULL,  -- Número de tarjeta obligatorio y valor reemplazado por otro cliente y zona
    id_persona INTEGER REFERENCES Persona(id_persona),
    cedula VARCHAR(20) UNIQUE NOT NULL,
    nombre VARCHAR(100) NOT NULL,
    apellido VARCHAR(100) NOT NULL,
    telefono VARCHAR(20),
    direccion TEXT,
    email VARCHAR(100),
    ruc VARCHAR(20) UNIQUE,
    fecha_registro DATE DEFAULT CURRENT_DATE,
    tipo_pago VARCHAR(20) CHECK (tipo_pago IN ('SEM', 'QUIN', 'MENS')),  -- SEM (semanal), QUIN (quincenal), MENS (mensual)
    saldo DECIMAL(10, 2) DEFAULT 0
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- Tabla Productos
CREATE TABLE Productos (
    id_producto SERIAL PRIMARY KEY,
    codigo_barras VARCHAR(50) UNIQUE NOT NULL,
    nombre VARCHAR(100) NOT NULL,
    id_marca INTEGER REFERENCES Marcas(id_marca),
    precio_contado DECIMAL(10, 2) NOT NULL,
    precio_credito DECIMAL(10, 2) NOT NULL,
    stock INTEGER NOT NULL,
    descripcion TEXT,
    presentacion VARCHAR(50),
    volumen INT CHECK (volumen BETWEEN 5 AND 200),
    es_kit BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- Trigger para actualizar el stock de productos después de una venta
CREATE OR REPLACE FUNCTION actualizar_stock_producto() 
RETURNS TRIGGER AS $$
BEGIN
    IF (NEW.cantidad > (SELECT stock FROM Productos WHERE id_producto = NEW.id_producto)) THEN
        RAISE EXCEPTION 'No hay suficiente stock para este producto';
    ELSE
        UPDATE Productos 
        SET stock = stock - NEW.cantidad 
        WHERE id_producto = NEW.id_producto;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tg_actualizar_stock
AFTER INSERT ON Ventas
FOR EACH ROW
EXECUTE FUNCTION actualizar_stock_producto();

-- Tabla de Marcas
CREATE TABLE Marcas (
    ID_Marca INT PRIMARY KEY AUTO_INCREMENT,
    Nombre VARCHAR(100) NOT NULL,
    Año_Fundacion INT,
    Sede VARCHAR(100),
    Sitio_Web VARCHAR(255),
    UNIQUE (Nombre)
);

-- Tabla de Perfumistas
CREATE TABLE Perfumistas (
    ID_Perfumista INT PRIMARY KEY AUTO_INCREMENT,
    Nombre VARCHAR(100) NOT NULL,
    Apellido VARCHAR(100) NOT NULL,
    Nacionalidad VARCHAR(50),
    UNIQUE (Nombre, Apellido)
);

-- Tabla de Notas Olfativas
CREATE TABLE Notas_Olfativas (
    ID_Nota INT PRIMARY KEY AUTO_INCREMENT,
    Nombre VARCHAR(50) NOT NULL,
    Descripcion TEXT,
    UNIQUE (Nombre)
);

-- Tabla de relación entre Productos y Notas Olfativas
CREATE TABLE Producto_Notas (
    ID_Producto INT,
    ID_Nota INT,
    Tipo_Nota ENUM('Alta', 'Media', 'Base'),
    PRIMARY KEY (ID_Producto, ID_Nota, Tipo_Nota),
    FOREIGN KEY (ID_Producto) REFERENCES Productos(ID_Producto),
    FOREIGN KEY (ID_Nota) REFERENCES Notas_Olfativas(ID_Nota)
);

-- Tabla de Productos (Perfumes)
CREATE TABLE Productos (
    ID_Producto INT PRIMARY KEY AUTO_INCREMENT,
    ID_Marca INT,
    Nombre VARCHAR(100) NOT NULL,
	Año_Lanzamiento INT,
    ID_Perfumista INT,
    Codigo_Barras VARCHAR(13) UNIQUE,
    Precio_Costo DECIMAL(10, 2),
    Precio_Venta DECIMAL(10, 2),
    Duracion_Horas INT,
    Stock INT DEFAULT 0,
    FOREIGN KEY (ID_Marca) REFERENCES Marcas(ID_Marca),
    FOREIGN KEY (ID_Perfumista) REFERENCES Perfumistas(ID_Perfumista)
);

-- Tabla Presentacion
CREATE TABLE Presentacion (
    id_presentacion SERIAL PRIMARY KEY,
    id_perfume INTEGER REFERENCES Perfume(id_perfume) ON DELETE CASCADE,
    codigo_barra VARCHAR(50) UNIQUE NOT NULL,
    tamano_ml INTEGER CHECK (tamano_ml > 0),
    imagen_url VARCHAR(255)
);

-- Tabla de Vendedores
CREATE TABLE Vendedores (
    id_vendedor SERIAL PRIMARY KEY,
    id_zona INTEGER REFERENCES Zona(id_zona);
	nombre VARCHAR(100) NOT NULL,
    zona VARCHAR(50) NOT NULL,
    comision DECIMAL(10, 2) DEFAULT 50000
);

-- Tabla de Inventario por Vendedora
CREATE TABLE Inventario (
    id_inventario SERIAL PRIMARY KEY,
    id_vendedor INTEGER REFERENCES Vendedores(id_vendedor),
    id_producto INTEGER REFERENCES Productos(id_producto),
    cantidad INTEGER NOT NULL
);

-- Tabla Ventas
CREATE TABLE Ventas (
    id_venta SERIAL PRIMARY KEY,
    id_cliente INTEGER REFERENCES Clientes(id_cliente),
    id_producto INTEGER REFERENCES Productos(id_producto),
    fecha DATE DEFAULT CURRENT_DATE,
    forma_pago VARCHAR(20) CHECK (forma_pago IN ('Contado', 'Crédito')),  -- Contado, Crédito (SEM, QUIN, MENS)
    total DECIMAL(10, 2) NOT NULL,
    saldo DECIMAL(10, 2) DEFAULT 0,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- Trigger para actualizar el saldo de los clientes tras una venta
CREATE OR REPLACE FUNCTION actualizar_saldo_cliente() 
RETURNS TRIGGER AS $$
BEGIN
    UPDATE Clientes 
    SET saldo = saldo - NEW.total
    WHERE id_cliente = NEW.id_cliente;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tg_actualizar_saldo
AFTER INSERT ON Ventas
FOR EACH ROW
EXECUTE FUNCTION actualizar_saldo_cliente();

-- Tabla Pagos
CREATE TABLE Pagos (
    id_pago SERIAL PRIMARY KEY,
    id_cliente INTEGER REFERENCES Clientes(id_cliente),
    id_venta INTEGER REFERENCES Ventas(id_venta),
    fecha_pago DATE DEFAULT CURRENT_DATE,
    monto DECIMAL(10, 2) NOT NULL,
    metodo_pago VARCHAR(20) CHECK (metodo_pago IN ('Efectivo', 'Tarjeta', 'Transferencia')),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- Tabla Cédula
CREATE TABLE Cedula (
    numero_ci VARCHAR(20) PRIMARY KEY,
    nombre VARCHAR(100) NOT NULL,
    apellido VARCHAR(100) NOT NULL,
    fecha_nacimiento DATE NOT NULL,
    direccion TEXT NOT NULL
);

-- Tabla AntecedentesJudiciales
CREATE TABLE AntecedentesJudiciales (
    id_antecedente SERIAL PRIMARY KEY,
    numero_ci VARCHAR(20) REFERENCES Cedula(numero_ci),
    causa_penal TEXT
);

-- Tabla de RUC
CREATE TABLE ruc (
    id_ruc SERIAL PRIMARY KEY,
    numero_ruc VARCHAR(20) UNIQUE NOT NULL,
    digito_verificador INT NOT NULL,
    razon_social VARCHAR(100) NOT NULL
);

-- Tabla Inventario_Maletines (para manejar los productos en los maletines de vendedoras)
CREATE TABLE Inventario_Maletines (
    id_inventario SERIAL PRIMARY KEY,
    id_maletin INTEGER REFERENCES Maletines(id_maletin),
    id_producto INTEGER REFERENCES Productos(id_producto),
    id_vendedor INTEGER REFERENCES Vendedores(id_vendedor),
    fecha_carga DATE DEFAULT CURRENT_DATE,
	cantidad INTEGER NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- Tabla Productos de Maletines
CREATE TABLE productos_maletin (
    id_maletin INT REFERENCES maletines(id_maletin),
    id_producto INT REFERENCES productos(id_producto),
    cantidad INT,
    PRIMARY KEY (id_maletin, id_producto)
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP NULL DEFAULT NULL
);

-- Tabla de Liquidaciones
CREATE TABLE liquidaciones (
    id_liquidacion SERIAL PRIMARY KEY,
    id_empleado INT REFERENCES empleados(id_empleado),
    fecha_liquidacion DATE DEFAULT CURRENT_DATE,
    total_ventas DECIMAL(10, 2),
    comision DECIMAL(10, 2),
    total_pagar DECIMAL(10, 2)
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP NULL DEFAULT NULL
);

-- Tabla de Vehículos
CREATE TABLE vehiculos (
    id_vehiculo SERIAL PRIMARY KEY,
    placa VARCHAR(20) UNIQUE,
    marca VARCHAR(50), CHARACTER SET utf8mb4;
    modelo VARCHAR(50), CHARACTER SET utf8mb4;
    año INT,
	chassis VARCHAR(50), CHARACTER SET utf8mb4;
	motor VARCHAR(50), CHARACTER SET utf8mb4;
    ultima_revision DATE
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP NULL DEFAULT NULL
);

-- Tabla de Gastos de Vehículos
CREATE TABLE gastos_vehiculos (
    id_gasto SERIAL PRIMARY KEY,
    id_vehiculo INT REFERENCES vehiculos(id_vehiculo),
    tipo_gasto VARCHAR(50) CHECK (tipo_gasto IN ('Combustible', 'Lubricantes', 'Gomería', 'Mecánica', 'Electricidad', 'Otro')); CHARACTER SET utf8mb4;
    monto DECIMAL(10, 2),
    fecha DATE DEFAULT CURRENT_DATE
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP NULL DEFAULT NULL
);

-- Tabla Rutas (para vendedores y manejo de geolocalización)
CREATE TABLE Rutas (
    id_ruta SERIAL PRIMARY KEY,
    id_vendedor INTEGER REFERENCES Vendedores(id_vendedor),
    nombre_ruta VARCHAR(100) NOT NULL,
    fecha DATE DEFAULT CURRENT_DATE,
    zona VARCHAR(50),
    id_vehiculo INTEGER REFERENCES Vehiculo(id_vehiculo),
	coordenadas GEOGRAPHY(POINT, 4326)  -- Integración con GIS
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- Tabla de Tracking GPS
CREATE TABLE tracking_gps (
    id_tracking SERIAL PRIMARY KEY,
    id_vehiculo INT REFERENCES vehiculos(id_vehiculo),
	coordenadas GEOGRAPHY(Point, 4326);
    latitud DECIMAL(9, 6),
    longitud DECIMAL(9, 6),
    fecha_hora TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Tabla de Proveedores
CREATE TABLE proveedores (
    id_proveedor SERIAL PRIMARY KEY,
    ruc VARCHAR(20) UNIQUE,
    nombre VARCHAR(100) NOT NULL, CHARACTER SET utf8mb4;
    direccion TEXT, CHARACTER SET utf8mb4;
    telefono VARCHAR(20),
    email VARCHAR(100) CHARACTER SET utf8mb4;
);

-- Tabla de Compras a Proveedores
CREATE TABLE compras_proveedores (
    id_compra SERIAL PRIMARY KEY,
    id_proveedor INT REFERENCES proveedores(id_proveedor),
    fecha_compra DATE DEFAULT CURRENT_DATE,
    total DECIMAL(10, 2)
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP NULL DEFAULT NULL
);

-- Tabla de Detalles de Compra
CREATE TABLE detalles_compra (
    id_detalle SERIAL PRIMARY KEY,
    id_compra INT REFERENCES compras_proveedores(id_compra),
    id_producto INT REFERENCES productos(id_producto),
    cantidad INT,
    precio_unitario DECIMAL(10, 2),
    subtotal DECIMAL(10, 2)
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP NULL DEFAULT NULL
);

-- Tabla Departamento
CREATE TABLE Departamento (
    id_departamento SERIAL PRIMARY KEY,
    nombre_departamento VARCHAR(100) NOT NULL, CHARACTER SET utf8mb4;
    codigo_departamento VARCHAR(10) UNIQUE NOT NULL
);

-- Tabla Municipio
CREATE TABLE Municipio (
    id_municipio SERIAL PRIMARY KEY,
    id_departamento INTEGER REFERENCES Departamento(id_departamento),
    nombre_municipio VARCHAR(100) NOT NULL, CHARACTER SET utf8mb4;
    codigo_municipio VARCHAR(10) UNIQUE NOT NULL
);

-- Tabla Zona
CREATE TABLE Zona (
    id_zona SERIAL PRIMARY KEY,
    id_municipio INTEGER REFERENCES Municipio(id_municipio),
    nombre_zona VARCHAR(100) NOT NULL, CHARACTER SET utf8mb4;
    codigo_zona VARCHAR(10) UNIQUE NOT NULL,
    geometria GEOGRAPHY(POLYGON, 4326)
);

-- Tabla Ubicacion
CREATE TABLE Ubicacion (
    id_ubicacion SERIAL PRIMARY KEY,
    id_vendedor INTEGER REFERENCES Vendedor(id_vendedor),
    fecha_hora TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    coordenadas GEOGRAPHY(POINT, 4326)
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP NULL DEFAULT NULL
);

-- Tabla de Equipos (para manejar lectores de códigos, impresoras, etc.)
CREATE TABLE equipos (
    id_equipo SERIAL PRIMARY KEY,
    tipo VARCHAR(50) CHECK (tipo IN ('Lector Código Barras', 'Impresora Ticket', 'Impresora Matricial', 'Impresora Láser', 'Impresora Inyección')),
    marca VARCHAR(50), CHARACTER SET utf8mb4;
    modelo VARCHAR(50), CHARACTER SET utf8mb4;
    fecha_adquisicion DATE
);

-- Índices para optimizar consultas frecuentes
CREATE INDEX idx_productos_marca ON Productos(ID_Marca);
CREATE INDEX idx_ventas_cliente ON Ventas(ID_Cliente);
CREATE INDEX idx_ventas_fecha ON Ventas(Fecha_Venta);
CREATE INDEX idx_inventario_producto ON Inventario(ID_Producto);

-- Índices para mejorar el rendimiento
CREATE INDEX idx_clientes_cedula ON clientes(cedula);
CREATE INDEX idx_clientes_ruc ON clientes(ruc);
CREATE INDEX idx_productos_codigo_barras ON productos(codigo_barras);
CREATE INDEX idx_ventas_fecha ON ventas(fecha_venta);
CREATE INDEX idx_empleados_cargo ON empleados(cargo);
CREATE INDEX idx_cliente_cedula ON Cliente(cedula);

-- Trigger que ejecuta la función al insertar una venta
CREATE TRIGGER tg_actualizar_saldo
AFTER INSERT ON Ventas
FOR EACH ROW
EXECUTE FUNCTION actualizar_saldo_cliente();
CREATE OR REPLACE FUNCTION actualizar_stock_producto() 
RETURNS TRIGGER AS $$
BEGIN
    IF (NEW.cantidad > (SELECT stock FROM Productos WHERE id_producto = NEW.id_producto)) THEN
        RAISE EXCEPTION 'No hay suficiente stock para este producto';
    ELSE
        UPDATE Productos 
        SET stock = stock - NEW.cantidad 
        WHERE id_producto = NEW.id_producto;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION actualizar_saldo_cliente() 
RETURNS TRIGGER AS $$
BEGIN
    UPDATE Clientes 
    SET saldo = saldo - NEW.total
    WHERE id_cliente = NEW.id_cliente;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger que ejecuta la función al insertar una venta
CREATE TRIGGER tg_actualizar_stock
AFTER INSERT ON Ventas
FOR EACH ROW
EXECUTE FUNCTION actualizar_stock_producto();

-- Función para verificar antecedentes judiciales al insertar un cliente
CREATE OR REPLACE FUNCTION verificar_antecedentes_judiciales()
RETURNS TRIGGER AS $$
BEGIN
    IF EXISTS (
        SELECT 1 FROM AntecedentesJudiciales
        WHERE numero_ci = NEW.cedula
    ) THEN
        RAISE NOTICE 'El cliente con cédula % tiene antecedentes judiciales', NEW.cedula;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger para llamar a la función al insertar un cliente
CREATE TRIGGER tg_verificar_antecedentes_judiciales
BEFORE INSERT ON Clientes
FOR EACH ROW
EXECUTE FUNCTION verificar_antecedentes_judiciales();

-- Trigger para actualizar el stock al vender
CREATE OR REPLACE FUNCTION actualizar_stock() RETURNS TRIGGER AS $$
BEGIN
    IF NEW.cantidad > OLD.stock THEN
        RAISE EXCEPTION 'No hay suficiente stock';
    ELSE
        UPDATE Inventario SET stock = stock - NEW.cantidad WHERE id_presentacion = NEW.id_presentacion;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tg_actualizar_stock
AFTER INSERT ON DetalleVenta
FOR EACH ROW EXECUTE FUNCTION actualizar_stock();

CREATE OR REPLACE FUNCTION actualizar_saldo_cliente() 
RETURNS TRIGGER AS $$
BEGIN
    UPDATE Clientes 
    SET saldo = saldo - NEW.total
    WHERE id_cliente = NEW.id_cliente;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Vistas para reportes comunes
CREATE VIEW VW_Ventas_Por_Cliente AS
SELECT 
    c.ID_Cliente, 
    c.Nombre, 
    c.Apellido, 
    COUNT(v.ID_Venta) AS Total_Ventas, 
    SUM(v.Total) AS Monto_Total
FROM 
    Clientes c
LEFT JOIN 
    Ventas v ON c.ID_Cliente = v.ID_Cliente
GROUP BY 
    c.ID_Cliente;

CREATE VIEW VW_Stock_Productos AS
SELECT 
    p.ID_Producto, 
    p.Nombre, 
    m.Nombre AS Marca, 
    p.Stock, 
    p.Precio_Venta
FROM 
    Productos p
JOIN 
    Marcas m ON p.ID_Marca = m.ID_Marca;

-- Trigger para verificar si un cliente tiene antecedentes judiciales
CREATE OR REPLACE FUNCTION verificar_antecedentes() 
RETURNS TRIGGER AS $$
BEGIN
    IF EXISTS (SELECT 1 FROM AntecedentesJudiciales WHERE cedula = NEW.cedula) THEN
        RAISE NOTICE 'El cliente con cédula % tiene antecedentes judiciales', NEW.cedula;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tg_verificar_antecedentes
BEFORE INSERT ON Clientes
FOR EACH ROW
EXECUTE FUNCTION verificar_antecedentes();

-- Trigger para actualizar la comisión de las vendedoras tras una venta
CREATE OR REPLACE FUNCTION actualizar_comision_vendedora() 
RETURNS TRIGGER AS $$
BEGIN
    UPDATE Liquidaciones 
    SET total_ventas = total_ventas + NEW.total,
        comision = comision + (50000 * NEW.cantidad)  -- Comisión por producto
    WHERE id_vendedor = NEW.id_vendedor;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tg_actualizar_comision
AFTER INSERT ON Ventas
FOR EACH ROW
EXECUTE FUNCTION actualizar_comision_vendedora();

-- Índices faltantes para optimización de consultas
CREATE INDEX idx_rutas_vendedor_fecha ON Rutas(id_vendedor, fecha);
CREATE INDEX idx_pagos_cliente_metodo ON Pagos(id_cliente, metodo_pago);
CREATE INDEX idx_antecedentes_cedula ON AntecedentesJudiciales(cedula);
CREATE INDEX idx_inventario_maletines_producto ON Inventario_Maletines(id_maletin, id_producto);
CREATE INDEX idx_vehiculos_motor_chasis_placa ON Vehiculos(numero_motor, numero_chasis, placa);

Gemini acaba de actualizarse.  Ver actualización
Conversación con Gemini
foto de perfil

¡Buenas tardes, Gemini!

¡Buenas tardes!   Es un placer saludarte. ¿En qué puedo ayudarte hoy?

Siéntete libre de preguntarme cualquier cosa. Aquí tienes algunas ideas para comenzar:

    Horóscopo: ¿Quieres saber qué te depara el día de hoy o la semana según tu signo?
    Características de Géminis: ¿Te interesa conocer más sobre las cualidades y peculiaridades de los nacidos bajo este signo?
    Consejos: ¿Buscas consejos para mejorar tu comunicación, relaciones o vida en general?
    Curiosidades: ¿Te gustaría saber datos interesantes sobre el signo de Géminis o la astrología en general?

¡Tú eliges el tema!
foto de perfil

esta es la mejor adecuación a las necesidades de Gabriela Fragancias, pero quiero tu ayuda para verificar las relaciones de las tablas, sus funciones y evitar redundancias

-- Trigger para verificar si un cliente tiene antecedentes judiciales

CREATE OR REPLACE FUNCTION verificar_antecedentes() 

RETURNS TRIGGER AS $$

BEGIN

    IF EXISTS (SELECT 1 FROM AntecedentesJudiciales WHERE cedula = NEW.cedula) THEN

        RAISE NOTICE 'El cliente con cédula % tiene antecedentes judiciales', NEW.cedula;

    END IF;

    RETURN NEW;

END;

$$ LANGUAGE plpgsql;


CREATE TRIGGER tg_verificar_antecedentes

BEFORE INSERT ON Clientes

FOR EACH ROW

EXECUTE FUNCTION verificar_antecedentes();


-- Trigger para actualizar la comisión de las vendedoras tras una venta

CREATE OR REPLACE FUNCTION actualizar_comision_vendedora() 

RETURNS TRIGGER AS $$

BEGIN

    UPDATE Liquidaciones 

    SET total_ventas = total_ventas + NEW.total,

        comision = comision + (50000 * NEW.cantidad)  -- Comisión por producto

    WHERE id_vendedor = NEW.id_vendedor;

    RETURN NEW;

END;

$$ LANGUAGE plpgsql;


CREATE TRIGGER tg_actualizar_comision

AFTER INSERT ON Ventas

FOR EACH ROW

EXECUTE FUNCTION actualizar_comision_vendedora();


-- Índices faltantes para optimización de consultas

CREATE INDEX idx_rutas_vendedor_fecha ON Rutas(id_vendedor, fecha);

CREATE INDEX idx_pagos_cliente_metodo ON Pagos(id_cliente, metodo_pago);

CREATE INDEX idx_antecedentes_cedula ON AntecedentesJudiciales(cedula);

CREATE INDEX idx_inventario_maletines_producto ON Inventario_Maletines(id_maletin, id_producto);

CREATE INDEX idx_vehiculos_motor_chasis_placa ON Vehiculos(numero_motor, numero_chasis, placa);

¡Hola! Es excelente que estés buscando optimizar tus triggers y funciones para Gabriela Fragancias. Analicemos juntos el código y hagamos algunas observaciones:
Análisis de los Triggers y Funciones
Trigger verificar_antecedentes

    Función: Verifica si un cliente tiene antecedentes judiciales al momento de registrarse.
    Observación: Es una función sencilla y efectiva para su propósito. El uso de RAISE NOTICE es útil para informar sobre la existencia de antecedentes, pero en un entorno productivo, podrías considerar registrar esta información en un log o enviar una notificación a un usuario específico.

Trigger actualizar_comision_vendedora

    Función: Actualiza la comisión de una vendedora cada vez que se registra una nueva venta.
    Observaciones:
        Cálculo de la comisión: La fórmula (50000 * NEW.cantidad) asume que la comisión es fija por producto. Si la comisión varía según el producto o la vendedora, deberías ajustar esta lógica.
        Tabla Liquidaciones: ¿La tabla Liquidaciones se actualiza con cada venta o se utiliza para calcular comisiones periódicamente? Si se actualiza con cada venta, podrías considerar agrupar las ventas por vendedor y periodo para generar un resumen más preciso de las comisiones.
        Concurrencia: Si hay múltiples transacciones simultáneas, este trigger podría generar problemas de concurrencia al actualizar la misma fila en la tabla Liquidaciones. Podrías utilizar transacciones o bloqueos para evitar esto.

Análisis de los Índices

    Función: Los índices mejoran el rendimiento de las consultas al reducir la cantidad de datos que deben ser escaneados.
    Observaciones:
        Selección de columnas: Los índices creados parecen estar bien seleccionados, considerando las columnas más utilizadas en las consultas.
        Cardinalidad: Es importante monitorear la cardinalidad de los índices (cantidad de valores únicos) para asegurar que estén siendo utilizados de manera eficiente.
        Tamaño de la tabla: Si las tablas son muy grandes, podrías considerar crear índices compuestos o particionar las tablas para mejorar el rendimiento.

Sugerencias Adicionales

    Redundancia: Revisa si hay columnas que contienen información redundante. Por ejemplo, si el nombre y apellido del cliente están almacenados tanto en la tabla Clientes como en la tabla Ventas, podrías eliminar esta redundancia para reducir el espacio de almacenamiento y mejorar la integridad de los datos.
    Normalización: Asegúrate de que las tablas estén normalizadas para evitar anomalías de datos y mejorar la integridad.
    Optimización de consultas: Analiza las consultas más frecuentes y utiliza herramientas como EXPLAIN para identificar cuellos de botella y optimizar el rendimiento.
    Pruebas: Realiza pruebas exhaustivas para verificar que los triggers y funciones funcionen correctamente y no introduzcan errores en la base de datos.

Preguntas para Aclarar

    ¿Cuál es la estructura completa de las tablas involucradas (campos, tipos de datos, relaciones)?
    ¿Qué tipo de consultas se realizan con mayor frecuencia?
    ¿Hay algún requisito específico de rendimiento o escalabilidad?
    ¿Se utilizan otras herramientas de base de datos, como vistas o funciones materializadas?

Ejemplo de Optimización del Trigger actualizar_comision_vendedora:
SQL

CREATE OR REPLACE FUNCTION actualizar_comision_vendedora() 
RETURNS TRIGGER AS $$
BEGIN
    -- Utilizar una transacción para garantizar la consistencia de los datos
    BEGIN
        UPDATE Liquidaciones 
        SET total_ventas = total_ventas + NEW.total,
            comision = comision + (SELECT comisión_por_producto FROM Productos WHERE id_producto = NEW.id_producto) * NEW.cantidad
        WHERE id_vendedor = NEW.id_vendedor;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE NOTICE 'Error al actualizar la comisión: %', SQLERRM;
    END;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

Usa el código con precaución.

Este ejemplo muestra cómo calcular la comisión de forma más flexible, utilizando una tabla Productos para obtener la comisión por producto. También incluye una transacción para garantizar la consistencia de los datos en caso de errores.

Espero que estas observaciones y sugerencias te sean útiles. ¡No dudes en hacer más preguntas!
foto de perfil

podrías presentar el código completo con tus mejoras

¡Absolutamente! Basándome en el análisis anterior y las sugerencias proporcionadas, aquí te presento una versión mejorada del código, incorporando las mejoras discutidas y adaptándolo a un escenario más completo:

Consideraciones Adicionales:

    Estructura de tablas: Asumí una estructura de tablas simplificada para este ejemplo. Adapta las tablas y relaciones a tu modelo de datos real.
    Cálculo de comisiones: Se ha introducido una tabla Comisiones para almacenar las comisiones por producto, lo que permite una mayor flexibilidad en el cálculo.
    Logueo de eventos: Se ha agregado un log para registrar los eventos importantes, como la detección de antecedentes judiciales o errores en la actualización de comisiones.
    Manejo de errores: Se han incluido bloques EXCEPTION para manejar errores de manera más robusta.
    Optimizaciones adicionales: Se pueden realizar más optimizaciones dependiendo de la complejidad de tu aplicación y las características del sistema de base de datos.

Código Mejorado:
SQL

-- Tabla para almacenar las comisiones por producto
CREATE TABLE Comisiones (
    id_producto INTEGER,
    comision NUMERIC,
    PRIMARY KEY (id_producto),
    FOREIGN KEY (id_producto) REFERENCES Productos(id_producto)
);

-- Función para registrar eventos en un log
CREATE OR REPLACE FUNCTION registrar_evento(evento TEXT)
RETURNS VOID AS $$
BEGIN
    INSERT INTO Log (fecha, evento) VALUES (NOW(), evento);
END;
$$ LANGUAGE plpgsql;

-- Trigger para verificar antecedentes judiciales y registrar en el log
CREATE OR REPLACE FUNCTION verificar_antecedentes() 
RETURNS TRIGGER AS $$
BEGIN
    IF EXISTS (SELECT 1 FROM AntecedentesJudiciales WHERE cedula = NEW.cedula) THEN
        RAISE NOTICE 'El cliente con cédula % tiene antecedentes judiciales', NEW.cedula;
        PERFORM registrar_evento('Cliente con antecedentes: ' || NEW.cedula);
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger para actualizar la comisión de las vendedoras tras una venta
CREATE OR REPLACE FUNCTION actualizar_comision_vendedora() 
RETURNS TRIGGER AS $$
BEGIN
    BEGIN
        UPDATE Liquidaciones 
        SET total_ventas = total_ventas + NEW.total,
            comision = comision + (SELECT comision FROM Comisiones WHERE id_producto = NEW.id_producto) * NEW.cantidad
        WHERE id_vendedor = NEW.id_vendedor;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            PERFORM registrar_evento('Error al actualizar comisión: ' || SQLERRM);
    END;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Índices adicionales (adapta según tu esquema)
CREATE INDEX idx_liquidaciones_vendedor ON Liquidaciones(id_vendedor);
CREATE INDEX idx_comisiones_producto ON Comisiones(id_producto);

Usa el código con precaución.

Explicación de los cambios:

    Tabla Comisiones: Esta tabla almacena la comisión por producto, permitiendo una gestión más flexible y escalable de las comisiones.
    Función registrar_evento: Esta función simplifica el registro de eventos en un log, lo que puede ser útil para la auditoría y la resolución de problemas.
    Trigger verificar_antecedentes: Se ha agregado una llamada a registrar_evento para documentar la detección de antecedentes judiciales.
    Trigger actualizar_comision_vendedora: Se utiliza la tabla Comisiones para obtener la comisión por producto y se ha mejorado el manejo de errores con un bloque EXCEPTION.
    Índices adicionales: Se ha agregado un índice en la tabla Liquidaciones para mejorar el rendimiento de las actualizaciones de comisiones.

Consideraciones Futuras:

    Optimización de consultas: Utiliza herramientas como EXPLAIN para identificar consultas lentas y optimizarlas.
    Particionamiento: Si las tablas son muy grandes, considera particionarlas para mejorar el rendimiento de las consultas.
    Materialización de vistas: Si hay consultas que se ejecutan con frecuencia, puedes considerar materializarlas como vistas para mejorar el rendimiento.
    Monitoreo: Implementa un sistema de monitoreo para identificar problemas de rendimiento y detectar anomalías en los datos.

Adaptación a tu Esquema:

    Ajuste de tablas y columnas: Asegúrate de que las tablas y columnas coincidan con tu esquema de base de datos.
    Modificación de funciones y triggers: Adapta las funciones y triggers para que se ajusten a tu lógica de negocio específica.
    Creación de índices: Crea índices en las columnas que se utilizan frecuentemente en las cláusulas WHERE, JOIN y ORDER BY de tus consultas.

Recuerda: Esta es solo una propuesta. La optimización de una base de datos es un proceso iterativo que requiere un profundo conocimiento de tu aplicación y de las características del sistema de base de datos que estás utilizando.

¿Te gustaría profundizar en alguna parte específica del código o explorar otras opciones de optimización?
foto de perfil

excelente, has visto las tablas

¡Absolutamente! Basándome en el código que hemos analizado, puedo inferir una estructura de tablas general para Gabriela Fragancias. Sin embargo, para poder ofrecerte una respuesta más precisa y personalizada, te pediría que me confirmes o corrijas la siguiente estructura:

Posible estructura de tablas:

    Clientes: id_cliente (PK), nombre, apellido, cedula, dirección, teléfono
    Ventas: id_venta (PK), fecha, total, id_cliente (FK), id_vendedor (FK)
    Productos: id_producto (PK), nombre, precio
    Ventas_Detalle: id_venta_detalle (PK), cantidad, id_venta (FK), id_producto (FK)
    Vendedores: id_vendedor (PK), nombre, apellido, comisión_base
    Liquidaciones: id_liquidacion (PK), fecha_inicio, fecha_fin, total_ventas, comision, id_vendedor (FK)
    AntecedentesJudiciales: id_antecedente (PK), descripcion, cedula (FK)
    Rutas: id_ruta (PK), fecha, id_vendedor (FK)
    Pagos: id_pago (PK), fecha, monto, metodo_pago, id_venta (FK)
    Inventario_Maletines: id_inventario_maletin (PK), cantidad, id_maletin (FK), id_producto (FK)
    Maletines: id_maletin (PK), descripcion
    Vehiculos: id_vehiculo (PK), numero_motor, numero_chasis, placa

Relaciones:

    Una venta puede tener muchos productos (relación muchos a muchos a través de Ventas_Detalle).
    Un cliente puede realizar muchas ventas.
    Un vendedor puede realizar muchas ventas y tener muchas rutas.
    Un pago está asociado a una venta.
    Un inventario de maletines contiene varios productos.

Si esta estructura es correcta, podemos profundizar en las siguientes áreas:

    Optimización de consultas: ¿Qué tipo de consultas realizas con mayor frecuencia? Podemos analizarlas y sugerir índices adicionales o ajustes en las consultas para mejorar el rendimiento.
    Diseño de reportes: ¿Qué tipo de reportes necesitas generar? Podemos diseñar vistas o procedimientos almacenados para facilitar la generación de informes personalizados.
    Escalabilidad: ¿Esperas un crecimiento significativo en la cantidad de datos? Podemos evaluar si es necesario realizar particionamiento o replicación de la base de datos.
    Seguridad: ¿Qué medidas de seguridad deseas implementar? Podemos discutir sobre permisos, encriptación de datos y otras medidas para proteger la información.

Por favor, confirma si esta estructura de tablas es correcta y si tienes alguna pregunta adicional.

Además, si puedes proporcionar información sobre:

    El sistema de base de datos que estás utilizando: (MySQL, PostgreSQL, SQL Server, etc.)
    El lenguaje de programación que utilizas: (Python, Java, etc.)
    Las consultas más frecuentes que realizas:

Podré darte recomendaciones aún más específicas.

¡Estoy a tu disposición para ayudarte!
foto de perfil

la interfaz será en python, la base en postgresql, las tablas son así como detallas, las consultas más frecuentes son de clientes y saldo, los clientes pueden tener el mismo número de tarjeta pero distinta zona, o a veces se reemplaza un cliente que ha cancelado por uno nuevo, los gráficos que se necesitan son sobre las ventas y zonas

¡Excelente! Con esta información adicional, podemos afinar aún más nuestras recomendaciones.
Análisis y Sugerencias Basado en tus Necesidades
Estructura de Tablas y Relación con Python

La estructura de tablas que has propuesto es sólida y cubre los aspectos básicos de un sistema de gestión de clientes y ventas. Para interactuar con esta base de datos desde Python, te recomiendo utilizar un ORM (Object-Relational Mapper) como SQLAlchemy. Esto te permitirá trabajar con los datos de la base de datos como si fueran objetos de Python, simplificando significativamente tu código.
Consultas Frecuentes y Optimización

Dado que las consultas más frecuentes son sobre clientes y saldos, es fundamental crear índices adecuados en las columnas que se utilizan con frecuencia en los criterios de búsqueda (e.g., cedula, nombre, apellido).

Índices Sugeridos:

    Clientes: cedula, nombre, apellido, zona
    Ventas: id_cliente, fecha
    Pagos: id_cliente, fecha

Consideraciones Adicionales:

    Clientes con mismo número de tarjeta y distinta zona: Para manejar esta situación, podrías agregar una columna id_cliente_original en la tabla Clientes para rastrear los reemplazos. Esto te permitirá realizar análisis históricos y comprender mejor la evolución de la base de cliente.
    Gráficos de ventas y zonas: Para generar gráficos, necesitarás agrupar los datos por zona y periodo. Utiliza las funciones de agregación de SQL (SUM, COUNT, etc.) para calcular los totales de ventas por zona.

Código de Ejemplo con SQLAlchemy
Python

from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy import Column, Integer, String,  

 ForeignKey

# Crear una conexión a la base de datos PostgreSQL
engine = create_engine('postgresql://usuario:contraseña@localhost/tu_base_de_datos')
Base = declarative_base()

# Definir las clases que representan las tablas
class Cliente(Base):
    __tablename__ = 'clientes'
    id_cliente = Column(Integer, primary_key=True)
    nombre = Column(String)
    # ... otros campos

class Venta(Base):
    __tablename__ = 'ventas'
    id_venta = Column(Integer, primary_key=True)
    fecha = Column(Date)
    # ... otros campos
    id_cliente = Column(Integer, ForeignKey('clientes.id_cliente'))
    cliente = relationship("Cliente")

# Crear las tablas en la base de datos
Base.metadata.create_all(engine)

# Ejemplo de consulta para obtener el total de ventas por zona en un mes
session = Session(engine)
resultado = session.query(Cliente.zona, func.sum(Venta.total)).join(Venta).group_by(Cliente.zona).all()

Usa el código con precaución.
Visualización de Datos

Para generar los gráficos, puedes utilizar bibliotecas como:

    Matplotlib: Para gráficos básicos y personalizados.
    Seaborn: Para gráficos estadísticos de alta calidad.
    Plotly: Para gráficos interactivos y dashboards.

Ejemplo con Matplotlib:
Python

import matplotlib.pyplot as plt

# Suponiendo que 'resultado' contiene los datos obtenidos de la consulta anterior
zonas = [row[0] for row in resultado]
totales = [row[1] for row in resultado]

plt.bar(zonas, totales)
plt.xlabel('Zona')
plt.ylabel('Total de Ventas')
plt.title('Ventas por Zona')
plt.show()

Usa el código con precaución.
Próximos Pasos

    Refina la estructura de tus tablas: Asegúrate de que incluyan todos los campos necesarios para tu aplicación y que las relaciones entre las tablas sean correctas.
    Crea los índices adecuados: Basándote en las consultas más frecuentes, crea índices para mejorar el rendimiento.
    Implementa las consultas: Utiliza SQLAlchemy para escribir consultas eficientes y flexibles.
    Visualiza los datos: Elige la biblioteca de visualización que mejor se adapte a tus necesidades y crea gráficos informativos.

Preguntas Adicionales:

    ¿Qué tipo de análisis estadístico deseas realizar? (e.g., tendencias de ventas, análisis de clientes)
    ¿Necesitas generar reportes personalizados?
    ¿Quieres implementar un panel de control para visualizar los datos de forma interactiva?

Con esta información adicional, podré brindarte un soporte más específico.
www.dataquest.io
www.dataquest.io
foto de perfil

excelente, ahora escribe todo el sql

¡Absolutamente! Para proporcionarte el código SQL completo, necesitaré un poco más de contexto sobre tus requerimientos específicos.

Consideraciones a tener en cuenta:

    Consultas específicas: ¿Qué tipo de información deseas obtener de la base de datos? Por ejemplo:
        ¿Quieres saber el total de ventas por producto en un rango de fechas?
        ¿Deseas identificar a los clientes que más han gastado?
        ¿Necesitas calcular el promedio de ventas por vendedor?
    Filtros y agrupamientos: ¿Qué criterios de búsqueda utilizarás? ¿Necesitarás agrupar los datos por alguna dimensión (e.g., zona, producto, vendedor)?
    Uniones entre tablas: ¿Qué relaciones existen entre las tablas y cómo quieres utilizarlas en tus consultas?

Ejemplo de Consulta Básica:
Supongamos que quieres obtener una lista de todos los clientes con su información de contacto. La consulta SQL sería:
SQL

SELECT * FROM clientes;

Usa el código con precaución.

Ejemplo de Consulta Más Compleja:
Si deseas conocer el total de ventas por producto en el mes de enero de 2023, la consulta podría ser:
SQL

SELECT productos.nombre, SUM(ventas_detalle.cantidad) AS total_vendido
FROM ventas
INNER JOIN ventas_detalle ON ventas.id_venta = ventas_detalle.id_venta
INNER JOIN productos ON ventas_detalle.id_producto = productos.id_producto
WHERE ventas.fecha BETWEEN '2023-01-01' AND '2023-01-31'
GROUP BY productos.nombre;

Usa el código con precaución.

Estructura de una Consulta SQL típica:
SQL

SELECT columna1, columna2, ...
FROM tabla1
INNER JOIN tabla2 ON tabla1.id = tabla2.id  -- Ejemplo de unión
WHERE condición
GROUP BY columna_agrupación
ORDER BY columna_ordenación;

Usa el código con precaución.

Claves para escribir buenas consultas SQL:

    Sé específico: Indica claramente qué datos quieres obtener.
    Utiliza alias: Asigna nombres cortos y descriptivos a las columnas y tablas para mejorar la legibilidad.
    Agrupa y ordena: Utiliza las cláusulas GROUP BY y ORDER BY para organizar los resultados de la consulta.
    Utiliza funciones de agregación: SUM, AVG, COUNT, MIN, MAX para realizar cálculos sobre los datos.
    Optimiza tus consultas: Utiliza índices para acelerar la ejecución de consultas que involucran grandes volúmenes de datos.

Una vez que me proporciones más detalles sobre tus necesidades específicas, podré ayudarte a crear las consultas SQL exactas que necesitas.

Por favor, responde a las siguientes preguntas:

    ¿Qué tipo de informes o análisis deseas realizar con los datos?
    ¿Qué métricas son importantes para tu negocio?
    ¿Hay alguna restricción de rendimiento o escalabilidad?

Con esta información, podremos trabajar juntos para crear un conjunto completo de consultas SQL que te permitan obtener la información que necesitas de manera eficiente y precisa.
foto de perfil

a todas tus sugerencias agrega el perfume más vendido y escribe todo el código sql

¡Absolutamente! Vamos a crear algunas consultas SQL que te permitan obtener información detallada sobre las ventas, incluyendo el perfume más vendido.

Consideraciones adicionales:

    Tabla de productos: Asumiremos que tienes una tabla productos con al menos los campos id_producto y nombre.
    Tabla de ventas_detalle: Esta tabla detallará las ventas, incluyendo la cantidad vendida de cada producto por venta. Tendremos los campos id_venta_detalle, cantidad, id_venta (FK a la tabla ventas) y id_producto (FK a la tabla productos).

Consultas SQL:

    Perfume más vendido en general:
    SQL

    SELECT p.nombre AS perfume, SUM(vd.cantidad) AS total_vendido
    FROM ventas_detalle vd
    INNER JOIN productos p ON vd.id_producto = p.id_producto
    GROUP BY p.nombre
    ORDER BY total_vendido DESC
    LIMIT 1;

    Usa el código con precaución.

Esta consulta te dará el nombre del perfume y la cantidad total vendida. El LIMIT 1 asegura que solo se muestre el primer resultado (el perfume más vendido).

Perfume más vendido por mes:
SQL

SELECT p.nombre, EXTRACT(MONTH FROM v.fecha) AS mes, SUM(vd.cantidad) AS total_vendido
FROM ventas v
INNER JOIN ventas_detalle vd ON v.id_venta = vd.id_venta
INNER JOIN productos p ON vd.id_producto = p.id_producto
GROUP BY p.nombre, EXTRACT(MONTH FROM v.fecha)
ORDER BY total_vendido DESC;

Usa el código con precaución.

Esta consulta te dará el perfume más vendido por cada mes. La función EXTRACT(MONTH FROM v.fecha) te permite agrupar los datos por mes.

Top 5 perfumes más vendidos por año:
SQL

SELECT p.nombre, EXTRACT(YEAR FROM v.fecha) AS año, SUM(vd.cantidad) AS total_vendido
FROM ventas v
INNER JOIN ventas_detalle vd ON v.id_venta = vd.id_venta
INNER JOIN productos p ON vd.id_producto = p.id_producto
GROUP BY p.nombre, EXTRACT(YEAR FROM v.fecha)
ORDER BY año, total_vendido DESC
LIMIT 5;

Usa el código con precaución.

    Esta consulta te dará los 5 perfumes más vendidos por cada año.

Personalizando las consultas:

    Rango de fechas: Puedes agregar una cláusula WHERE para filtrar las ventas por un rango de fechas específico.
    Agrupación por vendedor: Si quieres conocer el perfume más vendido por vendedor, agrega id_vendedor a la cláusula GROUP BY.
    Otros criterios: Puedes agregar más condiciones a la cláusula WHERE para filtrar los resultados según tus necesidades (e.g., por zona geográfica, tipo de cliente, etc.).

Ejemplo con rango de fechas y agrupación por vendedor:
SQL

SELECT p.nombre, v.id_vendedor, EXTRACT(YEAR FROM v.fecha) AS año, SUM(vd.cantidad) AS total_vendido
FROM ventas v
INNER JOIN ventas_detalle vd ON v.id_venta = vd.id_venta
INNER JOIN productos p ON vd.id_producto = p.id_producto
WHERE v.fecha BETWEEN '2023-01-01' AND '2023-12-31'
GROUP BY p.nombre, v.id_vendedor, EXTRACT(YEAR FROM v.fecha)
ORDER BY año, total_vendido DESC;

Usa el código con precaución.

Consideraciones adicionales para Python y SQLAlchemy:

    Ejecutar las consultas: Utiliza el método session.execute() para ejecutar las consultas SQL.
    Obtener los resultados: Utiliza el método fetchall() para obtener todos los resultados de la consulta.
    Procesar los resultados: Puedes utilizar bucles o pandas para procesar los resultados y generar informes o gráficos.

¿Necesitas más ejemplos o tienes alguna otra pregunta?

Recuerda:

    Adapta las consultas a tu esquema de base de datos: Asegúrate de que los nombres de las tablas y columnas coincidan con tu estructura.
    Utiliza índices: Crea índices en las columnas que se utilizan frecuentemente en las cláusulas WHERE, JOIN y GROUP BY para mejorar el rendimiento de las consultas.

Con estas consultas y consejos, podrás obtener información valiosa sobre las ventas de tus perfumes y tomar decisiones más informadas para tu negocio.
foto de perfil

excelente, escribe las tablas y las funciones todas juntas y completas para empezar la base de datos

¡Absolutamente! Aquí te presento un conjunto completo de tablas y funciones SQL para una base de datos de una perfumería, incluyendo las consultas que hemos discutido anteriormente. He asumido algunas estructuras y relaciones, pero puedes personalizarlas según tus necesidades específicas.

Estructura de la base de datos:
SQL

CREATE TABLE clientes (
    id_cliente SERIAL PRIMARY KEY,
    nombre VARCHAR(100),
    apellido VARCHAR(100),
    cedula VARCHAR(20),
    direccion TEXT,
    telefono VARCHAR(20),
    zona VARCHAR(50)
);

CREATE TABLE productos (
    id_producto SERIAL PRIMARY KEY,
    nombre VARCHAR(100),
    precio NUMERIC(10,2),
    categoria VARCHAR(50)
);

CREATE TABLE ventas (
    id_venta SERIAL PRIMARY KEY,
    fecha DATE,
    total NUMERIC(10,2),
    id_cliente INTEGER REFERENCES clientes(id_cliente),
    id_vendedor INTEGER REFERENCES vendedores(id_vendedor)
);

CREATE TABLE ventas_detalle (
    id_venta_detalle SERIAL PRIMARY KEY,
    cantidad INTEGER,
    id_venta INTEGER REFERENCES ventas(id_venta),
    id_producto INTEGER REFERENCES productos(id_producto)
);

CREATE TABLE vendedores (
    id_vendedor SERIAL PRIMARY KEY,
    nombre VARCHAR(100),
    apellido VARCHAR(100),
    comision NUMERIC(10,2)
);

Usa el código con precaución.

Funciones para calcular métricas:
SQL

-- Función para obtener el perfume más vendido en un rango de fechas
CREATE OR REPLACE FUNCTION perfume_mas_vendido(fecha_inicio DATE, fecha_fin DATE)
RETURNS TABLE (perfume VARCHAR, total_vendido NUMERIC) AS $$
BEGIN
  RETURN QUERY
  SELECT p.nombre, SUM(vd.cantidad) AS total_vendido
  FROM ventas v
  INNER JOIN ventas_detalle vd ON v.id_venta = vd.id_venta
  INNER JOIN productos p ON vd.id_producto = p.id_producto
  WHERE v.fecha BETWEEN fecha_inicio AND fecha_fin
  GROUP BY p.nombre
  ORDER BY total_vendido DESC
  LIMIT 1;
END;
$$ LANGUAGE plpgsql;

-- Función para obtener los top N perfumes vendidos por año
CREATE OR REPLACE FUNCTION top_perfumes_por_ano(ano INTEGER, n INTEGER)
RETURNS TABLE (perfume VARCHAR, total_vendido NUMERIC) AS $$
BEGIN
  RETURN QUERY
  SELECT p.nombre, SUM(vd.cantidad) AS total_vendido
  FROM ventas v
  INNER JOIN ventas_detalle vd ON v.id_venta = vd.id_venta
  INNER JOIN productos p ON vd.id_producto = p.id_producto
  WHERE EXTRACT(YEAR FROM v.fecha) = ano
  GROUP BY p.nombre
  ORDER BY total_vendido DESC
  LIMIT n;
END;
$$ LANGUAGE plpgsql;

Usa el código con precaución.

Uso de las funciones:
SQL

-- Ejemplo: Obtener el perfume más vendido en 2023
SELECT * FROM perfume_mas_vendido('2023-01-01', '2023-12-31');

-- Ejemplo: Obtener los 3 perfumes más vendidos en 2022
SELECT * FROM top_perfumes_por_ano(2022, 3);

Usa el código con precaución.

Explicación:

    Tablas: Hemos definido las tablas básicas para una perfumería, incluyendo clientes, productos, ventas, detalles de ventas y vendedores.
    Funciones:
        perfume_mas_vendido: Calcula el perfume más vendido en un rango de fechas especificado.
        top_perfumes_por_ano: Devuelve los N perfumes más vendidos en un año determinado.
    Uso de las funciones: Puedes llamar a estas funciones en tus consultas SQL para obtener los resultados deseados.

Personalización:

    Campos adicionales: Agrega campos como fecha_nacimiento en la tabla clientes, descuento en la tabla productos, etc.
    Relaciones adicionales: Puedes agregar relaciones entre tablas para representar conceptos como proveedores, marcas, etc.
    Funciones adicionales: Crea funciones para calcular métricas más complejas, como el valor promedio de una venta o el número de clientes por zona.
    Índices: Crea índices en las columnas que se utilizan frecuentemente en las cláusulas WHERE, JOIN y GROUP BY para mejorar el rendimiento de las consultas.

Recuerda:

    Adapta este esquema a tus necesidades específicas.
    Utiliza un diagrama de entidad-relación (ERD) para visualizar mejor las relaciones entre las tablas.
    Optimiza las consultas: Utiliza las herramientas de tu sistema de base de datos para analizar el rendimiento de las consultas y realizar ajustes si es necesario.

Próximos pasos:

    Crear la base de datos: Utiliza una herramienta como pgAdmin o el cliente de línea de comandos de PostgreSQL para crear la base de datos y ejecutar los scripts SQL.
    Poblar la base de datos: Ingresa datos de muestra o utiliza un script para importar datos de una fuente externa.
    Crear aplicaciones: Utiliza un lenguaje de programación como Python y un ORM como SQLAlchemy para interactuar con la base de datos y crear aplicaciones que permitan a los usuarios realizar consultas, generar informes y realizar otras tareas.

--Creación de la Base de Datos
CREATE DATABASE Gabriela_Fragancias;

--Tabla Zonas
CREATE TABLE Zonas (
    id_zona SERIAL PRIMARY KEY,
    nombre_zona VARCHAR(100) NOT NULL UNIQUE
);

--Tabla Clientes
CREATE TABLE Clientes (
    id_cliente SERIAL PRIMARY KEY,
    cedula VARCHAR(20) UNIQUE NOT NULL,
    nombre VARCHAR(100) NOT NULL,
    apellido VARCHAR(100) NOT NULL,
    telefono VARCHAR(20),
    direccion TEXT,
    email VARCHAR(100),
    ruc VARCHAR(20) UNIQUE,
    fecha_registro DATE DEFAULT CURRENT_DATE
);

--Tabla Vendedores
CREATE TABLE Vendedores (
    id_vendedor SERIAL PRIMARY KEY,
    nombre VARCHAR(100) NOT NULL,
    zona VARCHAR(50) NOT NULL,
    comision DECIMAL(10, 2) DEFAULT 50000
);

--Tabla Tarjetas
CREATE TABLE Tarjetas (
    id_tarjeta SERIAL PRIMARY KEY,
    numero_tarjeta VARCHAR(7) NOT NULL,
    id_cliente INTEGER REFERENCES Clientes(id_cliente),
    id_vendedor INTEGER REFERENCES Vendedores(id_vendedor),
    id_zona INTEGER REFERENCES Zonas(id_zona),
    total_gs DECIMAL(10, 2) NOT NULL,
    saldo DECIMAL(10, 2) DEFAULT 0,
    forma_pago VARCHAR(20) CHECK (forma_pago IN ('SEM', 'QUIN', 'MENS')),
    estado VARCHAR(20) CHECK (estado IN ('activa', 'cancelada')) DEFAULT 'activa',
    fecha_emision DATE DEFAULT CURRENT_DATE,
    id_tarjeta_anterior INTEGER REFERENCES Tarjetas(id_tarjeta)
);

--Tabla de Productos
CREATE TABLE Productos (
    id_producto SERIAL PRIMARY KEY,
    nombre VARCHAR(100) NOT NULL,
    codigo_barras VARCHAR(13) UNIQUE NOT NULL,
    precio_costo DECIMAL(10, 2),
    precio_venta DECIMAL(10, 2),
    stock INTEGER DEFAULT 0,
    descripcion TEXT
);

--Tabla Productos Vendidos
CREATE TABLE Productos_Vendidos (
    id_producto_vendido SERIAL PRIMARY KEY,
    id_tarjeta INTEGER REFERENCES Tarjetas(id_tarjeta),
    id_producto INTEGER REFERENCES Productos(id_producto),
    cantidad INTEGER CHECK (cantidad > 0),
    precio DECIMAL(10, 2)
);

--Tabla Pagos
CREATE TABLE Pagos (
    id_pago SERIAL PRIMARY KEY,
    id_tarjeta INTEGER REFERENCES Tarjetas(id_tarjeta),
    fecha_pago DATE DEFAULT CURRENT_DATE,
    monto DECIMAL(10, 2) NOT NULL,
    saldo_restante DECIMAL(10, 2) NOT NULL,
    entrega_inicial BOOLEAN DEFAULT FALSE,
    recargo BOOLEAN DEFAULT FALSE
);

--Tabla Antecedentes Judiciales
CREATE TABLE Antecedentes_Judiciales (
    id_antecedente SERIAL PRIMARY KEY,
    cedula VARCHAR(20) REFERENCES Clientes(cedula),
    causa_penal TEXT
);

--Tabla de Inventario (Maletines de Productos)
CREATE TABLE Inventario (
    id_inventario SERIAL PRIMARY KEY,
    id_vendedor INTEGER REFERENCES Vendedores(id_vendedor),
    id_producto INTEGER REFERENCES Productos(id_producto),
    cantidad INTEGER NOT NULL
);

--Tabla de Rutas
CREATE TABLE Rutas (
    id_ruta SERIAL PRIMARY KEY,
    id_vendedor INTEGER REFERENCES Vendedores(id_vendedor),
    id_zona INTEGER REFERENCES Zonas(id_zona),
    fecha DATE DEFAULT CURRENT_DATE,
    coordenadas GEOGRAPHY(POINT, 4326)  -- Integración con GIS
);

--Triggers y Funciones
CREATE OR REPLACE FUNCTION actualizar_saldo_cliente() 
RETURNS TRIGGER AS $$
BEGIN
    UPDATE Tarjetas 
    SET saldo = saldo - NEW.monto
    WHERE id_tarjeta = NEW.id_tarjeta;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

--Trigger para actualizar saldo tras un pago:
CREATE TRIGGER tg_actualizar_saldo
AFTER INSERT ON Pagos
FOR EACH ROW
EXECUTE FUNCTION actualizar_saldo_cliente();

--Función para actualizar inventario tras una venta:
CREATE OR REPLACE FUNCTION actualizar_inventario() 
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.cantidad > (SELECT stock FROM Productos WHERE id_producto = NEW.id_producto) THEN
        RAISE EXCEPTION 'No hay suficiente stock para este producto';
    ELSE
        UPDATE Productos 
        SET stock = stock - NEW.cantidad 
        WHERE id_producto = NEW.id_producto;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

--Trigger para actualizar inventario tras una venta:
CREATE TRIGGER tg_actualizar_inventario
AFTER INSERT ON Productos_Vendidos
FOR EACH ROW
EXECUTE FUNCTION actualizar_inventario();

--Vista para Reportes de Ventas
CREATE VIEW VW_Ventas_Por_Cliente AS
SELECT 
    c.id_cliente, 
    c.nombre, 
    c.apellido, 
    COUNT(v.id_tarjeta) AS total_ventas, 
    SUM(v.total_gs) AS monto_total
FROM 
    Clientes c
JOIN 
    Tarjetas v ON c.id_cliente = v.id_cliente
GROUP BY 
    c.id_cliente;

--Optimización con Índices
CREATE INDEX idx_tarjetas_cliente ON Tarjetas(id_cliente);
CREATE INDEX idx_productos_codigo_barras ON Productos(codigo_barras);
CREATE INDEX idx_pagos_fecha ON Pagos(fecha_pago);
CREATE INDEX idx_rutas_vendedor_fecha ON Rutas(id_vendedor, fecha);
CREATE INDEX idx_pagos_cliente_metodo ON Pagos(id_cliente, metodo_pago);
CREATE INDEX idx_antecedentes_cedula ON AntecedentesJudiciales(cedula);
CREATE INDEX idx_inventario_maletines_producto ON Inventario_Maletines(id_maletin, id_producto);
CREATE INDEX idx_vehiculos_motor_chasis_placa ON Vehiculos(numero_motor, numero_chasis, placa);
-- Tabla Personas (con alerta de defunción)
CREATE TABLE Personas (
    id_persona SERIAL PRIMARY KEY,
    cedula VARCHAR(20) UNIQUE NOT NULL,
    nombre VARCHAR(100) NOT NULL,
    apellido VARCHAR(100) NOT NULL,
    fecha_nacimiento DATE,
    direccion TEXT,
    departamento VARCHAR(100),
    distrito_municipio VARCHAR(100),
    barrio_localidad VARCHAR(100),
    zona VARCHAR(100),
    telefono VARCHAR(20),
    email VARCHAR(100) UNIQUE,
    fecha_defuncion DATE,  -- Campo para gestionar defunciones
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
);

-- Trigger para alerta de defunción
CREATE OR REPLACE FUNCTION verificar_defuncion() 
RETURNS TRIGGER AS $$
BEGIN
    IF (NEW.fecha_defuncion IS NOT NULL) THEN
        RAISE NOTICE 'La persona con cédula % ha sido marcada como fallecida.', NEW.cedula;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tg_verificar_defuncion
AFTER INSERT OR UPDATE ON Personas
FOR EACH ROW
EXECUTE FUNCTION verificar_defuncion();

-- Tabla Clientes
CREATE TABLE Clientes (
    id_cliente SERIAL PRIMARY KEY,
    id_persona INTEGER REFERENCES Personas(id_persona),
    tarjeta VARCHAR(7) UNIQUE NOT NULL,  -- Número de tarjeta obligatorio y único
    saldo DECIMAL(10, 2) DEFAULT 0,
    tipo_pago VARCHAR(20) CHECK (tipo_pago IN ('SEM', 'QUIN', 'MENS')),
    fecha_registro DATE DEFAULT CURRENT_DATE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- Tabla Marcas
CREATE TABLE Marcas (
    id_marca SERIAL PRIMARY KEY,
    nombre VARCHAR(100) UNIQUE NOT NULL,
    año_fundacion INT
);

-- Tabla Productos
CREATE TABLE Productos (
    id_producto SERIAL PRIMARY KEY,
    codigo_barras VARCHAR(50) UNIQUE NOT NULL,
    nombre VARCHAR(100) NOT NULL,
    id_marca INTEGER REFERENCES Marcas(id_marca),
    precio_contado DECIMAL(10, 2) NOT NULL,
    precio_credito DECIMAL(10, 2) NOT NULL,
    stock INTEGER NOT NULL,
    descripcion TEXT,
    presentacion VARCHAR(50),
    volumen INT CHECK (volumen BETWEEN 5 AND 200),
    es_kit BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- Trigger para actualizar el stock de productos después de una venta
CREATE OR REPLACE FUNCTION actualizar_stock_producto() 
RETURNS TRIGGER AS $$
BEGIN
    IF (NEW.cantidad > (SELECT stock FROM Productos WHERE id_producto = NEW.id_producto)) THEN
        RAISE EXCEPTION 'No hay suficiente stock para este producto';
    ELSE
        UPDATE Productos 
        SET stock = stock - NEW.cantidad 
        WHERE id_producto = NEW.id_producto;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tg_actualizar_stock
AFTER INSERT ON Ventas
FOR EACH ROW
EXECUTE FUNCTION actualizar_stock_producto();

-- Tabla Ventas
CREATE TABLE Ventas (
    id_venta SERIAL PRIMARY KEY,
    id_cliente INTEGER REFERENCES Clientes(id_cliente),
    id_producto INTEGER REFERENCES Productos(id_producto),
    fecha DATE DEFAULT CURRENT_DATE,
    forma_pago VARCHAR(20) CHECK (forma_pago IN ('Contado', 'Crédito')),
    total DECIMAL(10, 2) NOT NULL,
    saldo DECIMAL(10, 2) DEFAULT 0,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- Trigger para actualizar el saldo de los clientes tras una venta
CREATE OR REPLACE FUNCTION actualizar_saldo_cliente() 
RETURNS TRIGGER AS $$
BEGIN
    UPDATE Clientes 
    SET saldo = saldo - NEW.total
    WHERE id_cliente = NEW.id_cliente;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tg_actualizar_saldo
AFTER INSERT ON Ventas
FOR EACH ROW
EXECUTE FUNCTION actualizar_saldo_cliente();

-- Tabla Pagos
CREATE TABLE Pagos (
    id_pago SERIAL PRIMARY KEY,
    id_cliente INTEGER REFERENCES Clientes(id_cliente),
    id_venta INTEGER REFERENCES Ventas(id_venta),
    fecha_pago DATE DEFAULT CURRENT_DATE,
    monto DECIMAL(10, 2) NOT NULL,
    metodo_pago VARCHAR(20) CHECK (metodo_pago IN ('Efectivo', 'Tarjeta', 'Transferencia')),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- Tabla Detalles de Venta
CREATE TABLE Detalles_Venta (
    id_detalle SERIAL PRIMARY KEY,
    id_venta INTEGER REFERENCES Ventas(id_venta) ON DELETE CASCADE,
    id_producto INTEGER REFERENCES Productos(id_producto),
    cantidad INTEGER NOT NULL,
    precio_unitario DECIMAL(10, 2),
    subtotal DECIMAL(10, 2) GENERATED ALWAYS AS (cantidad * precio_unitario) STORED,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- Tabla Vehiculos
CREATE TABLE Vehiculos (
    id_vehiculo SERIAL PRIMARY KEY,
    placa VARCHAR(20) UNIQUE NOT NULL,  -- Número de placa obligatorio y único
    marca VARCHAR(50),
    modelo VARCHAR(50),
    año INT,
    numero_motor VARCHAR(50) UNIQUE,  -- Número de motor obligatorio y único
    numero_chasis VARCHAR(50) UNIQUE, -- Número de chasis obligatorio y único
    fecha_revision DATE,  -- Fecha de última revisión técnica
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- Tabla Rutas (para vendedores y manejo de geolocalización)
CREATE TABLE Rutas (
    id_ruta SERIAL PRIMARY KEY,
    id_vendedor INTEGER REFERENCES Vendedores(id_vendedor),
    nombre_ruta VARCHAR(100) NOT NULL,
    fecha DATE DEFAULT CURRENT_DATE,
    coordenadas GEOGRAPHY(POLYGON, 4326),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- Tabla Inventario_Maletines (para manejar los productos en los maletines de vendedoras)
CREATE TABLE Inventario_Maletines (
    id_inventario SERIAL PRIMARY KEY,
    id_maletin INTEGER REFERENCES Maletines(id_maletin),
    id_producto INTEGER REFERENCES Productos(id_producto),
    cantidad INTEGER NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- Tabla Maletines (gestión de los maletines de las vendedoras)
CREATE TABLE Maletines (
    id_maletin SERIAL PRIMARY KEY,
    id_vendedor INTEGER REFERENCES Vendedores(id_vendedor),
    fecha_carga DATE DEFAULT CURRENT_DATE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- Tabla AntecedentesJudiciales (para verificar los antecedentes de los clientes)
CREATE TABLE AntecedentesJudiciales (
    id_antecedente SERIAL PRIMARY KEY,
    cedula VARCHAR(20) REFERENCES Personas(cedula),
    causa_penal TEXT
);

-- Trigger para verificar si un cliente tiene antecedentes judiciales
CREATE OR REPLACE FUNCTION verificar_antecedentes() 
RETURNS TRIGGER AS $$
BEGIN
    IF EXISTS (SELECT 1 FROM AntecedentesJudiciales WHERE cedula = NEW.cedula) THEN
        RAISE NOTICE 'El cliente con cédula % tiene antecedentes judiciales', NEW.cedula;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tg_verificar_antecedentes
BEFORE INSERT ON Clientes
FOR EACH ROW
EXECUTE FUNCTION verificar_antecedentes();

-- Trigger para actualizar la comisión de las vendedoras tras una venta
CREATE OR REPLACE FUNCTION actualizar_comision_vendedora() 
RETURNS TRIGGER AS $$
BEGIN
    UPDATE Liquidaciones 
    SET total_ventas = total_ventas + NEW.total,
        comision = comision + (50000 * NEW.cantidad)  -- Comisión por producto
    WHERE id_vendedor = NEW.id_vendedor;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tg_actualizar_comision
AFTER INSERT ON Ventas
FOR EACH ROW
EXECUTE FUNCTION actualizar_comision_vendedora();

-- Índices faltantes para optimización de consultas
CREATE INDEX idx_rutas_vendedor_fecha ON Rutas(id_vendedor, fecha);
CREATE INDEX idx_pagos_cliente_metodo ON Pagos(id_cliente, metodo_pago);
CREATE INDEX idx_antecedentes_cedula ON AntecedentesJudiciales(cedula);
CREATE INDEX idx_inventario_maletines_producto ON Inventario_Maletines(id_maletin, id_producto);
CREATE INDEX idx_vehiculos_motor_chasis_placa ON Vehiculos(numero_motor, numero_chasis, placa);


-- Relaciones Clave

Clientes y Personas: La tabla personas puede utilizarse para almacenar información adicional sobre las personas, como sus cédulas y contactos. Los clientes pueden estar relacionados con personas si hay un esquema más complejo.
Rutas y Vehículos: Los vendedores pueden estar asignados a rutas, y cada ruta puede tener asociado un vehículo para facilitar la movilidad y el seguimiento GPS.
Antecedentes Judiciales: Se verifica si los clientes tienen antecedentes judiciales antes de ser ingresados, lo que podría afectar las decisiones comerciales.
Geolocalización: Las rutas están asociadas con zonas geográficas (ciudades, municipios, departamentos) para un mejor control territorial.
A ESTA TABLA QUISIERA INGRESAR UNA COLUMNA PARA LA IMAGEN DEL LOGOTIPO
Y UNA SENTENCIA SQL
CON el RUC 4974638-3
razón social Gabriela Fragancias 

-- Tabla Empresa
CREATE TABLE Empresa (
    id_empresa SERIAL PRIMARY KEY,
    ruc VARCHAR(20) UNIQUE NOT NULL,
    razon_social VARCHAR(100) NOT NULL
	logotipo BYTEA;
);

-- Insertar los datos de la empresa con logotipo
INSERT INTO Empresa (ruc, razon_social, logotipo)
VALUES ('4974638-3', 'Gabriela Fragancias', pg_read_binary_file("D:\Gabriela Fragancias\Datos\Diseños\Gabriela Fragancias (logo torre).png"));



-- Consulta de Clientes con Antecedentes Judiciales

SELECT p.nombre, p.apellido, a.causa_penal
FROM personas p
INNER JOIN antecedentes_judiciales a ON p.cedula = a.numero_ci;

-- Consulta de Vehículos Asignados a Vendedores

SELECT v.nombre, v.apellido, veh.marca, veh.modelo, veh.placa
FROM vendedores v
INNER JOIN rutas r ON v.id_vendedor = r.id_vendedor
INNER JOIN vehiculos veh ON r.id_vehiculo = veh.id_vehiculo;

-- Consulta de Geolocalización de Vehículos

SELECT veh.placa, t.latitud, t.longitud, t.fecha_hora
FROM vehiculos veh
INNER JOIN tracking_gps t ON veh.id_vehiculo = t.id_vehiculo
ORDER BY t.fecha_hora DESC;
--Creación de la Base de Datos
CREATE DATABASE Gabriela_Fragancias;

--Tabla Zonas
CREATE TABLE Zonas (
    id_zona SERIAL PRIMARY KEY,
    nombre_zona VARCHAR(100) NOT NULL UNIQUE
);

--Tabla Clientes
CREATE TABLE Clientes (
    id_cliente SERIAL PRIMARY KEY,
    cedula VARCHAR(20) UNIQUE NOT NULL,
    nombre VARCHAR(100) NOT NULL,
    apellido VARCHAR(100) NOT NULL,
    telefono VARCHAR(20),
    direccion TEXT,
    email VARCHAR(100),
    ruc VARCHAR(20) UNIQUE,
    fecha_registro DATE DEFAULT CURRENT_DATE
);

--Tabla Vendedores
CREATE TABLE Vendedores (
    id_vendedor SERIAL PRIMARY KEY,
    nombre VARCHAR(100) NOT NULL,
    zona VARCHAR(50) NOT NULL,
    comision DECIMAL(10, 2) DEFAULT 50000
);

--Tabla Tarjetas
CREATE TABLE Tarjetas (
    id_tarjeta SERIAL PRIMARY KEY,
    numero_tarjeta VARCHAR(7) NOT NULL,
    id_cliente INTEGER REFERENCES Clientes(id_cliente),
    id_vendedor INTEGER REFERENCES Vendedores(id_vendedor),
    id_zona INTEGER REFERENCES Zonas(id_zona),
    total_gs DECIMAL(10, 2) NOT NULL,
    saldo DECIMAL(10, 2) DEFAULT 0,
    forma_pago VARCHAR(20) CHECK (forma_pago IN ('SEM', 'QUIN', 'MENS')),
    estado VARCHAR(20) CHECK (estado IN ('activa', 'cancelada')) DEFAULT 'activa',
    fecha_emision DATE DEFAULT CURRENT_DATE,
    id_tarjeta_anterior INTEGER REFERENCES Tarjetas(id_tarjeta)
);

--Tabla de Productos
CREATE TABLE Productos (
    id_producto SERIAL PRIMARY KEY,
    nombre VARCHAR(100) NOT NULL,
    codigo_barras VARCHAR(13) UNIQUE NOT NULL,
    precio_costo DECIMAL(10, 2),
    precio_venta DECIMAL(10, 2),
    stock INTEGER DEFAULT 0,
    descripcion TEXT
);

--Tabla Productos Vendidos
CREATE TABLE Productos_Vendidos (
    id_producto_vendido SERIAL PRIMARY KEY,
    id_tarjeta INTEGER REFERENCES Tarjetas(id_tarjeta),
    id_producto INTEGER REFERENCES Productos(id_producto),
    cantidad INTEGER CHECK (cantidad > 0),
    precio DECIMAL(10, 2)
);

--Tabla Pagos
CREATE TABLE Pagos (
    id_pago SERIAL PRIMARY KEY,
    id_tarjeta INTEGER REFERENCES Tarjetas(id_tarjeta),
    fecha_pago DATE DEFAULT CURRENT_DATE,
    monto DECIMAL(10, 2) NOT NULL,
    saldo_restante DECIMAL(10, 2) NOT NULL,
    entrega_inicial BOOLEAN DEFAULT FALSE,
    recargo BOOLEAN DEFAULT FALSE
);

--Tabla Antecedentes Judiciales
CREATE TABLE Antecedentes_Judiciales (
    id_antecedente SERIAL PRIMARY KEY,
    cedula VARCHAR(20) REFERENCES Clientes(cedula),
    causa_penal TEXT
);

--Tabla de Inventario (Maletines de Productos)
CREATE TABLE Inventario (
    id_inventario SERIAL PRIMARY KEY,
    id_vendedor INTEGER REFERENCES Vendedores(id_vendedor),
    id_producto INTEGER REFERENCES Productos(id_producto),
    cantidad INTEGER NOT NULL
);

--Tabla de Rutas
CREATE TABLE Rutas (
    id_ruta SERIAL PRIMARY KEY,
    id_vendedor INTEGER REFERENCES Vendedores(id_vendedor),
    id_zona INTEGER REFERENCES Zonas(id_zona),
    fecha DATE DEFAULT CURRENT_DATE,
    coordenadas GEOGRAPHY(POINT, 4326)  -- Integración con GIS
);

--Triggers y Funciones
CREATE OR REPLACE FUNCTION actualizar_saldo_cliente() 
RETURNS TRIGGER AS $$
BEGIN
    UPDATE Tarjetas 
    SET saldo = saldo - NEW.monto
    WHERE id_tarjeta = NEW.id_tarjeta;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

--Trigger para actualizar saldo tras un pago:
CREATE TRIGGER tg_actualizar_saldo
AFTER INSERT ON Pagos
FOR EACH ROW
EXECUTE FUNCTION actualizar_saldo_cliente();

--Función para actualizar inventario tras una venta:
CREATE OR REPLACE FUNCTION actualizar_inventario() 
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.cantidad > (SELECT stock FROM Productos WHERE id_producto = NEW.id_producto) THEN
        RAISE EXCEPTION 'No hay suficiente stock para este producto';
    ELSE
        UPDATE Productos 
        SET stock = stock - NEW.cantidad 
        WHERE id_producto = NEW.id_producto;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

--Trigger para actualizar inventario tras una venta:
CREATE TRIGGER tg_actualizar_inventario
AFTER INSERT ON Productos_Vendidos
FOR EACH ROW
EXECUTE FUNCTION actualizar_inventario();

--13. Vista para Reportes de Ventas
CREATE VIEW VW_Ventas_Por_Cliente AS
SELECT 
    c.id_cliente, 
    c.nombre, 
    c.apellido, 
    COUNT(v.id_tarjeta) AS total_ventas, 
    SUM(v.total_gs) AS monto_total
FROM 
    Clientes c
JOIN 
    Tarjetas v ON c.id_cliente = v.id_cliente
GROUP BY 
    c.id_cliente;

--14. Optimización con Índices
CREATE INDEX idx_tarjetas_cliente ON Tarjetas(id_cliente);
CREATE INDEX idx_productos_codigo_barras ON Productos(codigo_barras);
CREATE INDEX idx_pagos_fecha ON Pagos(fecha_pago);
CREATE INDEX idx_rutas_vendedor_fecha ON Rutas(id_vendedor, fecha);
CREATE INDEX idx_pagos_cliente_metodo ON Pagos(id_cliente, metodo_pago);
CREATE INDEX idx_antecedentes_cedula ON AntecedentesJudiciales(cedula);
CREATE INDEX idx_inventario_maletines_producto ON Inventario_Maletines(id_maletin, id_producto);
CREATE INDEX idx_vehiculos_motor_chasis_placa ON Vehiculos(numero_motor, numero_chasis, placa);

ANALIZA TODO EL DOCUMENTO Y enfócate en especial en la tarjeta, de ella depende todo el negocio y para la base de datos deberíamos centrarnos en reproducirla y tener tablas accesorias a ella, número de tarjeta, celular, cómo cédula, antecedentes, barrios, municipios, referencias, los pagos (SEM, QUIN, MENS), fechas y montos, la venta que se da en ella y los recargos, la cédula y firma del cliente y guiarme a importar todos los datos de las dbf
ChatGPT Plus
ChatGPT

El documento que has proporcionado detalla una estructura completa de base de datos que incluye tablas esenciales para clientes, productos, ventas, pagos, rutas, antecedentes judiciales, y otros elementos relevantes. Específicamente para la tarjeta, se describe la siguiente información fundamental:

    Número de tarjeta: clave única para identificar cada tarjeta.
    Datos del cliente: nombre, dirección, teléfono, y otros detalles que provienen de la base de datos de cédulas y RUC.
    Zona y rutas: las ciudades y barrios donde se realizan las ventas están organizadas por zonas.
    Datos de venta: incluye el producto vendido, el vendedor, el cliente, el monto total de la venta, y la forma de pago (semanal, quincenal o mensual).
    Pagos: columna que registra el saldo de la tarjeta y los montos pagados.
    Recargos: se añade al saldo cuando se realiza una nueva venta sin entrega inicial.
    Control administrativo: una columna de control para registrar la verificación administrativa con la fecha de revisión.
    Cédula y firma del cliente: utilizada como contrato y pagaré del cliente.

El sistema de la tarjeta es crucial para manejar no solo las ventas y los pagos, sino también los datos geográficos de clientes y rutas, las zonas de ventas diarias y el control del inventario de productos en maletines, con liquidaciones a las vendedoras por cada producto vendido.
Propuesta para Base de Datos y Tablas Relacionadas a la Tarjeta

Para implementar esta lógica en la base de datos, se podrían crear las siguientes tablas o expandir las ya mencionadas:

    Tarjetas
        id_tarjeta (clave primaria)
        id_cliente (relación con la tabla Clientes)
        id_vendedor (relación con la tabla Vendedores)
        zona (relación con la tabla Zonas)
        total_gs (monto total de la venta)
        saldo (saldo pendiente de pago)
        forma_pago (SEM, QUIN, MENS)
        estado (activa, cancelada)
        fecha_emision

    Pagos
        id_pago (clave primaria)
        id_tarjeta (relación con Tarjetas)
        fecha_pago
        monto
        saldo_restante
        entrega_inicial (booleano para indicar si hubo entrega)
        recargo (booleano para indicar si hay una nueva venta)

    Productos Vendidos
        id_producto_vendido (clave primaria)
        id_tarjeta (relación con Tarjetas)
        id_producto (relación con Productos)
        cantidad
        precio

    Rutas
        id_ruta (clave primaria)
        id_vendedor
        zona
        fecha_ruta
        coordenadas (datos geográficos de GIS)

    Antecedentes Judiciales
        id_antecedente
        cedula (relación con la tabla Cedula)
        causa_penal
        fecha_registro

Importación de Datos desde DBF

Se puede seguir el flujo que mencionaste para extraer e importar datos de archivos DBF. Te propongo usar pandas para realizar esta extracción y limpieza de datos, ya que permite gestionar grandes cantidades de información y realizar las validaciones necesarias como el formato correcto de cédulas o RUC, identificación de clientes con antecedentes, y correlación de zonas.
Pasos Propuestos:

    Extracción de datos: Importar los datos de cédulas, RUC, antecedentes judiciales, ventas, etc.
    Limpieza de datos: Validar los campos clave como el número de cédula, RUC y correlación geográfica (barrios, zonas).
    Unificación: Relacionar las tablas mediante identificadores como cédula o tarjeta para generar una vista coherente de cliente y ventas.
    Automatización: Crear triggers para actualizar el saldo de la tarjeta, gestionar recargos y pagos parciales, y verificar antecedentes judiciales automáticamente al registrar un nuevo cliente.

Este esquema permitirá una integración eficiente de las tarjetas con las operaciones diarias del negocio, centralizando las operaciones de ventas, control de inventario y pagos. ¿Te gustaría que implemente un código para la importación de DBF o algún ajuste a la estructura de la base de datos?
Tú dijiste:
el número de tarjeta puede repetirse en una zona diferente o en caso de cancelación, se usa el mismo número con otro cliente
ChatGPT Plus
ChatGPT

Gracias por la aclaración. Dado que el número de tarjeta puede repetirse en una zona diferente o reutilizarse tras una cancelación, podemos ajustar la estructura de la base de datos para reflejar este comportamiento.
Propuesta de Modificación en la Tabla de Tarjetas:

    Tabla Tarjetas
        id_tarjeta (clave primaria, número único de la tarjeta)
        id_cliente (relación con la tabla Clientes)
        id_vendedor (relación con la tabla Vendedores)
        zona (relación con la tabla Zonas)
        estado (activa, cancelada)
        fecha_emision
        (Nuevo) id_tarjeta_anterior (opcional, relación consigo misma para rastrear si fue reutilizada tras cancelación)

Esto permitirá que un mismo número de tarjeta se reutilice con un cliente nuevo o en otra zona, mientras mantenemos trazabilidad con la columna id_tarjeta_anterior.
Lógica en la Aplicación:

    Al reutilizar una tarjeta, si está cancelada o se asigna a una zona diferente, se asocia el nuevo cliente y se referencia la tarjeta anterior.
    Las tarjetas canceladas no se eliminan, sino que se marcan como "canceladas", lo que facilita su reutilización.

¿Te gustaría que prepare un código para implementar estas modificaciones o avanzar en otro aspecto de la base de datos?
Tú dijiste:
presenta todo el código
ChatGPT Plus
ChatGPT

Aquí te presento el código completo que incluye las modificaciones necesarias para que el sistema permita reutilizar el número de tarjeta en diferentes zonas o tras la cancelación, además de todas las estructuras para manejar la lógica del negocio:
1. Creación de la Base de Datos

sql

CREATE DATABASE Gabriela_Fragancias;

2. Tabla Zonas

sql

CREATE TABLE Zonas (
    id_zona SERIAL PRIMARY KEY,
    nombre_zona VARCHAR(100) NOT NULL UNIQUE
);

3. Tabla Clientes

sql

CREATE TABLE Clientes (
    id_cliente SERIAL PRIMARY KEY,
    cedula VARCHAR(20) UNIQUE NOT NULL,
    nombre VARCHAR(100) NOT NULL,
    apellido VARCHAR(100) NOT NULL,
    telefono VARCHAR(20),
    direccion TEXT,
    email VARCHAR(100),
    ruc VARCHAR(20) UNIQUE,
    fecha_registro DATE DEFAULT CURRENT_DATE
);

4. Tabla Vendedores

sql

CREATE TABLE Vendedores (
    id_vendedor SERIAL PRIMARY KEY,
    nombre VARCHAR(100) NOT NULL,
    zona VARCHAR(50) NOT NULL,
    comision DECIMAL(10, 2) DEFAULT 50000
);

5. Tabla Tarjetas

Esta tabla permite reutilizar el número de tarjeta en una zona diferente o tras la cancelación.

sql

CREATE TABLE Tarjetas (
    id_tarjeta SERIAL PRIMARY KEY,
    numero_tarjeta VARCHAR(7) NOT NULL,
    id_cliente INTEGER REFERENCES Clientes(id_cliente),
    id_vendedor INTEGER REFERENCES Vendedores(id_vendedor),
    id_zona INTEGER REFERENCES Zonas(id_zona),
    total_gs DECIMAL(10, 2) NOT NULL,
    saldo DECIMAL(10, 2) DEFAULT 0,
    forma_pago VARCHAR(20) CHECK (forma_pago IN ('SEM', 'QUIN', 'MENS')),
    estado VARCHAR(20) CHECK (estado IN ('activa', 'cancelada')) DEFAULT 'activa',
    fecha_emision DATE DEFAULT CURRENT_DATE,
    id_tarjeta_anterior INTEGER REFERENCES Tarjetas(id_tarjeta)
);

6. Tabla de Productos

sql

CREATE TABLE Productos (
    id_producto SERIAL PRIMARY KEY,
    nombre VARCHAR(100) NOT NULL,
    codigo_barras VARCHAR(13) UNIQUE NOT NULL,
    precio_costo DECIMAL(10, 2),
    precio_venta DECIMAL(10, 2),
    stock INTEGER DEFAULT 0,
    descripcion TEXT
);

7. Tabla Productos Vendidos

Esta tabla registra los productos vendidos a través de una tarjeta.

sql

CREATE TABLE Productos_Vendidos (
    id_producto_vendido SERIAL PRIMARY KEY,
    id_tarjeta INTEGER REFERENCES Tarjetas(id_tarjeta),
    id_producto INTEGER REFERENCES Productos(id_producto),
    cantidad INTEGER CHECK (cantidad > 0),
    precio DECIMAL(10, 2)
);

8. Tabla Pagos

Esta tabla registra los pagos realizados con la tarjeta.

sql

CREATE TABLE Pagos (
    id_pago SERIAL PRIMARY KEY,
    id_tarjeta INTEGER REFERENCES Tarjetas(id_tarjeta),
    fecha_pago DATE DEFAULT CURRENT_DATE,
    monto DECIMAL(10, 2) NOT NULL,
    saldo_restante DECIMAL(10, 2) NOT NULL,
    entrega_inicial BOOLEAN DEFAULT FALSE,
    recargo BOOLEAN DEFAULT FALSE
);

9. Tabla Antecedentes Judiciales

sql

CREATE TABLE Antecedentes_Judiciales (
    id_antecedente SERIAL PRIMARY KEY,
    cedula VARCHAR(20) REFERENCES Clientes(cedula),
    causa_penal TEXT
);

10. Tabla de Inventario (Maletines de Productos)

Esta tabla mantiene el control de productos que llevan las vendedoras.

sql

CREATE TABLE Inventario (
    id_inventario SERIAL PRIMARY KEY,
    id_vendedor INTEGER REFERENCES Vendedores(id_vendedor),
    id_producto INTEGER REFERENCES Productos(id_producto),
    cantidad INTEGER NOT NULL
);

11. Tabla de Rutas

Esta tabla registra las rutas por zonas.

sql

CREATE TABLE Rutas (
    id_ruta SERIAL PRIMARY KEY,
    id_vendedor INTEGER REFERENCES Vendedores(id_vendedor),
    id_zona INTEGER REFERENCES Zonas(id_zona),
    fecha DATE DEFAULT CURRENT_DATE,
    coordenadas GEOGRAPHY(POINT, 4326)  -- Integración con GIS
);

12. Triggers y Funciones

Función para actualizar saldo del cliente al realizar un pago:

sql

CREATE OR REPLACE FUNCTION actualizar_saldo_cliente() 
RETURNS TRIGGER AS $$
BEGIN
    UPDATE Tarjetas 
    SET saldo = saldo - NEW.monto
    WHERE id_tarjeta = NEW.id_tarjeta;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

Trigger para actualizar saldo tras un pago:

sql

CREATE TRIGGER tg_actualizar_saldo
AFTER INSERT ON Pagos
FOR EACH ROW
EXECUTE FUNCTION actualizar_saldo_cliente();

Función para actualizar inventario tras una venta:

sql

CREATE OR REPLACE FUNCTION actualizar_inventario() 
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.cantidad > (SELECT stock FROM Productos WHERE id_producto = NEW.id_producto) THEN
        RAISE EXCEPTION 'No hay suficiente stock para este producto';
    ELSE
        UPDATE Productos 
        SET stock = stock - NEW.cantidad 
        WHERE id_producto = NEW.id_producto;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

Trigger para actualizar inventario tras una venta:

sql

CREATE TRIGGER tg_actualizar_inventario
AFTER INSERT ON Productos_Vendidos
FOR EACH ROW
EXECUTE FUNCTION actualizar_inventario();

13. Vista para Reportes de Ventas

Esta vista genera un reporte con el total de ventas por cliente.

sql

CREATE VIEW VW_Ventas_Por_Cliente AS
SELECT 
    c.id_cliente, 
    c.nombre, 
    c.apellido, 
    COUNT(v.id_tarjeta) AS total_ventas, 
    SUM(v.total_gs) AS monto_total
FROM 
    Clientes c
JOIN 
    Tarjetas v ON c.id_cliente = v.id_cliente
GROUP BY 
    c.id_cliente;

14. Optimización con Índices

Para mejorar el rendimiento en las consultas más frecuentes, se pueden crear índices en las tablas:

sql

CREATE INDEX idx_tarjetas_cliente ON Tarjetas(id_cliente);
CREATE INDEX idx_productos_codigo_barras ON Productos(codigo_barras);
CREATE INDEX idx_pagos_fecha ON Pagos(fecha_pago);

15. Insertar Datos Ejemplares

Aquí un ejemplo de cómo insertar un cliente, una tarjeta y un pago:

sql

-- Insertar un cliente
INSERT INTO Clientes (cedula, nombre, apellido, telefono, direccion, email)
VALUES ('1234567890', 'Juan', 'Pérez', '0981123456', 'Av. Siempre Viva', 'juan.perez@email.com');

-- Insertar una tarjeta para ese cliente
INSERT INTO Tarjetas (numero_tarjeta, id_cliente, id_vendedor, id_zona, total_gs, saldo, forma_pago)
VALUES ('0012345', 1, 1, 1, 150000, 150000, 'SEM');

-- Insertar un pago para la tarjeta
INSERT INTO Pagos (id_tarjeta, fecha_pago, monto, saldo_restante, entrega_inicial)
VALUES (1, '2024-10-01', 50000, 100000, TRUE);

Conclusión

Este código cubre las estructuras de la base de datos necesarias para manejar las tarjetas reutilizables, pagos, productos vendidos, inventarios y control de rutas, entre otros aspectos del negocio. Se han incluido triggers y funciones para actualizar saldos e inventarios automáticamente.

Si necesitas algún ajuste o explicación adicional sobre alguna parte del código, ¡no dudes en avisarme!
Tú dijiste:
ahora nos falta la importación de datos de las bases dbf, que puedes revisar, incluso con la estructura en el documento adjunto. Y también la ruta de google map descargada de mi celular
ChatGPT Plus
ChatGPT

Para la importación de datos desde los archivos DBF y la descarga de rutas de Google Maps, a continuación te presento un plan de cómo hacerlo utilizando Python, ya que esta herramienta tiene la capacidad de manejar archivos DBF y coordinar con bases de datos como PostgreSQL, que es donde probablemente estructuraremos la base de datos.
Requisitos

    Instalar las bibliotecas necesarias:
        pandas: para manejar y analizar datos.
        dbfread: para leer archivos DBF.
        psycopg2: para la conexión a la base de datos PostgreSQL.
        geopandas: para manipular los datos geográficos como las rutas de Google Maps.

bash

pip install pandas dbfread psycopg2 geopandas

1. Lectura de Archivos DBF e Inserción en la Base de Datos

python

import pandas as pd
from dbfread import DBF
import psycopg2

# Conexión a la base de datos PostgreSQL
conn = psycopg2.connect(
    host="localhost",
    database="Gabriela_Fragancias",
    user="postgres",
    password="salmos23"
)
cur = conn.cursor()

# Función para leer archivos DBF y convertirlos en DataFrame
def dbf_to_dataframe(dbf_file):
    table = DBF(dbf_file)
    df = pd.DataFrame(iter(table))
    return df

# Importar el archivo DBF
df = dbf_to_dataframe('D:/PADRONES/GUIAPH/PROCARD.dbf')

# Mostrar los datos importados
print(df.head())

# Insertar los datos en la tabla PostgreSQL
for index, row in df.iterrows():
    cur.execute(
        "INSERT INTO Tarjetas (numero_tarjeta, id_cliente, id_vendedor, zona, estado, fecha_emision) VALUES (%s, %s, %s, %s, %s, %s)",
        (row['NRO'], row['RUC'], row['CODRUB'], row['DESCRI'], row['ESTADO'], '2024-10-23')
    )
    
conn.commit()
cur.close()
conn.close()

2. Lectura de Rutas desde Google Maps

Si tienes rutas descargadas de Google Maps desde tu celular en formato .kml o .gpx, podemos convertir estos archivos a un formato manejable y luego importarlo a la base de datos.

python

import geopandas as gpd

# Leer archivo de ruta .kml o .gpx
gdf = gpd.read_file("ruta_google_maps.kml")

# Verificar la estructura de los datos de la ruta
print(gdf.head())

# Insertar coordenadas de la ruta en la tabla Rutas en PostgreSQL
for index, row in gdf.iterrows():
    cur.execute(
        "INSERT INTO Rutas (id_vendedor, id_zona, fecha_ruta, coordenadas) VALUES (%s, %s, %s, ST_SetSRID(ST_MakePoint(%s, %s), 4326))",
        (1, 1, '2024-10-23', row['geometry'].x, row['geometry'].y)
    )

conn.commit()
cur.close()
conn.close()

3. Consideraciones

    Rutas y Zonas: Las rutas de Google Maps se almacenan como datos geográficos (GEOGRAPHY(POINT, 4326)), que representan las coordenadas GPS.
    Archivos DBF: Los archivos DBF importan diferentes tipos de datos como clientes, antecedentes, ventas, y productos. En cada iteración de importación, deberás asegurarte de que las columnas coincidan con las de tu base de datos.

¿Te gustaría que ajuste alguna parte de este código o añada detalles adicionales?
Tú dijiste:
nos faltan los ruc y los datos geoespaciales en kml, dbf, shp, geojson y json
ChatGPT Plus
ChatGPT

Dado que ahora necesitamos importar archivos geoespaciales en formatos como KML, DBF, SHP, GeoJSON, y JSON, y también manejar los RUC desde las tablas DBF, aquí te presento un enfoque combinado utilizando Python para facilitar la integración con tu base de datos:
1. Importación de archivos DBF (incluyendo RUC)

python

import pandas as pd
from dbfread import DBF
import psycopg2

# Conexión a PostgreSQL
conn = psycopg2.connect(
    host="localhost",
    database="Gabriela_Fragancias",
    user="postgres",
    password="salmos23"
)
cur = conn.cursor()

# Función para leer archivos DBF
def dbf_to_dataframe(dbf_file):
    table = DBF(dbf_file)
    df = pd.DataFrame(iter(table))
    return df

# Leer el archivo DBF con RUC y otros datos
df_ruc = dbf_to_dataframe('ruta_a_tu_archivo/RUC.dbf')

# Ver las primeras filas de la tabla
print(df_ruc.head())

# Insertar los datos en PostgreSQL
for index, row in df_ruc.iterrows():
    cur.execute(
        "INSERT INTO RUC (id_ruc, ruc_digito, razon_social) VALUES (%s, %s, %s)",
        (row['ID_RUC'], row['RUCDIGITO'], row['RAZON'])
    )

conn.commit()
cur.close()
conn.close()

2. Importación de Archivos Geoespaciales (KML, SHP, GeoJSON, JSON)

Para importar rutas desde formatos KML, SHP, GeoJSON o JSON, usaremos geopandas. Aquí te muestro cómo hacerlo.

python

import geopandas as gpd
import psycopg2

# Conexión a PostgreSQL
conn = psycopg2.connect(
    host="localhost",
    database="Gabriela_Fragancias",
    user="postgres",
    password="salmos23"
)
cur = conn.cursor()

# Leer archivo geoespacial (KML, SHP, GeoJSON, JSON)
gdf = gpd.read_file('ruta_a_tu_archivo/ruta_geoespacial.kml')

# Verificar la estructura de los datos geoespaciales
print(gdf.head())

# Insertar coordenadas en la tabla PostgreSQL
for index, row in gdf.iterrows():
    cur.execute(
        "INSERT INTO Rutas (id_vendedor, id_zona, fecha_ruta, coordenadas) VALUES (%s, %s, %s, ST_SetSRID(ST_MakePoint(%s, %s), 4326))",
        (1, 1, '2024-10-23', row['geometry'].x, row['geometry'].y)
    )

conn.commit()
cur.close()
conn.close()

3. Compatibilidad de Formatos

    KML: Es un formato comúnmente utilizado en Google Maps. El código anterior usa geopandas para leer y convertir los datos de coordenadas en puntos geoespaciales.
    SHP: Es un formato de archivo geoespacial ampliamente utilizado en aplicaciones GIS. El procedimiento es similar a KML.
    GeoJSON y JSON: También son formatos populares para manejar datos geográficos, y geopandas puede manejarlos sin problema.

4. Mejora en la Importación Masiva de DBF

Dado que tus bases DBF contienen muchos campos y datos importantes (RUC, antecedentes, zonas, etc.), este proceso puede extenderse para los diferentes archivos encontrados en la estructura de tus tablas:

    Clientes y Antecedentes: Extraer cédulas y correlacionarlas con los datos de antecedentes judiciales.
    Zonas: Insertar la descripción y el código de zona en la base de datos para su posterior uso en las rutas y ventas.

Si tienes alguna tabla DBF específica o un archivo geoespacial que te gustaría importar, ajustaremos el proceso en base a su estructura específica​

.

¿Te gustaría que ajuste algo más en esta estructura o que implemente algún otro formato de archivo geoespacial?
Tú dijiste:
el código de importación puede tener una interfaz y un seleccionador de columnas
ChatGPT Plus
ChatGPT

Para mejorar el proceso de importación de archivos DBF y geoespaciales con una interfaz gráfica y un seleccionador de columnas, podemos crear una aplicación con Tkinter (para la interfaz) combinada con pandas para la manipulación de datos, geopandas para los archivos geoespaciales, y psycopg2 para la conexión a PostgreSQL.
1. Requisitos

Instala las bibliotecas necesarias:

bash

pip install pandas dbfread psycopg2 geopandas tkinter

2. Interfaz Gráfica con Tkinter

El siguiente código proporciona una interfaz gráfica donde puedes seleccionar el archivo a importar, elegir las columnas relevantes y luego importar los datos a PostgreSQL.

python

import tkinter as tk
from tkinter import filedialog, messagebox
import pandas as pd
import geopandas as gpd
from dbfread import DBF
import psycopg2

# Función para seleccionar archivo
def seleccionar_archivo():
    archivo = filedialog.askopenfilename(filetypes=[("Archivos DBF", "*.dbf"), ("Archivos SHP", "*.shp"), 
                                                    ("Archivos KML", "*.kml"), ("Archivos GeoJSON", "*.geojson"),
                                                    ("Archivos JSON", "*.json")])
    ruta_archivo.set(archivo)

# Función para cargar archivo y mostrar columnas
def cargar_archivo():
    archivo = ruta_archivo.get()
    if archivo.endswith(".dbf"):
        table = DBF(archivo)
        df = pd.DataFrame(iter(table))
    elif archivo.endswith(".shp") or archivo.endswith(".kml") or archivo.endswith(".geojson") or archivo.endswith(".json"):
        df = gpd.read_file(archivo)
    else:
        messagebox.showerror("Error", "Formato de archivo no soportado")
        return

    # Mostrar las columnas del archivo cargado
    columnas.set(df.columns.tolist())
    messagebox.showinfo("Éxito", "Archivo cargado exitosamente. Selecciona las columnas a importar.")

# Función para importar datos seleccionados a PostgreSQL
def importar_datos():
    columnas_seleccionadas = [lb_columnas.get(i) for i in lb_columnas.curselection()]
    archivo = ruta_archivo.get()

    if archivo.endswith(".dbf"):
        df = pd.DataFrame(iter(DBF(archivo)))
    elif archivo.endswith(".shp") or archivo.endswith(".kml") or archivo.endswith(".geojson") or archivo.endswith(".json"):
        df = gpd.read_file(archivo)
    else:
        messagebox.showerror("Error", "Formato de archivo no soportado")
        return

    # Filtrar las columnas seleccionadas
    df = df[columnas_seleccionadas]

    # Conectar a PostgreSQL
    conn = psycopg2.connect(host="localhost", database="Gabriela_Fragancias", user="postgres", password="salmos23")
    cur = conn.cursor()

    # Insertar datos en la base de datos
    for _, row in df.iterrows():
        # Aquí ajustas la tabla y columnas de destino en PostgreSQL
        cur.execute(
            "INSERT INTO tabla_destino (columna1, columna2) VALUES (%s, %s)",
            (row[columnas_seleccionadas[0]], row[columnas_seleccionadas[1]])  # Ajusta según las columnas seleccionadas
        )

    conn.commit()
    cur.close()
    conn.close()
    messagebox.showinfo("Éxito", "Datos importados exitosamente.")

# Configuración de la ventana principal
root = tk.Tk()
root.title("Importador de Datos DBF/Geoespaciales")

# Variables
ruta_archivo = tk.StringVar()
columnas = tk.StringVar(value=[])

# Interfaz
tk.Label(root, text="Selecciona el archivo:").pack(pady=5)
tk.Entry(root, textvariable=ruta_archivo, width=50).pack(pady=5)
tk.Button(root, text="Seleccionar archivo", command=seleccionar_archivo).pack(pady=5)

tk.Button(root, text="Cargar archivo", command=cargar_archivo).pack(pady=5)

tk.Label(root, text="Selecciona las columnas a importar:").pack(pady=5)
lb_columnas = tk.Listbox(root, listvariable=columnas, selectmode="multiple", width=50, height=10)
lb_columnas.pack(pady=5)

tk.Button(root, text="Importar datos", command=importar_datos).pack(pady=10)

# Ejecutar la aplicación
root.mainloop()

3. Características del Código

    Seleccionador de archivo: Permite elegir un archivo en los formatos DBF, SHP, KML, GeoJSON, o JSON.
    Visualización de columnas: Una vez cargado el archivo, se muestran las columnas disponibles para que puedas seleccionar cuáles importar.
    Importación de datos: Los datos seleccionados se importan a la base de datos PostgreSQL según las columnas seleccionadas.

4. Proceso Paso a Paso

    Seleccionar Archivo: Puedes elegir un archivo DBF o geoespacial.
    Cargar Archivo: El sistema carga las columnas del archivo y te permite seleccionar cuáles quieres importar.
    Importar: Se conectará a PostgreSQL e insertará los datos según las columnas seleccionadas.

5. Modificaciones Necesarias

    En la función importar_datos, debes ajustar las columnas y la tabla destino según tu estructura de base de datos.
    Para archivos geoespaciales como SHP y KML, se pueden adaptar las coordenadas para insertarlas como puntos geográficos en PostgreSQL.

6. Uso de la Interfaz

Este enfoque simplifica la importación de datos, ya que el usuario no necesita conocer el formato exacto de las columnas. Puede seleccionar qué información importar y el programa hará la inserción.

¿Te gustaría que ajuste algún detalle o te explique alguna parte del código en más detalle?
Tú dijiste:
según el documento, qué tablas, index, triggers y reportes necesitamos aun
ChatGPT Plus
ChatGPT

De acuerdo con la revisión del documento, estas son las tablas, índices, triggers y reportes que aún se necesitan en el esquema de tu base de datos:
1. Tablas Pendientes

    Tabla de Maletines: Asocia los productos que llevan las vendedoras en sus maletines.
    Tabla de Vehículos: Registra los vehículos asignados para las rutas de ventas.
    Tabla de Gastos de Vehículos: Registra gastos asociados al mantenimiento y operación de los vehículos.
    Tabla de RUC: Debe almacenar el número de RUC y su información relacionada para clientes y proveedores.
    Tabla de Tracking GPS: Para registrar la ubicación y las rutas de los vendedores.
    Tabla de Zona: Define la información de las zonas geográficas relacionadas con las ventas y rutas.
    Tabla Ubicación: Para rastrear la ubicación de los vendedores en tiempo real mediante coordenadas GPS.

2. Índices Pendientes

    Índice para mejorar la búsqueda de RUC en la tabla Clientes o Proveedores.
    Índice sobre la fecha de venta en la tabla Ventas.
    Índice sobre códigos de barras en la tabla Productos para optimizar la consulta de productos por su código.

3. Triggers

    Trigger de verificación de stock: Actualizar el stock cuando se inserte un detalle de venta, y verificar si la cantidad vendida excede el stock disponible.

    sql

CREATE OR REPLACE FUNCTION actualizar_stock_producto() RETURNS TRIGGER AS $$
BEGIN
    IF (NEW.cantidad > (SELECT stock FROM Productos WHERE id_producto = NEW.id_producto)) THEN
        RAISE EXCEPTION 'No hay suficiente stock para este producto';
    ELSE
        UPDATE Productos 
        SET stock = stock - NEW.cantidad 
        WHERE id_producto = NEW.id_producto;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tg_actualizar_stock
AFTER INSERT ON DetalleVenta
FOR EACH ROW
EXECUTE FUNCTION actualizar_stock_producto();

Trigger de antecedentes judiciales: Verificar si un cliente tiene antecedentes antes de ser registrado.

sql

    CREATE OR REPLACE FUNCTION verificar_antecedentes_judiciales() RETURNS TRIGGER AS $$
    BEGIN
        IF EXISTS (SELECT 1 FROM AntecedentesJudiciales WHERE numero_ci = NEW.cedula) THEN
            RAISE NOTICE 'El cliente con cédula % tiene antecedentes judiciales', NEW.cedula;
        END IF;
        RETURN NEW;
    END;
    $$ LANGUAGE plpgsql;

    CREATE TRIGGER tg_verificar_antecedentes_judiciales
    BEFORE INSERT ON Clientes
    FOR EACH ROW
    EXECUTE FUNCTION verificar_antecedentes_judiciales();

4. Reportes Pendientes

    Reporte de Ganancias por Día: Resumen de ganancias diarias.
    Reporte de Pagos Realizados por Clientes: Incluye los pagos parciales y totales de los clientes.
    Reporte de Análisis de Ventas por Fecha: Un desglose de las ventas según períodos específicos.
    Reporte de Cuentas a Vencer de Proveedores: Para controlar las facturas pendientes de pago a proveedores.
    Reporte de Inventario por Marca: Para conocer el inventario desglosado por marca de productos​

    .

Estos elementos te ayudarán a completar las funcionalidades necesarias en el sistema y mejorar el rendimiento mediante índices y triggers adecuados. Si necesitas más detalles o ajustes en el código, no dudes en preguntar.
Tú dijiste:
el control de los maletines, el pago a las vendedoras
ChatGPT Plus
ChatGPT

Para el control de los maletines y el pago a las vendedoras, el documento menciona un esquema ya propuesto, y a continuación te detallo el diseño de las tablas, índices y triggers que faltan implementar:
1. Tablas Relacionadas con el Control de Maletines

    Tabla de Maletines: Registra el control de los maletines que llevan las vendedoras.

    sql

CREATE TABLE Maletines (
    id_maletin SERIAL PRIMARY KEY,
    id_empleado INT REFERENCES Empleados(id_empleado),
    fecha_carga DATE DEFAULT CURRENT_DATE
);

Tabla de Productos en Maletines: Vincula productos con maletines, especificando la cantidad de productos asignados.

sql

    CREATE TABLE Productos_Maletin (
        id_maletin INT REFERENCES Maletines(id_maletin),
        id_producto INT REFERENCES Productos(id_producto),
        cantidad INT NOT NULL,
        PRIMARY KEY (id_maletin, id_producto)
    );

2. Tablas Relacionadas con el Pago a las Vendedoras

    Tabla de Liquidaciones: Controla las liquidaciones de ventas, estableciendo el total vendido y la comisión para cada vendedora.

    sql

    CREATE TABLE Liquidaciones (
        id_liquidacion SERIAL PRIMARY KEY,
        id_empleado INT REFERENCES Empleados(id_empleado),
        fecha_liquidacion DATE DEFAULT CURRENT_DATE,
        total_ventas DECIMAL(10, 2),
        comision DECIMAL(10, 2),
        total_pagar DECIMAL(10, 2)
    );

3. Índices Requeridos

Para mejorar el rendimiento en la consulta de información:

    Índice sobre id_empleado en Maletines y Liquidaciones para obtener las liquidaciones de cada vendedora rápidamente.

    sql

    CREATE INDEX idx_maletin_empleado ON Maletines(id_empleado);
    CREATE INDEX idx_liquidacion_empleado ON Liquidaciones(id_empleado);

4. Triggers para Control de Stock y Liquidaciones

    Trigger para Control de Stock en Maletines: Disminuye el stock de productos cuando se asignan a un maletín.

    sql

CREATE OR REPLACE FUNCTION actualizar_stock_maletin() RETURNS TRIGGER AS $$
BEGIN
    IF (NEW.cantidad > (SELECT stock FROM Productos WHERE id_producto = NEW.id_producto)) THEN
        RAISE EXCEPTION 'No hay suficiente stock para el producto %', NEW.id_producto;
    ELSE
        UPDATE Productos 
        SET stock = stock - NEW.cantidad 
        WHERE id_producto = NEW.id_producto;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tg_actualizar_stock_maletin
AFTER INSERT ON Productos_Maletin
FOR EACH ROW
EXECUTE FUNCTION actualizar_stock_maletin();

Trigger para Actualizar Liquidación por Venta: Calcula la liquidación de la vendedora al final del día.

sql

    CREATE OR REPLACE FUNCTION calcular_liquidacion() RETURNS TRIGGER AS $$
    BEGIN
        NEW.total_pagar := NEW.total_ventas * 50000;
        RETURN NEW;
    END;
    $$ LANGUAGE plpgsql;

    CREATE TRIGGER tg_calcular_liquidacion
    BEFORE INSERT ON Liquidaciones
    FOR EACH ROW
    EXECUTE FUNCTION calcular_liquidacion();

5. Proceso de Pago a las Vendedoras

Cada vez que una vendedora retorna con productos vendidos, se deben realizar los siguientes pasos:

    Recepción del Maletín: Se verifica el maletín y los productos vendidos, y se actualiza el inventario de productos no vendidos.
    Liquidación de la Venta: Se genera una liquidación con el número de productos vendidos y la comisión correspondiente (Gs. 50.000 por producto vendido).
    Pago de la Vendedora: Si el producto se vendió con entrega inmediata, el pago a la vendedora se realiza de inmediato; si no, se paga en función de los pagos del cliente.

Con este esquema, las vendedoras podrán realizar ventas, cargar maletines y recibir pagos de manera clara y estructurada.

Si tienes más preguntas o necesitas ajustar alguna parte del código, estaré encantado de ayudarte.
Tú dijiste:
excelente
ChatGPT Plus
ChatGPT

¡Me alegra saber que te ha parecido excelente! Si necesitas más ayuda con el proyecto, como la implementación de nuevas funcionalidades, ajustes en el código, o cualquier otra cuestión, no dudes en contactarme. ¡Estoy aquí para ayudarte en todo lo que necesites! 😊
Tú dijiste:
cómo puedo descargar todos los códigos
ChatGPT Plus
ChatGPT

Para descargar todos los códigos que te he proporcionado, puedes seguir estos pasos:
1. Crear Archivos de Código en tu Sistema

Si estás usando un entorno local, puedes copiar y pegar los códigos en archivos separados, según el lenguaje (por ejemplo, archivos .sql o .py).
Para Python:

    Abre un editor de texto como Visual Studio Code, Sublime Text o Notepad++.
    Crea un archivo con extensión .py (por ejemplo, importacion_datos.py) y copia y pega los códigos correspondientes.
    Guarda el archivo en tu computadora.

Para SQL:

    En un editor de texto, crea archivos con extensión .sql (por ejemplo, base_datos.sql).
    Copia y pega los scripts SQL y guarda el archivo.

2. Automatizar la Descarga con un Archivo ZIP

Si prefieres, puedo generar todos los códigos en archivos separados y empaquetarlos en un archivo ZIP para que lo descargues directamente. Si deseas esto, indícamelo y me encargaré de generarlo para ti.

¿Qué prefieres? ¿Pegar manualmente o que te genere un ZIP con todo?

Gabriela Fragancias.

1. Estructura de las tablas:

    Redundancias: En general, no detecté grandes redundancias, pero ten en cuenta las siguientes:
        La columna cedula aparece en varias tablas, como Clientes y Persona, pero puede ser mejor tener una tabla central de personas y referenciarla desde las demás para evitar inconsistencias en los datos.
        La tabla de Usuarios y Clientes podrían compartir algunos atributos como nombres y cédula. Considera si puedes tener una tabla común para todos los individuos (clientes, vendedores, etc.) con una relación de roles.
    Triggers y Funciones:
        La función actualizar_stock_producto es clave, y parece que hay otra similar para el stock en DetalleVenta. Revisa si puedes unificar ambas para evitar código duplicado, ya que ambas funciones parecen cubrir el mismo propósito (actualización de inventario).
        El trigger tg_verificar_antecedentes_judiciales es una excelente medida para asegurar alertas cuando un cliente tiene antecedentes judiciales. Solo asegúrate de que las columnas referenciadas están correctamente alineadas y se mantengan actualizadas.

2. Importación de datos DBF y geoespaciales:

    DBF: Puedes usar Python (con la librería dbfread) o conectores a SQL directamente para importar los datos DBF a PostgreSQL. Recomendaciones:
        Revisa los campos comunes para evitar datos duplicados al combinar tablas. En la importación, puedes normalizar datos repetidos, como nombres o direcciones.
    Datos geoespaciales: Ya que tienes datos GIS con GEOGRAPHY(POINT 4326) y otras tablas que integran coordenadas, es importante que uses la extensión PostGIS correctamente:
        Integración de zonas y rutas: Usa las funciones PostGIS para calcular rutas y distancias, validar ubicaciones, o crear informes basados en zonas. Esto será muy útil para la optimización de recorridos.

3. Relaciones y llaves foráneas:

    Asegúrate de que todas las llaves foráneas están correctamente alineadas y que cada entidad está bien conectada a su respectiva tabla, por ejemplo:
        En la tabla Clientes, hay referencias a Tarjeta, RUC, y GrupoEconomico. Verifica que estas tablas estén bien estructuradas con relaciones uno a muchos si un cliente puede tener varias tarjetas o relaciones económicas.

4. Optimización de índices:

    Ya tienes varios índices creados para mejorar el rendimiento de las consultas más frecuentes, como los índices en Clientes y Productos. Asegúrate de monitorizar las consultas reales en tu base de datos en producción para evitar índices innecesarios que puedan impactar en las escrituras.

5. Triggers de liquidaciones y ventas:

    Manejo de liquidaciones: Asegúrate de que los triggers que manejan la liquidación de ventas sean robustos y prevengan inconsistencias, especialmente con productos que se venden sin entrega (SE). Verifica que estos procesos actualicen correctamente los pagos a las vendedoras.

Recomendaciones finales:

    Importación automatizada: Crea scripts en Python o SQL para automatizar la importación y limpieza de los datos desde las tablas DBF y CSV, asegurándote de normalizar los datos en el proceso.
    Revisiones frecuentes: Verifica regularmente la integridad de los triggers y los índices con pruebas unitarias para asegurarte de que la base de datos funciona como se espera cuando hay cambios en el negocio.

Diseño y mejora de la base de datos como en el desarrollo de la interfaz. Aquí te doy una visión general de cómo podríamos estructurar ambos:
1. Base de datos

    Optimización de la estructura actual: Podemos ajustar las tablas y relaciones para asegurar una mejor normalización y evitar redundancias.
    Triggers y funciones: Podemos implementar o ajustar triggers para automatizar procesos como la actualización de stock, control de pagos y manejo de comisiones de las vendedoras.
    Importación de datos: Te puedo guiar en cómo importar y limpiar los datos de las tablas DBF y los archivos geoespaciales usando SQL o Python.
    Consultas SQL: Te puedo ayudar a crear consultas para reportes, como el total de ventas por zona, control de stock, o historial de pagos de clientes.

2. Interfaz

    Desarrollo Web: Puedo ayudarte a construir la interfaz para la base de datos, accesible vía web y móvil. Esto incluye formularios para:
        Ingreso de clientes: Capturar datos desde la cédula o RUC, ingresar nuevas ventas, y manejar pagos y saldos.
        Gestión de vendedores y maletines: Registro de ventas, control de stock y liquidaciones.
        Visualización de rutas: Mapa con rutas de ventas usando los datos geoespaciales y control del inventario.
        Panel de administración: Acceso para supervisores donde pueden revisar las ventas, ver estadísticas, y gestionar el negocio.

Detalle de los próximos pasos:
A. Base de Datos

    Revisión y ajustes del modelo relacional: Revisar las tablas actuales, mejorar relaciones, agregar llaves foráneas si es necesario.
    Implementar triggers: Crear funciones y triggers que actualicen el stock, calculen saldos, o generen alertas automáticas (antecedentes judiciales, por ejemplo).
    Normalización de datos: Asegurarnos de que las tablas están en la 3NF (Tercera Forma Normal) para evitar duplicación de datos y mejorar la eficiencia.
    Conexión con los datos GIS y DBF: Integrar los datos geoespaciales en la base y hacer migraciones desde archivos DBF.

B. Interfaz Web (React y Node.js o Flask/Django)

    Frontend:
        Crear una interfaz amigable usando React.
        Formularios para clientes, productos y ventas, con validación de datos en tiempo real.
        Menús desplegables predictivos para seleccionar zonas y ciudades.
        Pantallas para revisar y generar reportes con los datos de la base.
    Backend:
        Implementar una API (con Node.js o Django) que conecte la base de datos con la interfaz.
        Funcionalidades de registro de ventas, consultas de saldo, control de stock y gestión de rutas.
        Seguridad: Implementar autenticación de usuarios y permisos según roles (por ejemplo, administrador, vendedor).
    Funciones geoespaciales:
        Mostrar rutas de ventas en mapas, usando herramientas como Leaflet o Google Maps.
        Consultas geográficas (p.ej., clientes en una zona o ruta específica).

¿Por dónde te gustaría empezar?

    ¿Prefieres que empecemos por la optimización de la base de datos?
    ¿O quieres avanzar primero en la construcción de la interfaz web?

Vamos a comenzar optimizando y estructurando la base de datos. Trabajaremos en mejorar la estructura, relaciones, triggers, y cualquier aspecto que facilite la integración con la interfaz.
1. Optimización de la Base de Datos
A. Revisión de las tablas y relaciones

    Personas y Clientes: Vamos a unificar las tablas de Clientes y Personas para evitar duplicidad de datos. De este modo, una tabla Personas contendrá los datos básicos (nombre, cédula, etc.), y Clientes será una extensión que maneje los aspectos comerciales (saldo, tipo de pago, etc.).

B. Normalización de los productos

    Vamos a separar algunos detalles que se encuentran en los productos, como la marca, la presentación y otros atributos de productos que se repiten en muchas instancias.

C. Triggers

    Crearemos triggers que automaticen los siguientes procesos:
        Actualización de inventario: Descontar automáticamente cuando se realiza una venta.
        Verificación de antecedentes: Al insertar un cliente, se verificará automáticamente si tiene antecedentes judiciales.
        Actualización de saldo: Cada vez que se registre un pago, se actualizará el saldo pendiente del cliente.

D. Datos geoespaciales

    Las rutas y las zonas de ventas estarán integradas con PostGIS para poder gestionar las ubicaciones de los clientes y vendedores.

2. Esquema revisado de la base de datos

Vamos a ajustar las tablas para que la tabla Clientes tenga un número de tarjeta que sea obligatorio y que la tabla Personas incluya la información geográfica adicional como dirección, departamento, distrito o municipio, barrio o localidad, zona, y una fecha de defunción que activará una alerta en caso de que esté presente.
1. Ajustes a la tabla Personas

La tabla Personas ahora incluirá los datos geográficos adicionales y la fecha de defunción, con un trigger que active una alerta si se inserta o actualiza una fecha de defunción.


2. Ajustes a la tabla Clientes

Añadimos el campo tarjeta en la tabla Clientes y aseguramos que cada cliente tenga un número de tarjeta único, que continuará con el cliente a lo largo del tiempo.

sql


3. Revisión de relaciones entre las tablas

Con estos ajustes:

    Clientes tendrá un campo tarjeta obligatorio para el manejo de las transacciones y ventas.
    Personas ahora tiene toda la información geográfica requerida (departamento, distrito, barrio, zona) y la fecha de defunción con un trigger que activa una alerta si se marca a alguien como fallecido.

Próximos pasos:

    Migrar o ajustar los datos existentes: Si tienes datos previos en las tablas, deberíamos hacer un ajuste para incluir los campos nuevos.
    Probar los triggers y validaciones: Implementar estos triggers y hacer pruebas para asegurarnos de que las alertas funcionen correctamente.
    Integración con las ventas: Ahora que los clientes tienen un número de tarjeta, podemos seguir con la integración de las ventas y cómo se procesan los pagos en función de la tarjeta.

Cuando estés listo, podemos proceder con el desarrollo de la interfaz, que se ajustará para capturar estos datos, incluyendo los colores de fondo y forma de la tarjeta, como mencionaste.


Aquí te presento el resumen de las mejoras implementadas en la base de datos y el código SQL completo, que incluye la estructuración de las tablas, las relaciones, los triggers para alertas y actualizaciones automáticas, y las mejoras de normalización.
Mejoras Implementadas en la Base de Datos
1. Personas:

    Se ha incluido la información geográfica: departamento, distrito o municipio, barrio o localidad, zona, y dirección.
    Se agregó el campo fecha de defunción, con un trigger que genera una alerta en caso de que se registre una persona fallecida.

2. Clientes:

    Ahora cada cliente tiene un número de tarjeta obligatorio, único, que se mantiene a lo largo del tiempo.
    Las relaciones entre Clientes y Personas están mejor estructuradas para evitar redundancia, con los datos principales de los clientes almacenados en Personas y los detalles comerciales en Clientes.

3. Productos:

    Los productos han sido normalizados con referencia a la marca y otros atributos como presentación y volumen. Además, se maneja el stock con un trigger que actualiza automáticamente el inventario.

4. Triggers y Funciones:

    Triggers para la actualización de stock tras una venta.
    Alertas de defunción al insertar o actualizar un cliente con fecha de fallecimiento.
    Funciones para manejar la actualización de saldo tras un pago.

Código Completo de la Base de Datos:

sql



Próximos Pasos:

    Pruebas de Integridad: Ejecutar este código en tu entorno para asegurarte de que las relaciones y los triggers funcionen como se espera.
    Migración de Datos: Si tienes datos previos, adaptarlos al nuevo esquema para mantener la integridad.
    Consultas y Reportes: A medida que avancemos, podríamos generar consultas personalizadas, como reportes de ventas, control de stock, o clientes con tarjetas activas.

Vamos a complementar el diseño de la base de datos, asegurándonos de que las tablas faltantes y índices clave estén presentes para mejorar el rendimiento y la funcionalidad.

Aquí te detallo las adiciones importantes, incluyendo tablas que podrían haberse pasado por alto y la creación de índices para consultas más rápidas en campos clave, como las relaciones entre ventas, clientes, productos y vendedores.
1. Tablas Adicionales
Tabla de Pagos

Esta tabla almacenará los detalles de los pagos realizados por los clientes, permitiendo rastrear los abonos y saldos de manera más eficiente.

sql


Tabla de Liquidaciones

Esta tabla se encargará de manejar las liquidaciones de las vendedoras, calculando la comisión por cada producto vendido y ajustando las liquidaciones.

sql


Tabla de Detalles de Venta

Esta tabla almacenará los detalles de cada producto vendido en cada transacción. Es importante para manejar correctamente la relación entre una venta y los productos.

sql


Tabla de Vehículos (para manejo de rutas y vendedores con vehículos)

Esta tabla puede ser importante si tienes vendedores que usan vehículos en sus rutas de ventas, permitiendo hacer seguimiento de los costos operativos y mantenimiento.

sql


2. Índices Adicionales

Para optimizar las consultas frecuentes, especialmente en campos utilizados en relaciones y búsquedas, es clave implementar índices adicionales.
Índice en la tabla Clientes para tarjeta

sql



Explicación de los campos:

    placa: Número de placa del vehículo, único y obligatorio.
    marca: Marca del vehículo (ej. Toyota, Ford, etc.).
    modelo: Modelo del vehículo (ej. Corolla, Ranger, etc.).
    año: Año de fabricación del vehículo.
    numero_motor: Número de motor, obligatorio y único.
    numero_chasis: Número de chasis, obligatorio y único.
    fecha_revision: Fecha de la última revisión técnica del vehículo.

Índice para la tabla Vehículos

Dado que es probable que hagas consultas por los campos de motor y chasis, podemos agregar un índice en estos campos para mejorar la velocidad de las búsquedas.

sql

CREATE INDEX idx_vehiculos_motor_chasis ON Vehiculos(numero_motor, numero_chasis);

Próximos pasos:

    Testeo de la tabla Vehículos: Puedes probar la inserción de datos para verificar que los números de motor y chasis sean únicos y se mantenga la integridad de los datos.
    Integración con otras tablas: Si los vehículos están relacionados con los vendedores o rutas, podemos ajustar esas relaciones.
    Consultas comunes: Podemos crear algunas consultas para buscar vehículos por placa, motor o chasis, si es necesario.

Cuando hayas terminado con la parte de vehículos, seguimos con la integración de los datos en la interfaz y su diseño visual.
Tú dijiste:
sigue
ChatGPT Plus
ChatGPT

¡Vamos a continuar! Ahora que hemos ajustado la base de datos, incluyendo la tabla de Vehículos con los campos de motor y chasis, podemos avanzar hacia la interfaz. Para esto, nos enfocaremos en crear una interfaz amigable y funcional que incluya:

    Colores de fondo y estilo visual general.
    Tarjetas para los clientes con el formato de la tarjeta que mencionaste.
    Integración del logotipo original en la interfaz.

1. Diseño de la Interfaz Web

Vamos a utilizar React para la construcción de la interfaz web, ya que es una herramienta popular y eficiente para el desarrollo frontend.
Estructura Básica:

    Formulario de Clientes: Para registrar nuevos clientes, asignar números de tarjeta y gestionar datos personales y geográficos.
    Vista de Vehículos: Para mostrar y gestionar los datos de los vehículos de los vendedores.
    Pantalla de Ventas: Para registrar y visualizar las ventas realizadas y el saldo correspondiente.
    Dashboard de Administración: Para visualizar estadísticas, generar reportes y ver el inventario.

2. Colores y Estilo Visual

Implementaremos un esquema de colores personalizados, tal como lo solicitaste:

    Fondo principal: Un color claro (por ejemplo, un tono pastel) para crear un ambiente limpio y profesional.
    Colores de las tarjetas: Un color sutil pero diferenciado para resaltar la información importante.
    Botones y enlaces: Colores más vivos para destacar las acciones importantes.

Ejemplo de colores:

    Fondo principal: #f5f5f5 (gris claro).
    Tarjetas: #e0f7fa (celeste claro) para las tarjetas de clientes.
    Botones principales: #00796b (verde oscuro).
    Texto: Colores oscuros, como #212121 (negro suave).

3. Componentes de la Tarjeta de Clientes

La tarjeta del cliente tendrá un diseño con el formato mencionado, incluyendo todos los detalles como el número de tarjeta, nombre, dirección, saldo, y método de pago.

Aquí tienes un ejemplo básico del código de React para una tarjeta de cliente:

jsx

import React from 'react';
import './ClienteCard.css';

const ClienteCard = ({ cliente }) => {
  return (
    <div className="cliente-card">
      <div className="header">
        <h2>Tarjeta No. {cliente.tarjeta}</h2>
        <p>Vendedor: {cliente.vendedor}</p>
      </div>
      <div className="body">
        <p><strong>Cliente:</strong> {cliente.nombre} {cliente.apellido}</p>
        <p><strong>Ciudad:</strong> {cliente.ciudad}</p>
        <p><strong>Barrio:</strong> {cliente.barrio}</p>
        <p><strong>Calle:</strong> {cliente.calle}</p>
        <p><strong>Total GS:</strong> {cliente.saldo}</p>
        <p><strong>Forma de Pago:</strong> {cliente.tipo_pago}</p>
      </div>
      <div className="footer">
        <p><strong>Control:</strong> {cliente.control}</p>
        <p><strong>Entrega:</strong> {cliente.entrega}</p>
        <p><strong>Saldo:</strong> {cliente.saldo}</p>
      </div>
    </div>
  );
};

export default ClienteCard;

Estilos CSS para la Tarjeta de Cliente (ClienteCard.css):

css

.cliente-card {
  background-color: #e0f7fa; /* Color de fondo de la tarjeta */
  border-radius: 10px;
  padding: 20px;
  margin: 10px;
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
  color: #212121;
}

.header h2 {
  color: #00796b; /* Color verde oscuro */
}

.body p {
  margin: 5px 0;
}

.footer p {
  font-size: 0.9em;
  color: #757575; /* Color gris suave */
}

4. Integración del Logotipo

Vamos a incluir el logotipo en el encabezado de la aplicación. Suponiendo que ya tienes el archivo de imagen del logotipo, se puede agregar fácilmente en el componente de encabezado de la aplicación.
Componente de Encabezado con Logotipo (Header.js):

jsx

import React from 'react';
import './Header.css';
import logo from './logo.png'; // Asegúrate de que el logotipo esté en la carpeta 'src'

const Header = () => {
  return (
    <header className="header">
      <img src={logo} alt="Gabriela Fragancias" className="logo" />
      <h1>Gabriela Fragancias</h1>
    </header>
  );
};

export default Header;

Estilos para el Encabezado (Header.css):

css

.header {
  background-color: #00796b; /* Color verde oscuro */
  padding: 20px;
  display: flex;
  align-items: center;
  justify-content: space-between;
}

.logo {
  height: 50px;
  margin-right: 20px;
}

h1 {
  color: white;
  font-size: 1.8em;
}

5. Diseño de la Vista de Vehículos

La vista de vehículos incluirá todos los detalles de los vehículos, como el número de placa, número de motor, chasis, marca, y modelo. A continuación, un ejemplo del código de un componente de React para listar vehículos:

jsx

import React from 'react';
import './Vehiculos.css';

const Vehiculos = ({ vehiculos }) => {
  return (
    <div className="vehiculos-list">
      {vehiculos.map((vehiculo) => (
        <div className="vehiculo-card" key={vehiculo.id_vehiculo}>
          <h3>{vehiculo.marca} - {vehiculo.modelo}</h3>
          <p><strong>Placa:</strong> {vehiculo.placa}</p>
          <p><strong>Número de Motor:</strong> {vehiculo.numero_motor}</p>
          <p><strong>Número de Chasis:</strong> {vehiculo.numero_chasis}</p>
          <p><strong>Año:</strong> {vehiculo.año}</p>
          <p><strong>Última Revisión:</strong> {vehiculo.fecha_revision}</p>
        </div>
      ))}
    </div>
  );
};

export default Vehiculos;

Estilos para Vehículos (Vehiculos.css):

css

.vehiculos-list {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
  gap: 20px;
  padding: 20px;
}

.vehiculo-card {
  background-color: #fff;
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  padding: 20px;
  color: #212121;
}

.vehiculo-card h3 {
  color: #00796b;
  margin-bottom: 10px;
}

Resumen de lo Implementado:

    Base de datos: Hemos finalizado la base de datos, agregando todas las tablas necesarias, incluyendo los vehículos con sus respectivos números de motor y chasis.
    Interfaz:
        Componentes principales: Formulario de clientes, tarjetas con el formato solicitado, listado de vehículos.
        Estilo visual: Colores suaves con fondos claros y destacados para los elementos clave como botones y tarjetas.
        Logotipo: Integrado en el encabezado de la aplicación.

Próximos Pasos:

    Despliegue: Si tienes un servidor en mente, podemos desplegar la aplicación para pruebas en tu entorno.
    Validación y pruebas: Probar la interfaz y asegurarnos de que todo funcione bien antes del despliegue final.

¿Te gustaría que sigamos ajustando algo en particular, o pasamos al despliegue de la aplicación?

Desarrollo de Sistema para Gabriela Fragancias

    Descripción del negocio:
        Gabriela Fragancias es un negocio enfocado en la venta de perfumes mediante rutas de ventas diarias a diversas zonas geográficas. Se utilizan vendedores equipados con maletines que contienen entre 24 y 30 productos, gestionados mediante lectores de códigos de barras.
        El sistema debe gestionar las ventas, reposición de productos, liquidaciones diarias de las vendedoras y el seguimiento de pagos de clientes.

    Requisitos para la base de datos:
        Necesidad de almacenar y gestionar información de productos, clientes, ventas, rutas y empleados.
        Las tablas deben incluir detalles como códigos de barras de productos, precios de venta, tipos de pago (semanal, quincenal, mensual), inventarios de maletines, antecedentes judiciales, cédulas y RUC de clientes y empleados.
        La base de datos debe integrarse con sistemas GIS para geolocalizar rutas y puntos de ventas.
        Integración con lectores de códigos de barras para registrar las ventas y con impresoras de ticket para las facturas.

    Requisitos de la interfaz:
        Una interfaz intuitiva para que los vendedores puedan gestionar sus productos y ventas desde dispositivos móviles o PCs.
        Funcionalidades como:
            Gestión de catálogo de productos.
            Registro y seguimiento de ventas diarias.
            Seguimiento de clientes y pagos.
            Panel de control para estadísticas de ventas, productos más vendidos, comisiones, etc.
        Ingreso de datos mediante menú desplegable predictivo para ciudades y barrios.
        Funcionalidad de búsqueda por cédula de identidad o nombre del cliente, integrando alertas por antecedentes judiciales.

    Tecnologías preferidas:
        Base de datos: PostgreSQL para manejar las relaciones entre clientes, productos, ventas, rutas, y otros datos clave del negocio. Posibilidad de utilizar un servidor Firebird si se quiere aprovechar la infraestructura existente.
        Frontend: React o Vue.js para la creación de una interfaz ágil y reactiva.
        Backend: Node.js con APIs RESTful para la integración de la base de datos y el frontend.
        Geolocalización: Integración con mapas GIS mediante GeoJSON, KML para gestionar rutas de ventas.

    Escalabilidad y Seguridad:
        El sistema debe ser escalable para soportar el crecimiento del negocio, permitiendo agregar más rutas, vendedores y clientes sin afectar el rendimiento.
        Protección de datos sensibles como cédulas de identidad, antecedentes judiciales y detalles de ventas mediante cifrado y control de acceso.

analiza el documento y de todas las opciones de bases de datos e interfaz presenta la mejor solución para Gabriela Fragancias
Para analizar y proporcionar la mejor solución para Gabriela Fragancias, es importante considerar las necesidades específicas de la empresa:
crear un prompt que permita hacerlo, resaltando el modo que funciona el negocio
Para desarrollar un sistema para Gabriela Fragancias, crea un prompt que tenga en cuenta los siguientes aspectos:

Descripción del negocio: Describe cómo funciona el negocio de Gabriela Fragancias, incluyendo venta, inventario y gestión de clientes.
Requisitos de las bases de datos: Indica la necesidad de almacenar productos, pedidos, y datos de clientes. Especifica el tipo de datos y relaciones entre ellos.
Funcionalidades de la interfaz: Define qué se necesita en la interfaz: gestión de catálogo, seguimiento de pedidos y panel de control para estadísticas.
Tecnología preferida: Menciona requerimientos tecnológicos o restricciones específicas si las hay.
Escalabilidad y seguridad: Subraya la importancia de que el sistema pueda crecer con el negocio y mantenga la seguridad de los datos.
Con esta información, tanto el código SQL como la interfaz podrían desarrollarse de manera efectiva para satisfacer las necesidades del negocio.

Tipo de datos y volumen: Si manejan grandes volúmenes de datos, una base de datos relacional como MySQL o PostgreSQL es eficiente. Para datos no estructurados, una base de datos NoSQL como MongoDB podría ser más adecuada.
Escalabilidad: Para un crecimiento rápido, Amazon Aurora o Google Cloud Spanner ofrecen escalabilidad y alta disponibilidad.
Interfaces: Una interfaz de usuario dinámica y fácil de usar puede lograrse con React o Vue.js. Esto facilita la gestión de productos y pedidos.
Integración: Usar APIs RESTful con Node.js proporciona flexibilidad para conectar la base de datos con la interfaz de usuario.
Considerando estos factores, una combinación de PostgreSQL por su robustez y React para la interfaz podría ser una solución ideal, garantizando eficiencia y escalabilidad para el futuro.

-- Tabla Vehiculos
CREATE TABLE Vehiculos (
    id_vehiculo SERIAL PRIMARY KEY,
    placa VARCHAR(20) UNIQUE NOT NULL,  -- Número de placa obligatorio y único
    marca VARCHAR(50),
    modelo VARCHAR(50),
    año INT,
    numero_motor VARCHAR(50) UNIQUE,  -- Número de motor obligatorio y único
    numero_chasis VARCHAR(50) UNIQUE, -- Número de chasis obligatorio y único
    fecha_revision DATE,  -- Fecha de última revisión técnica
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);


Estructura de la tabla DBF 'D:\PADRONES\Automotores\autocol.dbf':
Columna: CODIGO, Tipo: N
Columna: XXX, Tipo: C
Columna: COLOR, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\Automotores\automar.dbf':
Columna: CODIGO, Tipo: N
Columna: XXX, Tipo: C
Columna: COLOR, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\Automotores\autotip.dbf':
Columna: CODIGO, Tipo: N
Columna: XXX, Tipo: C
Columna: TIPOVEHIC, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\Automotores\autov1.dbf':
Columna: CLAVE, Tipo: N
Columna: MARCA, Tipo: N
Columna: MODELO, Tipo: N
Columna: TIPOVEHI, Tipo: N
Columna: CODDEP1, Tipo: N
Columna: CODDEP2, Tipo: N
Columna: NROCHAPA, Tipo: C
Columna: FECRECEP, Tipo: N
Columna: NROCHASIS, Tipo: C
Columna: NROMOTOR, Tipo: C
Columna: NROPROVID, Tipo: C
Columna: REMITIDO, Tipo: C
Columna: REMITIDA, Tipo: C
Columna: FCHREMI, Tipo: N
Columna: NOTAREMI, Tipo: N
Columna: ENTREGADO, Tipo: C
Columna: TIPODOCU, Tipo: C
Columna: CEDULA, Tipo: N
Columna: ACTANRO, Tipo: N
Columna: COLOR, Tipo: C
Columna: SITUACION, Tipo: C
Columna: OBSERVA, Tipo: C
Columna: DENUNCIA, Tipo: C
Columna: FCHDENU, Tipo: N
Columna: NOTADENU, Tipo: N
Columna: FCHENT, Tipo: N
Columna: TIPOROBO, Tipo: C
Columna: TITULOV, Tipo: C
Columna: CODIENTR, Tipo: N
Columna: SEPARTI, Tipo: C
Columna: HORA, Tipo: C
Columna: USUARIO, Tipo: C
Columna: FECHAGRA, Tipo: N
Columna: HORAGRA, Tipo: N
Columna: TEL_DENTE, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\Automotores\color.dbf':
Columna: CODIGO, Tipo: N
Columna: XXX, Tipo: C
Columna: COLOR, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\Automotores\dependencias.dbf':
Columna: CODIGO, Tipo: N
Columna: DESCRI, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\Automotores\FOXUSER.dbf':
Columna: TYPE, Tipo: C
Columna: ID, Tipo: C
Columna: NAME, Tipo: M
Columna: READONLY, Tipo: L
Columna: CKVAL, Tipo: N
Columna: DATA, Tipo: M
Columna: UPDATED, Tipo: D

Estructura de la tabla DBF 'D:\PADRONES\Automotores\histocons.dbf':
Columna: ID, Tipo: N
Columna: USUARIO, Tipo: C
Columna: TIPOCONS, Tipo: C
Columna: NROCED, Tipo: N
Columna: CLAVE, Tipo: N
Columna: SITUACION, Tipo: C
Columna: DEPEND, Tipo: C
Columna: FECHA, Tipo: T

Estructura de la tabla DBF 'D:\PADRONES\Automotores\Marca.dbf':
Columna: CODIGO, Tipo: N
Columna: XXX, Tipo: C
Columna: MARCA, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\Automotores\nacionalidades.dbf':
Columna: CLAVE, Tipo: N
Columna: DESCRI, Tipo: C

CREATE TABLE Personas (
    id_persona SERIAL PRIMARY KEY,
    cedula VARCHAR(20) UNIQUE NOT NULL,
    nombre VARCHAR(100) NOT NULL,
    apellido VARCHAR(100) NOT NULL,
    fecha_nacimiento DATE,
    direccion TEXT,
    departamento VARCHAR(100),
    distrito_municipio VARCHAR(100),
    barrio_localidad VARCHAR(100),
    zona VARCHAR(100),
    telefono VARCHAR(20),
    email VARCHAR(100) UNIQUE,
    fecha_defuncion DATE,  -- Campo para gestionar defunciones
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
);

-- Tabla AntecedentesJudiciales (para verificar los antecedentes de los clientes)
CREATE TABLE AntecedentesJudiciales (
    id_antecedente SERIAL PRIMARY KEY,
    cedula VARCHAR(20) REFERENCES Personas(cedula),
    causa_penal TEXT
);
Estructura de la tabla DBF 'D:\PADRONES\Automotores\poli01.dbf':
Columna: NROCED, Tipo: N
Columna: NROPRO, Tipo: N
Columna: APELLI, Tipo: C
Columna: NOMBRE, Tipo: C
Columna: IC, Tipo: C
Columna: ESTADO, Tipo: N
Columna: FECHANAC, Tipo: N
Columna: SEXO, Tipo: N
Columna: PROFESION, Tipo: N
Columna: LUEstructura de la tabla DBF 'D:\PADRONES\Automotores\cap001.dbf':
Columna: CIDCAP, Tipo: N
Columna: ORDEN, Tipo: N
Columna: CLAVE, Tipo: N
Columna: CAUSA, Tipo: C
Columna: UNIDAD, Tipo: N
Columna: FECNOTA, Tipo: N
Columna: NRONOTA, Tipo: N
Columna: COMPETE, Tipo: N
Columna: TURNO, Tipo: N
Columna: CIRCUN, Tipo: N
Columna: LUGARH, Tipo: C
Columna: JUEZ, Tipo: C
Columna: SECRETA, Tipo: C
Columna: INTERINO, Tipo: N
Columna: FECHAGRA, Tipo: N
Columna: USUARIO, Tipo: C
Columna: HORAGRA, Tipo: N
Columna: ESTADO, Tipo: C
Columna: OBSERVA, Tipo: C
Columna: RADIO, Tipo: C
Columna: FECRADIO, Tipo: N
Columna: UNIDAINF, Tipo: N
Columna: NOBRE, Tipo: C
Columna: GUARDI, Tipo: C
Columna: HORAGUA, Tipo: N
Columna: CREDEN, Tipo: N
Columna: SITU, Tipo: C
Columna: TIPOSE, Tipo: C
Columna: NROSE, Tipo: NGNAC, Tipo: C
Columna: NACIO, Tipo: N
Columna: NOMPAD, Tipo: C
Columna: NOMMAD, Tipo: C
Columna: NOMCONJ, Tipo: C
Columna: DOMICILIO, Tipo: C
Columna: NROPROPEN, Tipo: N
Columna: UBICACION, Tipo: N
Columna: USUARIO, Tipo: C
Columna: FECHAGRA, Tipo: N
Columna: SITUACION, Tipo: N
Columna: FECHAIMP, Tipo: N

Estructura de la tabla DBF 'D:\PADRONES\Consulta Padron 2013\data\difuntos.dbf':
Columna: CEDULA, Tipo: C
Columna: NOMBRE, Tipo: C
Columna: APELLIDO, Tipo: C
Columna: FEC_NAC, Tipo: D
Columna: FEC_DEF, Tipo: D

Estructura de la tabla DBF 'D:\PADRONES\padron_31-08-2010 (rcp2008.dbc)\data\regciv.dbf':
Columna: DEPART, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: ZONA, Tipo: N
Columna: LOCAL, Tipo: N
Columna: MESA, Tipo: N
Columna: ORDEN, Tipo: N
Columna: CEDULA, Tipo: C
Columna: NOMBRE, Tipo: C
Columna: APELLIDO, Tipo: C
Columna: ID_INTERNO, Tipo: N
Columna: NACIONAL, Tipo: C
Columna: SEXO, Tipo: C
Columna: FEC_NAC, Tipo: N
Columna: ESTATUS, Tipo: C
Columna: NAC, Tipo: N

Estructura de la tabla DBF 'D:\PADRONES\Consulta Padron 2013\data\pol_y_mil.dbf':
Columna: TIPO, Tipo: C
Columna: GRADO, Tipo: C
Columna: DEPART, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: ZONA, Tipo: N
Columna: LOCAL, Tipo: N
Columna: TALON, Tipo: N
Columna: BOLETA, Tipo: N
Columna: CEDULA, Tipo: C
Columna: FECINS, Tipo: D
Columna: NOMBRE, Tipo: C
Columna: APELLIDO, Tipo: C
Columna: FEC_NAC, Tipo: D
Columna: SEXO, Tipo: C
Columna: NACIONAL, Tipo: C
Columna: _NullFlags, Tipo: 0

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2013 Generales (rcp2008.dbc)\data\regciv_exte.dbf':
Columna: PAIS, Tipo: N
Columna: CIUDAD, Tipo: N
Columna: TIPO, Tipo: C
Columna: TALON, Tipo: N
Columna: BOLETA, Tipo: N
Columna: CEDULA, Tipo: C
Columna: FEC_INSCRI, Tipo: D
Columna: NOMBRE, Tipo: C
Columna: APELLIDO, Tipo: C
Columna: FEC_NAC, Tipo: D
Columna: SEXO, Tipo: C
Columna: NACIONAL, Tipo: C
Columna: DEPART_ULT, Tipo: N
Columna: DISTRI_ULT, Tipo: N
Columna: BARRIO, Tipo: C
Columna: PART, Tipo: C
Columna: SIGLAS, Tipo: C
Columna: DES_MENOR, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2020 (rcp2008.dbc)\data\inhabilitados.dbf':
Columna: DEPART, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: ZONA, Tipo: N
Columna: LOCAL, Tipo: N
Columna: TALON, Tipo: N
Columna: BOLETA, Tipo: N
Columna: CEDULA, Tipo: N
Columna: NOMBRE, Tipo: C
Columna: APELLIDO, Tipo: C
Columna: SEXO, Tipo: C
Columna: FEC_NAC, Tipo: D
Columna: FEC_DEFUNC, Tipo: D
Columna: FEC_INSCRI, Tipo: D
Columna: SERIE_BOLE, Tipo: N
Columna: DIRECCION, Tipo: C
Columna: LUGNAC, Tipo: C
Columna: BARRIO, Tipo: C
Columna: FECHA_EST, Tipo: D
Columna: DESCRI_EST, Tipo: C
Columna: ID_NACION, Tipo: N
Columna: ID_TIPOREG, Tipo: N
Columna: TIPO, Tipo: C
Columna: _NullFlags, Tipo: 0

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2013 Generales (rcp2008.dbc)-\data\deshabilitados.dbf':
Columna: DEPART, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: ZONA, Tipo: N
Columna: LOCAL, Tipo: N
Columna: TALON, Tipo: N
Columna: BOLETA, Tipo: N
Columna: FEC_INSCRI, Tipo: D
Columna: CEDULA, Tipo: C
Columna: NOMBRE, Tipo: C
Columna: APELLIDO, Tipo: C
Columna: FEC_NAC, Tipo: D
Columna: SEXO, Tipo: C
Columna: NACIONAL, Tipo: C
Columna: OBS, Tipo: C
Columna: _NullFlags, Tipo: 0

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2013 Generales (rcp2008.dbc)-\data\desh_exte.dbf':
Columna: PAIS, Tipo: N
Columna: CIUDAD, Tipo: N
Columna: TIPO, Tipo: C
Columna: TALON, Tipo: N
Columna: BOLETA, Tipo: N
Columna: FEC_INSCRI, Tipo: D
Columna: CEDULA, Tipo: C
Columna: NOMBRE, Tipo: C
Columna: APELLIDO, Tipo: C
Columna: FECHA_NACI, Tipo: D
Columna: BARRIO, Tipo: C
Columna: SEXO, Tipo: C
Columna: NACIONALID, Tipo: N
Columna: DESCRI_EST, Tipo: C

-- Tabla Rutas
CREATE TABLE Rutas (
    id_ruta SERIAL PRIMARY KEY,
    id_vendedor INTEGER REFERENCES Vendedores(id_vendedor),
    nombre_ruta VARCHAR(100) NOT NULL,
    fecha DATE DEFAULT CURRENT_DATE,
    zona VARCHAR(50),
    id_vehiculo INTEGER REFERENCES Vehiculos(id_vehiculo),
    coordenadas GEOGRAPHY(POINT, 4326),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- Tabla Tracking GPS
CREATE TABLE Tracking_GPS (
    id_tracking SERIAL PRIMARY KEY,
    id_vehiculo INTEGER REFERENCES Vehiculos(id_vehiculo),
    coordenadas GEOGRAPHY(POINT, 4326), -- Para almacenar latitud y longitud
    latitud DECIMAL(9,6),
    longitud DECIMAL(9,6),
    fecha_hora TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Tabla Departamento
CREATE TABLE Departamentos (
    id_departamento SERIAL PRIMARY KEY,
    nombre_departamento VARCHAR(100) NOT NULL,
    codigo_departamento VARCHAR(10) UNIQUE NOT NULL
);

-- Tabla Municipio
CREATE TABLE Municipios (
    id_municipio SERIAL PRIMARY KEY,
    id_departamento INTEGER REFERENCES Departamentos(id_departamento),
    nombre_municipio VARCHAR(100) NOT NULL,
    codigo_municipio VARCHAR(10) UNIQUE NOT NULL
);

-- Tabla Zonas o Ciudades
CREATE TABLE Zonas (
    id_zona SERIAL PRIMARY KEY,
    id_municipio INTEGER REFERENCES Municipios(id_municipio),
    nombre_zona VARCHAR(100) NOT NULL,
    codigo_zona VARCHAR(10) UNIQUE NOT NULL,
    geometria GEOGRAPHY(POLYGON, 4326) -- Definición de zonas geográficas
);

Estructura de la tabla DBF 'D:\PADRONES\Consulta Padron 2013\data\ciudades.dbf':
Columna: ID_PAIS, Tipo: N
Columna: ID_CIUDAD, Tipo: N
Columna: DES_CIUDAD, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\Consulta Padron 2013\data\dep.dbf':
Columna: DEPART, Tipo: N
Columna: DESCRIP, Tipo: C
Columna: TOT_HAB, Tipo: N
Columna: CAN_MESA, Tipo: N
 
Estructura de la tabla DBF 'D:\PADRONES\Consulta Padron 2013\data\dis.dbf':
Columna: DEPART, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: DESCRIP, Tipo: C 

Estructura de la tabla DBF 'D:\PADRONES\padron_31-08-2010 (rcp2008.dbc)\data\zon.dbf':
Columna: DEPART, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: ZONA, Tipo: N
Columna: DESCRIP, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2010 (PLRA)\barrios.dbf':
Columna: COD_DEP, Tipo: N
Columna: COD_DIS, Tipo: N
Columna: COD_ZON, Tipo: N
Columna: COD_LOC, Tipo: N
Columna: NOM_LOC, Tipo: C
Columna: NOM_ZON, Tipo: C
Columna: ABREVIADO, Tipo: C
Columna: TOTAL, Tipo: N
Columna: OBJETIVO, Tipo: N
Columna: INTERNA, Tipo: N
Columna: VOTANTES, Tipo: N
Columna: UNACE, Tipo: N
Columna: ANR, Tipo: N
Columna: SEGUROS, Tipo: C

<class 'pandas.core.frame.DataFrame'>
Index: 5 entries, type: "FeatureCollection" to }
Data columns (total 1 columns):
 #   Column  Non-Null Count  Dtype  
---  ------  --------------  -----  
 0   {       0 non-null      float64
dtypes: float64(1)
memory usage: 80.0+ bytes
Estructura del archivo D:/SOFTWARE/GPS\DATOSGOVPY\DISTRITOS_PY_CNPV2022.geojson.txt:
    Columnas: None

<class 'pandas.core.frame.DataFrame'>
RangeIndex: 39 entries, 0 to 38
Data columns (total 13 columns):
 #   Column                   Non-Null Count  Dtype  
---  ------                   --------------  -----  
 0   Date (MM-DD-YYYY)        39 non-null     object 
 1   Start Time               39 non-null     object 
 2   Origin Longitude         39 non-null     float64
 3   Origin Latitude          39 non-null     float64
 4   Destination Longitude    39 non-null     float64
 5   Destination Latitude     39 non-null     float64
 6   Origin                   39 non-null     object 
 7   Destination              39 non-null     object 
 8   Distance (km)            39 non-null     float64
 9    Time (min)              39 non-null     int64  
 10   Fuel Economy (l/100km)  39 non-null     float64
 11   Fuel Cost (PYG)         39 non-null     float64
 12   Carbon Footprint (kg)   39 non-null     float64
dtypes: float64(8), int64(1), object(4)
memory usage: 4.1+ KB
Estructura del archivo D:/SOFTWARE/GPS\Garmin\Backups\1CA616187\2022-06-27 (16.10.32)\Reports\mileage.csv:
    Columnas: None

<class 'pandas.core.frame.DataFrame'>
RangeIndex: 1 entries, 0 to 0
Data columns (total 1 columns):
 #   Column                         Non-Null Count  Dtype 
---  ------                         --------------  ----- 
 0   Install program and close it.  1 non-null      object
dtypes: object(1)
memory usage: 140.0+ bytes
Estructura del archivo D:/SOFTWARE/GPS\GDS Google Map Desktop Control v8.0.0 for WinForms & WPF + Keygen\Patch_Keygen\Readme.txt:
    Columnas: None

Estructura del archivo D:/SOFTWARE/GPS\INEC\CARTOGRAFÍA\00 ASUNCIÓN\Barrios_Localidades_Asuncion.dbf:
    Columnas: [{'Nombre': 'DPTO', 'Tipo': 'C'}, {'Nombre': 'DISTRITO', 'Tipo': 'C'}, {'Nombre': 'DPTO_DESC', 'Tipo': 'C'}, {'Nombre': 'DIST_DESC', 'Tipo': 'C'}, {'Nombre': 'AREA', 'Tipo': 'C'}, {'Nombre': 'BAR_LOC', 'Tipo': 'C'}, {'Nombre': 'BARLO_DESC', 'Tipo': 'C'}, {'Nombre': 'CLAVE', 'Tipo': 'C'}]

Estructura del archivo D:/SOFTWARE/GPS\INEC\CARTOGRAFÍA\00 ASUNCIÓN\Ciudades_Asuncion.dbf:
    Columnas: [{'Nombre': 'DPTO', 'Tipo': 'C'}, {'Nombre': 'DPTO_DESC', 'Tipo': 'C'}, {'Nombre': 'DISTRITO', 'Tipo': 'C'}, {'Nombre': 'DIST_DESC', 'Tipo': 'C'}, {'Nombre': 'CLAVE', 'Tipo': 'C'}]

Estructura del archivo D:/SOFTWARE/GPS\INEC\CARTOGRAFÍA\00 ASUNCIÓN\Departamento_Asuncion.dbf:
    Columnas: [{'Nombre': 'DPTO', 'Tipo': 'C'}, {'Nombre': 'DPTO_DESC', 'Tipo': 'C'}]

Estructura del archivo D:/SOFTWARE/GPS\INEC\CARTOGRAFÍA\00 ASUNCIÓN\Distritos_Asuncion.dbf:
    Columnas: [{'Nombre': 'DPTO', 'Tipo': 'C'}, {'Nombre': 'DISTRITO', 'Tipo': 'C'}, {'Nombre': 'DPTO_DESC', 'Tipo': 'C'}, {'Nombre': 'DIST_DESC', 'Tipo': 'C'}, {'Nombre': 'CLAVE', 'Tipo': 'C'}]

Estructura del archivo D:/SOFTWARE/GPS\INEC\CARTOGRAFÍA\00 ASUNCIÓN\Hidrografia_Asuncion.dbf:
    Columnas: [{'Nombre': 'NOMBRE', 'Tipo': 'C'}]

Estructura del archivo D:/SOFTWARE/GPS\INEC\CARTOGRAFÍA\00 ASUNCIÓN\Manzanas_Asuncion.dbf:
    Columnas: [{'Nombre': 'DISTRITO', 'Tipo': 'C'}, {'Nombre': 'AREA', 'Tipo': 'C'}, {'Nombre': 'MANZANA', 'Tipo': 'C'}, {'Nombre': 'DPTO', 'Tipo': 'C'}, {'Nombre': 'DPTO_DESC', 'Tipo': 'C'}, {'Nombre': 'DIST_DESC', 'Tipo': 'C'}, {'Nombre': 'BAR_LOC', 'Tipo': 'C'}, {'Nombre': 'BARLO_DESC', 'Tipo': 'C'}, {'Nombre': 'CLAVE', 'Tipo': 'C'}]

Estructura del archivo D:/SOFTWARE/GPS\INEC\CARTOGRAFÍA\00 ASUNCIÓN\Vias principales_Asuncion.dbf:
    Columnas: [{'Nombre': 'NOMBRE', 'Tipo': 'C'}, {'Nombre': 'LONG_KM_EN', 'Tipo': 'N'}, {'Nombre': 'RUTA_NRO', 'Tipo': 'C'}, {'Nombre': 'ANCHO', 'Tipo': 'N'}, {'Nombre': 'TIPO', 'Tipo': 'N'}, {'Nombre': 'LONG_MTS', 'Tipo': 'N'}]

Estructura del archivo D:/SOFTWARE/GPS\INEC\CARTOGRAFÍA\00 ASUNCIÓN\Vias_Asuncion.dbf:
    Columnas: [{'Nombre': 'NOMBRE', 'Tipo': 'C'}, {'Nombre': 'ANCHO', 'Tipo': 'N'}, {'Nombre': 'TIPO', 'Tipo': 'N'}, {'Nombre': 'PAVIMENTO', 'Tipo': 'C'}, {'Nombre': 'DPTO', 'Tipo': 'C'}, {'Nombre': 'DPTO_DESC', 'Tipo': 'C'}]

Estructura del archivo D:/SOFTWARE/GPS\INEC\CARTOGRAFÍA\Códigos cartográficos\LOCALES_DE_SALUD_DGEEC2012.dbf:
    Columnas: [{'Nombre': 'DPTO', 'Tipo': 'C'}, {'Nombre': 'DPTO_DESC', 'Tipo': 'C'}, {'Nombre': 'DISTRITO', 'Tipo': 'C'}, {'Nombre': 'DIST_DESC', 'Tipo': 'C'}, {'Nombre': 'NOMBRE', 'Tipo': 'C'}, {'Nombre': 'LONGITUD', 'Tipo': 'N'}, {'Nombre': 'LATITUD', 'Tipo': 'N'}]

Estructura del archivo D:/SOFTWARE/GPS\INEC\CARTOGRAFÍA\Códigos cartográficos\LOCALES_EDUCATIVOS_DGEEC2012.dbf:
    Columnas: [{'Nombre': 'DPTO', 'Tipo': 'C'}, {'Nombre': 'DPTO_DESC', 'Tipo': 'C'}, {'Nombre': 'DISTRITO', 'Tipo': 'C'}, {'Nombre': 'DIST_DESC', 'Tipo': 'C'}, {'Nombre': 'NOMBRE', 'Tipo': 'C'}, {'Nombre': 'LONGITUD', 'Tipo': 'N'}, {'Nombre': 'LATITUD', 'Tipo': 'N'}]

Estructura del archivo D:/SOFTWARE/GPS\INEC\CARTOGRAFÍA\Códigos cartográficos\LOCALES_POLICIALES_DGEEC2012.dbf:
    Columnas: [{'Nombre': 'DPTO', 'Tipo': 'C'}, {'Nombre': 'DPTO_DESC', 'Tipo': 'C'}, {'Nombre': 'DISTRITO', 'Tipo': 'C'}, {'Nombre': 'DIST_DESC', 'Tipo': 'C'}, {'Nombre': 'NOMBRE', 'Tipo': 'C'}, {'Nombre': 'LONGITUD', 'Tipo': 'N'}, {'Nombre': 'LATITUD', 'Tipo': 'N'}]

Estructura del archivo D:/SOFTWARE/GPS\INEC\CARTOGRAFÍA\PAIS\Barrios_Localidades_Paraguay.dbf:
    Columnas: [{'Nombre': 'DPTO', 'Tipo': 'C'}, {'Nombre': 'DISTRITO', 'Tipo': 'C'}, {'Nombre': 'DPTO_DESC', 'Tipo': 'C'}, {'Nombre': 'DIST_DESC', 'Tipo': 'C'}, {'Nombre': 'AREA', 'Tipo': 'C'}, {'Nombre': 'BAR_LOC', 'Tipo': 'C'}, {'Nombre': 'BARLO_DESC', 'Tipo': 'C'}, {'Nombre': 'CLAVE', 'Tipo': 'C'}]

Estructura del archivo D:/SOFTWARE/GPS\INEC\CARTOGRAFÍA\PAIS\Ciudades_Paraguay.dbf:
    Columnas: [{'Nombre': 'DPTO', 'Tipo': 'C'}, {'Nombre': 'DPTO_DESC', 'Tipo': 'C'}, {'Nombre': 'DISTRITO', 'Tipo': 'C'}, {'Nombre': 'DIST_DESC', 'Tipo': 'C'}, {'Nombre': 'CLAVE', 'Tipo': 'C'}]

Estructura del archivo D:/SOFTWARE/GPS\INEC\CARTOGRAFÍA\PAIS\Comunidades_Indigenas_Paraguay.dbf:
    Columnas: [{'Nombre': 'DPTO', 'Tipo': 'C'}, {'Nombre': 'DISTRITO', 'Tipo': 'C'}, {'Nombre': 'DPTO_DESC', 'Tipo': 'C'}, {'Nombre': 'DIST_DESC', 'Tipo': 'C'}, {'Nombre': 'AREA', 'Tipo': 'C'}, {'Nombre': 'BAR_LOC', 'Tipo': 'C'}, {'Nombre': 'BARLO_DESC', 'Tipo': 'C'}, {'Nombre': 'COMUNIDAD', 'Tipo': 'C'}, {'Nombre': 'ALDEA', 'Tipo': 'C'}, {'Nombre': 'COM_DESC', 'Tipo': 'C'}, {'Nombre': 'PUEBLO_ETN', 'Tipo': 'C'}, {'Nombre': 'COD_PUEBLO', 'Tipo': 'C'}, {'Nombre': 'FAMILIA', 'Tipo': 'C'}]

Estructura del archivo D:/SOFTWARE/GPS\INEC\CARTOGRAFÍA\PAIS\Departamentos_Paraguay.dbf:
    Columnas: [{'Nombre': 'DPTO', 'Tipo': 'C'}, {'Nombre': 'DPTO_DESC', 'Tipo': 'C'}]

Estructura del archivo D:/SOFTWARE/GPS\INEC\CARTOGRAFÍA\PAIS\Distritos_Paraguay.dbf:
    Columnas: [{'Nombre': 'OBJECTID_1', 'Tipo': 'N'}, {'Nombre': 'DPTO', 'Tipo': 'C'}, {'Nombre': 'DISTRITO', 'Tipo': 'C'}, {'Nombre': 'DPTO_DESC', 'Tipo': 'C'}, {'Nombre': 'DIST_DESC', 'Tipo': 'C'}, {'Nombre': 'CLAVE', 'Tipo': 'C'}]

Estructura del archivo D:/SOFTWARE/GPS\INEC\CARTOGRAFÍA\PAIS\Hidrografia_Paraguay.dbf:
    Columnas: [{'Nombre': 'NOMBRE', 'Tipo': 'C'}]

Estructura del archivo D:/SOFTWARE/GPS\INEC\CARTOGRAFÍA\PAIS\Manzanas_Paraguay.dbf:
    Columnas: [{'Nombre': 'DISTRITO', 'Tipo': 'C'}, {'Nombre': 'AREA', 'Tipo': 'C'}, {'Nombre': 'MANZANA', 'Tipo': 'C'}, {'Nombre': 'DPTO', 'Tipo': 'C'}, {'Nombre': 'DPTO_DESC', 'Tipo': 'C'}, {'Nombre': 'DIST_DESC', 'Tipo': 'C'}, {'Nombre': 'BAR_LOC', 'Tipo': 'C'}, {'Nombre': 'BARLO_DESC', 'Tipo': 'C'}, {'Nombre': 'CLAVE', 'Tipo': 'C'}]

Estructura del archivo D:/SOFTWARE/GPS\INEC\CARTOGRAFÍA\PAIS\Vias principales_Paraguay.dbf:
    Columnas: [{'Nombre': 'NOMBRE', 'Tipo': 'C'}, {'Nombre': 'LONG_KM_EN', 'Tipo': 'N'}, {'Nombre': 'RUTA_NRO', 'Tipo': 'C'}, {'Nombre': 'ANCHO', 'Tipo': 'N'}, {'Nombre': 'TIPO', 'Tipo': 'N'}, {'Nombre': 'LONG_MTS', 'Tipo': 'N'}]

Estructura del archivo D:/SOFTWARE/GPS\INEC\CARTOGRAFÍA\PAIS\Vias_Paraguay.dbf:
    Columnas: [{'Nombre': 'NOMBRE', 'Tipo': 'C'}, {'Nombre': 'TIPO', 'Tipo': 'N'}, {'Nombre': 'ANCHO', 'Tipo': 'N'}, {'Nombre':
	
D:\PADRONES\Consulta Padron 2013\data\deshabilitados.dbf
D:\PADRONES\Consulta Padron 2013\data\desh_exte.dbf
D:\PADRONES\Consulta Padron 2013\data\difuntos.dbf
D:\PADRONES\Consulta Padron 2013\data\dobles.dbf
D:\PADRONES\Consulta Padron 2013\data\extranjeros.dbf
D:\PADRONES\Consulta Padron 2013\data\interdictos.dbf
D:\PADRONES\Consulta Padron 2013\data\menores.dbf
D:\PADRONES\Consulta Padron 2013\data\nacionalidades.dbf
D:\PADRONES\Consulta Padron 2013\data\part.dbf
D:\PADRONES\Consulta Padron 2013\data\pol_y_mil.dbf'DPTO', 'Tipo': 'C'}, {'Nombre': 'DPTO_DESC', 'Tipo': 'C'}]
D:\PADRONES\RUC\RUC.dbf
D:\PADRONES\RUC\RUC2017.dbf
D:\PADRONES\SATI\DATOS\cedauto.dbf
D:\PADRONES\SATI\DATOS\celulares.DBF
D:\PADRONES\SATI\DATOS\provisorios.dbf
D:\PADRONES\unixODBC-2.3.12
D:\SOFTWARE\GPS\INEC\CARTOGRAFÍA\PAIS\Barrios_Localidades_Paraguay.dbf
D:\SOFTWARE\GPS\INEC\CARTOGRAFÍA\PAIS\Ciudades_Paraguay.dbf
D:\SOFTWARE\GPS\INEC\CARTOGRAFÍA\PAIS\Comunidades_Indigenas_Paraguay.dbf
D:\SOFTWARE\GPS\INEC\CARTOGRAFÍA\PAIS\Departamentos_Paraguay.dbf
D:\SOFTWARE\GPS\INEC\CARTOGRAFÍA\PAIS\Distritos_Paraguay.dbf
D:\SOFTWARE\GPS\INEC\CARTOGRAFÍA\PAIS\Hidrografia_Paraguay.dbf
D:\SOFTWARE\GPS\INEC\CARTOGRAFÍA\PAIS\Manzanas_Paraguay.dbf
D:\SOFTWARE\GPS\INEC\CARTOGRAFÍA\PAIS\Vias principales_Paraguay.dbf
D:\SOFTWARE\GPS\INEC\CARTOGRAFÍA\PAIS\Vias_Paraguay.dbf
D:\PADRONES\Automotores\cap001.dbf
D:\PADRONES\Automotores\poli01.dbf
D:\PADRONES\Padrón 2010 (rcp2008.dbc)\data\deshabilitados.DBF
D:\PADRONES\Padrón 2010 (rcp2008.dbc)\data\desh_exte.dbf
D:\PADRONES\Padrón 2010 (rcp2008.dbc)\data\difuntos.dbf
D:\PADRONES\Padrón 2010 (rcp2008.dbc)\data\dobles.dbf
D:\PADRONES\Padrón 2010 (rcp2008.dbc)\data\inhabilitados.dbf
D:\PADRONES\Padrón 2010 (rcp2008.dbc)\data\interdictos.dbf
D:\PADRONES\Padrón 2010 (rcp2008.dbc)\data\menores.dbf
D:\PADRONES\Padrón 2010 (rcp2008.dbc)\data\part.DBF
D:\PADRONES\Padrón 2010 (rcp2008.dbc)\data\pol_y_mil.dbf
D:\PADRONES\Padrón 2010 (rcp2008.dbc)\data\regciv.dbf
D:\PADRONES\Padrón 2010 (rcp2008.dbc)\data\regciv_exte.dbf
D:\PADRONES\Padrón 2010 (rcp2008.dbc) 31-08\data\deshabilitados.DBF
D:\PADRONES\Padrón 2010 (rcp2008.dbc) 31-08\data\difuntos.dbf
D:\PADRONES\Padrón 2010 (rcp2008.dbc) 31-08\data\dobles.DBF
D:\PADRONES\Padrón 2010 (rcp2008.dbc) 31-08\data\interdictos.dbf
D:\PADRONES\Padrón 2010 (rcp2008.dbc) 31-08\data\menores.dbf
D:\PADRONES\Padrón 2010 (rcp2008.dbc) 31-08\data\part.dbf
D:\PADRONES\Padrón 2010 (rcp2008.dbc) 31-08\data\pol_y_mil.dbf
D:\PADRONES\Padrón 2010 (rcp2008.dbc) 31-08\data\regciv.dbf
D:\PADRONES\Padrón 2013 Generales (rcp2008.dbc)\data\deshabilitados.dbf
D:\PADRONES\Padrón 2013 Generales (rcp2008.dbc)\data\desh_exte.dbf
D:\PADRONES\Padrón 2013 Generales (rcp2008.dbc)\data\difuntos.dbf
D:\PADRONES\Padrón 2013 Generales (rcp2008.dbc)\data\dobles.dbf
D:\PADRONES\Padrón 2013 Generales (rcp2008.dbc)\data\extranjeros.dbf
D:\PADRONES\Padrón 2013 Generales (rcp2008.dbc)\data\interdictos.dbf
D:\PADRONES\Padrón 2013 Generales (rcp2008.dbc)\data\menores.dbf
D:\PADRONES\Padrón 2013 Generales (rcp2008.dbc)\data\nacionalidades.dbf
D:\PADRONES\Padrón 2013 Generales (rcp2008.dbc)\data\part.dbf
D:\PADRONES\Padrón 2013 Generales (rcp2008.dbc)\data\pol_y_mil.dbf
D:\PADRONES\Padrón 2013 Generales (rcp2008.dbc)\data\regciv.dbf
D:\PADRONES\Padrón 2013 Generales (rcp2008.dbc)\data\regciv_exte.dbf
D:\PADRONES\Padrón 2013 Generales (rcp2008.dbc)-\data\deshabilitados.dbf
D:\PADRONES\Padrón 2013 Generales (rcp2008.dbc)-\data\desh_exte.dbf
D:\PADRONES\Padrón 2013 Generales (rcp2008.dbc)-\data\difuntos.dbf
D:\PADRONES\Padrón 2013 Generales (rcp2008.dbc)-\data\dobles.dbf
D:\PADRONES\Padrón 2013 Generales (rcp2008.dbc)-\data\extranjeros.dbf
D:\PADRONES\Padrón 2013 Generales (rcp2008.dbc)-\data\interdictos.dbf
D:\PADRONES\Padrón 2013 Generales (rcp2008.dbc)-\data\menores.dbf
D:\PADRONES\Padrón 2013 Generales (rcp2008.dbc)-\data\nacionalidades.dbf
D:\PADRONES\Padrón 2013 Generales (rcp2008.dbc)-\data\part.dbf
D:\PADRONES\Padrón 2013 Generales (rcp2008.dbc)-\data\pol_y_mil.dbf
D:\PADRONES\Padrón 2015 (rcp2008.dbc)\data\desh_exte.dbf
D:\PADRONES\Padrón 2015 (rcp2008.dbc)\data\dobles.dbf
D:\PADRONES\Padrón 2015 (rcp2008.dbc)\data\inhabilitados.dbff
D:\PADRONES\Padrón 2015 (rcp2008.dbc)\data\part.DBF
D:\PADRONES\Padrón 2015 (rcp2008.dbc)\data\regciv.dbf
D:\PADRONES\Padrón 2015 (rcp2008.dbc)\data\regciv_exte.dbf
D:\PADRONES\Padrón 2017 HC (datos.dbc)\mas_pda.dbf
D:\PADRONES\Padrón 2017 pre ANR (datos.dbc)\mas_pda.dbf
D:\PADRONES\Padrón 2018 (rcp2008.dbc)\data\desh_exte.dbf
D:\PADRONES\Padrón 2018 (rcp2008.dbc)\data\dobles.dbf
D:\PADRONES\Padrón 2018 (rcp2008.dbc)\data\inhabilitados.dbf
D:\PADRONES\Padrón 2018 (rcp2008.dbc)\data\part.DBF
D:\PADRONES\Padrón 2018 (rcp2008.dbc)\data\regciv.dbf
D:\PADRONES\Padrón 2018 (rcp2008.dbc)\data\regciv_exte.dbf
D:\PADRONES\Padrón 2020 (rcp2008.dbc)\data\desh_exte.dbf
D:\PADRONES\Padrón 2020 (rcp2008.dbc)\data\dobles.dbf
D:\PADRONES\Padrón 2020 (rcp2008.dbc)\data\inhabilitados.dbf
D:\PADRONES\Padrón 2020 (rcp2008.dbc)\data\part.DBF
D:\PADRONES\Padrón 2020 (rcp2008.dbc)\data\regciv.dbf
D:\PADRONES\Padrón 2020 (rcp2008.dbc)\data\regciv_exte.dbf
D:\PADRONES\Padrón 2021\data\desh_exte.dbf
D:\PADRONES\Padrón 2021\data\dobles.dbf
D:\PADRONES\Padrón 2021\data\inhabilitados.dbf
D:\PADRONES\Padrón 2021\data\part.DBF
D:\PADRONES\Padrón 2021\data\regciv.dbf
D:\PADRONES\Padrón 2021\data\regciv_exte.dbf
D:\PADRONES\Padrón 2021 (rcp2008.dbc)\regciv.dbf
D:\PADRONES\Padrón 2021 (rcp2008.dbc)\data\desh_exte.dbf
D:\PADRONES\Padrón 2021 (rcp2008.dbc)\data\dobles.dbf
D:\PADRONES\Padrón 2021 (rcp2008.dbc)\data\inhabilitados.dbf
D:\PADRONES\Padrón 2021 (rcp2008.dbc)\data\nacionalidades.dbf
D:\PADRONES\Padrón 2021 (rcp2008.dbc)\data\part.DBF
D:\PADRONES\Padrón 2021 (rcp2008.dbc)\data\regciv.dbf
D:\PADRONES\Padrón 2021 (rcp2008.dbc)\data\regciv_exte.dbf
D:\PADRONES\Padrón 2021 ANR (datos.dbc)\mas_pda.DBF
D:\PADRONES\Padrón UNACE (rcp2008.dbc)\data\deshabilitados.DBF
D:\PADRONES\Padrón UNACE (rcp2008.dbc)\data\difuntos.dbf
D:\PADRONES\Padrón UNACE (rcp2008.dbc)\data\dobles.DBF
D:\PADRONES\Padrón UNACE (rcp2008.dbc)\data\interdictos.dbf
D:\PADRONES\Padrón UNACE (rcp2008.dbc)\data\menores.dbf
D:\PADRONES\Padrón UNACE (rcp2008.dbc)\data\part.dbf
D:\PADRONES\Padrón UNACE (rcp2008.dbc)\data\pol_y_mil.dbf
D:\PADRONES\Padrón UNACE (rcp2008.dbc)\data\regciv.dbf


Para importar los datos de las distintas tablas DBF a la tabla Personas, puedes utilizar consultas de inserción que seleccionen los datos relevantes de cada tabla. Aquí te dejo un ejemplo de cómo podrías hacerlo:

    Importar datos de la tabla "difuntos.dbf":

INSERT INTO Personas (cedula, nombre, apellido, fecha_nacimiento, fecha_defuncion)
SELECT CEDULA, NOMBRE, APELLIDO, FEC_NAC, FEC_DEF
FROM difuntos;
		

    Importar datos de la tabla "regciv.dbf":

INSERT INTO Personas (cedula, nombre, apellido, departamento, distrito_municipio, zona, barrio_localidad, fecha_nacimiento)
SELECT CEDULA, NOMBRE, APELLIDO, DEPART, DISTRITO, ZONA, LOCAL, FEC_NAC
FROM regciv;
		

    Importar datos de la tabla "pol_y_mil.dbf":

INSERT INTO Personas (cedula, nombre, apellido, departamento, distrito_municipio, zona, fecha_nacimiento)
SELECT CEDULA, NOMBRE, APELLIDO, DEPART, DISTRITO, ZONA, FEC_NAC
FROM pol_y_mil;
		

    Importar datos de la tabla "regciv_exte.dbf":

INSERT INTO Personas (cedula, nombre, apellido, fecha_nacimiento, nacionalidad)
SELECT CEDULA, NOMBRE, APELLIDO, FEC_NAC, NACIONAL
FROM regciv_exte;
		
Claro, aquí te dejo un ejemplo de cómo podrías modificar los scripts de inserción para seleccionar solo las columnas que te interesan y omitir las cédulas que ya han sido ingresadas en la tabla Personas:

    Importar datos de la tabla "difuntos.dbf":

INSERT INTO Personas (cedula, nombre, apellido, fecha_nacimiento, fecha_defuncion)
SELECT CEDULA, NOMBRE, APELLIDO, FEC_NAC, FEC_DEF
FROM difuntos
WHERE CEDULA NOT IN (SELECT cedula FROM Personas);
		

    Importar datos de la tabla "regciv.dbf":

INSERT INTO Personas (cedula, nombre, apellido, departamento, distrito_municipio, zona, barrio_localidad, fecha_nacimiento)
SELECT CEDULA, NOMBRE, APELLIDO, DEPART, DISTRITO, ZONA, LOCAL, FEC_NAC
FROM regciv
WHERE CEDULA NOT IN (SELECT cedula FROM Personas);
		

    Importar datos de la tabla "pol_y_mil.dbf":

INSERT INTO Personas (cedula, nombre, apellido, departamento, distrito_municipio, zona, fecha_nacimiento)
SELECT CEDULA, NOMBRE, APELLIDO, DEPART, DISTRITO, ZONA, FEC_NAC
FROM pol_y_mil
WHERE CEDULA NOT IN (SELECT cedula FROM Personas);
		

    Importar datos de la tabla "regciv_exte.dbf":

INSERT INTO Personas (cedula, nombre, apellido, fecha_nacimiento, nacionalidad)
SELECT CEDULA, NOMBRE, APELLIDO, FEC_NAC, NACIONAL
FROM regciv_exte
WHERE CEDULA NOT IN (SELECT cedula FROM Personas);
		

Con este cambio, cada script de inserción verificará si la cédula ya existe en la tabla Personas antes de insertar los datos. De esta manera, evitarás errores de clave duplicada durante la inserción.

Recuerda que estos scripts son solo un ejemplo y tendrás que adaptarlos a tus necesidades específicas y a la estructura real de tus tablas DBF.

es necesario ingresar la ruta del archivo o se selecciona

Si estás trabajando con un sistema de gestión de bases de datos que soporta el acceso directo a archivos DBF, como MySQL o PostgreSQL con el módulo ODBC, puedes utilizar la función CONNECT para establecer una conexión a los archivos DBF y luego hacer consultas sobre ellos como si fueran tablas normales.

Por ejemplo, para conectarte a un archivo DBF en MySQL, puedes usar el siguiente comando:

CONNECT 'D:\PADRONES\Consulta Padron 2013\data\difuntos.dbf' AS difuntos;
		

Una vez establecida la conexión, puedes hacer consultas sobre la tabla difuntos como si fuera una tabla normal en tu base de datos.

Si estás trabajando con otro sistema de gestión de bases de datos que no soporta el acceso directo a archivos DBF, tendrás que importar los datos a tu base de datos antes de poder hacer consultas sobre ellos. En este caso, puedes utilizar una herramienta de migración de datos o escribir un script personalizado que lea los archivos DBF y ejecute consultas de inserción en tu base de datos.

En cualquier caso, es importante tener en cuenta la ruta de los archivos DBF y asegurarte de que sean accesibles desde el sistema de gestión de bases de datos que estés utilizando.

como conectar en postgesql

Para conectarte a archivos DBF desde PostgreSQL, puedes utilizar la extensión odbc_fdw, que te permite acceder a fuentes de datos ODBC externas como si fueran tablas de PostgreSQL. Aquí te dejo los pasos para configurar y usar odbc_fdw:

    Instala el gestor de conexiones UnixODBC en tu sistema. Puedes seguir las instrucciones de instalación para tu sistema operativo en el sitio oficial de UnixODBC: <http://www.unixodbc.org/>

    Instala el controlador ODBC para DBF. Hay varios controladores disponibles, como el controlador de Microsoft o el controlador de OpenLink Software. Sigue las instrucciones de instalación del controlador que elijas.

    Configura el origen de datos ODBC en el archivo odbc.ini. Asegúrate de especificar la ruta correcta a tus archivos DBF en la configuración. Por ejemplo:

    [PadronesDBF]
    Description = Mis archivos DBF
    Driver = /path/to/your/dbf/driver
    Database = /path/to/your/dbf/files

    Instala la extensión odbc_fdw en tu base de datos PostgreSQL:

    CREATE EXTENSION odbc_fdw;

    Crea un servidor externo que se conecte a tu origen de datos ODBC:

    CREATE SERVER padrones_server
    FOREIGN DATA WRAPPER odbc_fdw
    OPTIONS (dsn 'PadronesDBF');

    Crea una tabla externa que represente a tu archivo DBF:

    CREATE FOREIGN TABLE difuntos (
        cedula VARCHAR(20),
        nombre VARCHAR(100),
        apellido VARCHAR(100),
        fec_nac DATE,
        fec_def DATE
    ) SERVER padrones_server
    OPTIONS (schema 'DIFUNTOS');

    Asegúrate de ajustar la definición de la tabla y las opciones según la estructura real de tu archivo DBF.

Una vez que hayas completado estos pasos, podrás hacer consultas sobre la tabla difuntos como si fuera una tabla normal en tu base de datos PostgreSQL.

Ten en cuenta que este es solo un ejemplo y tendrás que adaptar los comandos y configuraciones a tus necesidades específicas y a la estructura real de tus archivos DBF.

ogr2ogr -f "PostgreSQL" PG:"dbname=your_database user=your_user password=your_password" "D:\PADRONES\Consulta Padron 2013\data\deshabilitados.dbf" -nln deshabilitados

Estructura de la tabla DBF 'D:\PADRONES\Automotores\autov1.dbf':
Columna: CLAVE, Tipo: N
Columna: MARCA, Tipo: N
Columna: MODELO, Tipo: N
Columna: TIPOVEHI, Tipo: N
Columna: CODDEP1, Tipo: N
Columna: CODDEP2, Tipo: N
Columna: NROCHAPA, Tipo: C
Columna: FECRECEP, Tipo: N
Columna: NROCHASIS, Tipo: C
Columna: NROMOTOR, Tipo: C
Columna: NROPROVID, Tipo: C
Columna: REMITIDO, Tipo: C
Columna: REMITIDA, Tipo: C
Columna: FCHREMI, Tipo: N
Columna: NOTAREMI, Tipo: N
Columna: ENTREGADO, Tipo: C
Columna: TIPODOCU, Tipo: C
Columna: CEDULA, Tipo: N
Columna: ACTANRO, Tipo: N
Columna: COLOR, Tipo: C
Columna: SITUACION, Tipo: C
Columna: OBSERVA, Tipo: C
Columna: DENUNCIA, Tipo: C
Columna: FCHDENU, Tipo: N
Columna: NOTADENU, Tipo: N
Columna: FCHENT, Tipo: N
Columna: TIPOROBO, Tipo: C
Columna: TITULOV, Tipo: C
Columna: CODIENTR, Tipo: N
Columna: SEPARTI, Tipo: C
Columna: HORA, Tipo: C
Columna: USUARIO, Tipo: C
Columna: FECHAGRA, Tipo: N
Columna: HORAGRA, Tipo: N
Columna: TEL_DENTE, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\Automotores\cap001.dbf':
Columna: CIDCAP, Tipo: N
Columna: ORDEN, Tipo: N
Columna: CLAVE, Tipo: N
Columna: CAUSA, Tipo: C
Columna: UNIDAD, Tipo: N
Columna: FECNOTA, Tipo: N
Columna: NRONOTA, Tipo: N
Columna: COMPETE, Tipo: N
Columna: TURNO, Tipo: N
Columna: CIRCUN, Tipo: N
Columna: LUGARH, Tipo: C
Columna: JUEZ, Tipo: C
Columna: SECRETA, Tipo: C
Columna: INTERINO, Tipo: N
Columna: FECHAGRA, Tipo: N
Columna: USUARIO, Tipo: C
Columna: HORAGRA, Tipo: N
Columna: ESTADO, Tipo: C
Columna: OBSERVA, Tipo: C
Columna: RADIO, Tipo: C
Columna: FECRADIO, Tipo: N
Columna: UNIDAINF, Tipo: N
Columna: NOBRE, Tipo: C
Columna: GUARDI, Tipo: C
Columna: HORAGUA, Tipo: N
Columna: CREDEN, Tipo: N
Columna: SITU, Tipo: C
Columna: TIPOSE, Tipo: C
Columna: NROSE, Tipo: N

Estructura de la tabla DBF 'D:\PADRONES\Automotores\color.dbf':
Columna: CODIGO, Tipo: N
Columna: XXX, Tipo: C
Columna: COLOR, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\Automotores\dependencias.dbf':
Columna: CODIGO, Tipo: N
Columna: DESCRI, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\Automotores\FOXUSER.dbf':
Columna: TYPE, Tipo: C
Columna: ID, Tipo: C
Columna: NAME, Tipo: M
Columna: READONLY, Tipo: L
Columna: CKVAL, Tipo: N
Columna: DATA, Tipo: M
Columna: UPDATED, Tipo: D

Estructura de la tabla DBF 'D:\PADRONES\Automotores\histocons.dbf':
Columna: ID, Tipo: N
Columna: USUARIO, Tipo: C
Columna: TIPOCONS, Tipo: C
Columna: NROCED, Tipo: N
Columna: CLAVE, Tipo: N
Columna: SITUACION, Tipo: C
Columna: DEPEND, Tipo: C
Columna: FECHA, Tipo: T

Estructura de la tabla DBF 'D:\PADRONES\Automotores\Marca.dbf':
Columna: CODIGO, Tipo: N
Columna: XXX, Tipo: C
Columna: MARCA, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\Automotores\nacionalidades.dbf':
Columna: CLAVE, Tipo: N
Columna: DESCRI, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\Automotores\poli01.dbf':
Columna: NROCED, Tipo: N
Columna: NROPRO, Tipo: N
Columna: APELLI, Tipo: C
Columna: NOMBRE, Tipo: C
Columna: IC, Tipo: C
Columna: ESTADO, Tipo: N
Columna: FECHANAC, Tipo: N
Columna: SEXO, Tipo: N
Columna: PROFESION, Tipo: N
Columna: LUGNAC, Tipo: C
Columna: NACIO, Tipo: N
Columna: NOMPAD, Tipo: C
Columna: NOMMAD, Tipo: C
Columna: NOMCONJ, Tipo: C
Columna: DOMICILIO, Tipo: C
Columna: NROPROPEN, Tipo: N
Columna: UBICACION, Tipo: N
Columna: USUARIO, Tipo: C
Columna: FECHAGRA, Tipo: N
Columna: SITUACION, Tipo: N
Columna: FECHAIMP, Tipo: N

Estructura de la tabla DBF 'D:\PADRONES\Automotores\tipo.dbf':
Columna: CODIGO, Tipo: N
Columna: XXX, Tipo: C
Columna: TIPOVEHIC, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\Automotores\usuarios.dbf':
Columna: CODIGO, Tipo: C
Columna: CONTRA, Tipo: C
Columna: NOMBRE, Tipo: C
Columna: APELLIDO, Tipo: C
Columna: DEPE, Tipo: C
Columna: FECHACAR, Tipo: D

Estructura de la tabla DBF 'D:\PADRONES\Consulta Padron 2013\FOXUSER.dbf':
Columna: TYPE, Tipo: C
Columna: ID, Tipo: C
Columna: NAME, Tipo: M
Columna: READONLY, Tipo: L
Columna: CKVAL, Tipo: N
Columna: DATA, Tipo: M
Columna: UPDATED, Tipo: D

Estructura de la tabla DBF 'D:\PADRONES\Consulta Padron 2013\data\ciudades.dbf':
Columna: ID_PAIS, Tipo: N
Columna: ID_CIUDAD, Tipo: N
Columna: DES_CIUDAD, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\Consulta Padron 2013\data\dep.dbf':
Columna: DEPART, Tipo: N
Columna: DESCRIP, Tipo: C
Columna: TOT_HAB, Tipo: N
Columna: CAN_MESA, Tipo: N

Estructura de la tabla DBF 'D:\PADRONES\Consulta Padron 2013\data\desafiliaciones.dbf':
Columna: NUM, Tipo: N
Columna: CEDULA, Tipo: C
Columna: APELLIDO, Tipo: C
Columna: NOMBRE, Tipo: C
Columna: FECHA, Tipo: D
Columna: PROCESADO, Tipo: C
Columna: LUGAR_PRES, Tipo: C
Columna: TIPO_DOC, Tipo: C
Columna: FECHA_DOC, Tipo: C
Columna: PARTIDO, Tipo: N
Columna: OBSERVACIO, Tipo: C
Columna: VIEJO, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\Consulta Padron 2013\data\deshabilitados.dbf':
Columna: DEPART, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: ZONA, Tipo: N
Columna: LOCAL, Tipo: N
Columna: TALON, Tipo: N
Columna: BOLETA, Tipo: N
Columna: FEC_INSCRI, Tipo: D
Columna: CEDULA, Tipo: C
Columna: NOMBRE, Tipo: C
Columna: APELLIDO, Tipo: C
Columna: FEC_NAC, Tipo: D
Columna: SEXO, Tipo: C
Columna: NACIONAL, Tipo: C
Columna: OBS, Tipo: C
Columna: _NullFlags, Tipo: 0

Estructura de la tabla DBF 'D:\PADRONES\Consulta Padron 2013\data\desh_exte.dbf':
Columna: PAIS, Tipo: N
Columna: CIUDAD, Tipo: N
Columna: TIPO, Tipo: C
Columna: TALON, Tipo: N
Columna: BOLETA, Tipo: N
Columna: FEC_INSCRI, Tipo: D
Columna: CEDULA, Tipo: C
Columna: NOMBRE, Tipo: C
Columna: APELLIDO, Tipo: C
Columna: FECHA_NACI, Tipo: D
Columna: BARRIO, Tipo: C
Columna: SEXO, Tipo: C
Columna: NACIONALID, Tipo: N
Columna: DESCRI_EST, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\Consulta Padron 2013\data\difuntos.dbf':
Columna: CEDULA, Tipo: C
Columna: NOMBRE, Tipo: C
Columna: APELLIDO, Tipo: C
Columna: FEC_NAC, Tipo: D
Columna: FEC_DEF, Tipo: D

Estructura de la tabla DBF 'D:\PADRONES\Consulta Padron 2013\data\dis.dbf':
Columna: DEPART, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: DESCRIP, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\Consulta Padron 2013\data\dobles.dbf':
Columna: DEPART, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: ZONA, Tipo: N
Columna: LOCAL, Tipo: N
Columna: TALON, Tipo: N
Columna: BOLETA, Tipo: N
Columna: FEC_INSCRI, Tipo: D
Columna: CEDULA, Tipo: C
Columna: NOMBRE, Tipo: C
Columna: APELLIDO, Tipo: C
Columna: FEC_NAC, Tipo: D
Columna: SEXO, Tipo: C
Columna: NACIONAL, Tipo: C
Columna: _NullFlags, Tipo: 0

Estructura de la tabla DBF 'D:\PADRONES\Consulta Padron 2013\data\dos.dbf':
Columna: CEDULA, Tipo: C
Columna: CNT, Tipo: N

Estructura de la tabla DBF 'D:\PADRONES\Consulta Padron 2013\data\extranjeros.dbf':
Columna: DEPART, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: ZONA, Tipo: N
Columna: LOCAL, Tipo: N
Columna: TALON, Tipo: N
Columna: BOLETA, Tipo: N
Columna: FEC_INS, Tipo: D
Columna: CEDULA, Tipo: C
Columna: NOMBRE, Tipo: C
Columna: APELLIDO, Tipo: C
Columna: SEXO, Tipo: C
Columna: FEC_NAC, Tipo: D
Columna: NACIONAL, Tipo: C
Columna: DIRECCION, Tipo: C
Columna: _NullFlags, Tipo: 0

Estructura de la tabla DBF 'D:\PADRONES\Consulta Padron 2013\data\interdictos.dbf':
Columna: DEPART, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: ZONA, Tipo: N
Columna: LOCAL, Tipo: N
Columna: TALON, Tipo: N
Columna: BOLETA, Tipo: N
Columna: FECINS, Tipo: C
Columna: CEDULA, Tipo: C
Columna: NOMBRE, Tipo: C
Columna: APELLIDO, Tipo: C
Columna: FEC_NAC, Tipo: D
Columna: SEXO, Tipo: C
Columna: NACIONAL, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\Consulta Padron 2013\data\loc.dbf':
Columna: DPTO, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: ZONA, Tipo: N
Columna: LOCAL, Tipo: N
Columna: DESCRIP, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\Consulta Padron 2013\data\menores.dbf':
Columna: DEPART, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: ZONA, Tipo: N
Columna: LOCAL, Tipo: N
Columna: TALON, Tipo: N
Columna: BOLETA, Tipo: N
Columna: FEC_INS, Tipo: D
Columna: CEDULA, Tipo: C
Columna: NOMBRE, Tipo: C
Columna: APELLIDO, Tipo: C
Columna: FEC_NAC, Tipo: D
Columna: SEXO, Tipo: C
Columna: NACIONAL, Tipo: C
Columna: DES_MENOR, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\Consulta Padron 2013\data\nacionalidades.dbf':
Columna: ID_NACION, Tipo: N
Columna: DES_NACION, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\Consulta Padron 2013\data\part.dbf':
Columna: CODIGO, Tipo: N
Columna: ANIO, Tipo: N
Columna: CRUZAR, Tipo: L
Columna: NOMBRE, Tipo: C
Columna: ESPARTIDO, Tipo: L
Columna: SIGLAS, Tipo: C
Columna: CERTIFICA, Tipo: L
Columna: PRI_ENTRE, Tipo: D
Columna: SEG_ENTRE, Tipo: D
Columna: RUTA, Tipo: C
Columna: NACIONAL, Tipo: C
Columna: EXTERIOR, Tipo: C
Columna: VIEJO, Tipo: C
Columna: _NullFlags, Tipo: 0

Estructura de la tabla DBF 'D:\PADRONES\Consulta Padron 2013\data\pol_y_mil.dbf':
Columna: TIPO, Tipo: C
Columna: GRADO, Tipo: C
Columna: DEPART, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: ZONA, Tipo: N
Columna: LOCAL, Tipo: N
Columna: TALON, Tipo: N
Columna: BOLETA, Tipo: N
Columna: CEDULA, Tipo: C
Columna: FECINS, Tipo: D
Columna: NOMBRE, Tipo: C
Columna: APELLIDO, Tipo: C
Columna: FEC_NAC, Tipo: D
Columna: SEXO, Tipo: C
Columna: NACIONAL, Tipo: C
Columna: _NullFlags, Tipo: 0

Estructura de la tabla DBF 'D:\PADRONES\Epi_Info\BurkinaFaso.dbf':
Columna: NAME2, Tipo: C
Columna: NAME1, Tipo: C
Columna: DENSITY90, Tipo: N
Columna: POPTOT90, Tipo: N
Columna: SQKMCALC, Tipo: N
Columna: AMAP11, Tipo: C
Columna: AMAP11H, Tipo: C
Columna: AMAP11B, Tipo: C
Columna: AMAP11HB, Tipo: C
Columna: SQKM, Tipo: N
Columna: ADMSQKM, Tipo: N
Columna: AGSQKM, Tipo: N
Columna: IWSQKM, Tipo: N
Columna: DEMOFLAG, Tipo: N
Columna: CODE, Tipo: C
Columna: ADMINID, Tipo: N
Columna: POPURB90, Tipo: N
Columna: POPRUR90, Tipo: N
Columna: DUPFLAG, Tipo: N
Columna: CTRY3NAME2, Tipo: C
Columna: POP9798, Tipo: N
Columna: 0_14, Tipo: N
Columna: COVERAGE, Tipo: N
Columna: REPORTING, Tipo: N
Columna: IDS_FORM, Tipo: N
Columna: COVERAGE0, Tipo: N
Columna: TREATMEN, Tipo: N
Columna: ONE_CASE, Tipo: N
Columna: CASES, Tipo: N
Columna: DEATHS, Tipo: N

Estructura de la tabla DBF 'D:\PADRONES\exe back ups\PRODUCTO.dbf':
Columna: BARRAS, Tipo: C
Columna: DESCRIPCIO, Tipo: C
Columna: MARCA, Tipo: C
Columna: GRUPO, Tipo: C
Columna: SESION, Tipo: C
Columna: FAMILIA, Tipo: C
Columna: PRECIO, Tipo: N
Columna: IMAGEN, Tipo: M

Estructura de la tabla DBF 'D:\PADRONES\GUIAPH\ABONACLA.dbf':
Columna: ACCESO, Tipo: C
Columna: TELEFO, Tipo: C
Columna: DESCRI, Tipo: C
Columna: DESCRI1, Tipo: C
Columna: COMERC, Tipo: C
Columna: APENOM, Tipo: C
Columna: DIRECC, Tipo: C
Columna: CODRUB, Tipo: N
Columna: EMAIL, Tipo: C
Columna: LUGAR, Tipo: C
Columna: RM, Tipo: C
Columna: ESTADO, Tipo: N
Columna: RUC, Tipo: C
Columna: OTRONRO, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\GUIAPH\AGENDA.dbf':
Columna: ACCESO, Tipo: C
Columna: TELEFO, Tipo: C
Columna: APENOM, Tipo: C
Columna: APENOM1, Tipo: C
Columna: DIRECC, Tipo: C
Columna: CELULAR, Tipo: C
Columna: E_MAIL, Tipo: C
Columna: CODRUB, Tipo: N
Columna: RDESCRI, Tipo: C
Columna: CODPRO, Tipo: N
Columna: PDESCRI, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\GUIAPH\AREA.dbf':
Columna: ACCESO, Tipo: C
Columna: DESCRI, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\GUIAPH\AUX_A.dbf':
Columna: ACCESO, Tipo: C
Columna: TELEFO, Tipo: C
Columna: DESCRI, Tipo: C
Columna: DESCRI1, Tipo: C
Columna: COMERC, Tipo: C
Columna: APENOM, Tipo: C
Columna: DIRECC, Tipo: C
Columna: CODRUB, Tipo: N
Columna: EMAIL, Tipo: C
Columna: LUGAR, Tipo: C
Columna: RM, Tipo: C
Columna: ESTADO, Tipo: N
Columna: RUC, Tipo: C
Columna: OTRONRO, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\GUIAPH\AUX_G.dbf':
Columna: ACCESO, Tipo: C
Columna: TELEFO, Tipo: C
Columna: APENOM, Tipo: C
Columna: DIRECC, Tipo: C
Columna: CIUDAD, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\GUIAPH\AUX_P.dbf':
Columna: ACCESO, Tipo: C
Columna: TELEFO, Tipo: C
Columna: DESCRI, Tipo: C
Columna: APENOM, Tipo: C
Columna: DIRECC, Tipo: C
Columna: CODPRO, Tipo: N
Columna: AUX, Tipo: N
Columna: ESTADO, Tipo: N

Estructura de la tabla DBF 'D:\PADRONES\GUIAPH\AUX_PRO.dbf':
Columna: ACCESO, Tipo: C
Columna: TELEFO, Tipo: C
Columna: DESCRI, Tipo: C
Columna: DESCRI1, Tipo: C
Columna: COMERC, Tipo: C
Columna: APENOM, Tipo: C
Columna: DIRECC, Tipo: C
Columna: CODRUB, Tipo: N
Columna: EMAIL, Tipo: C
Columna: LUGAR, Tipo: C
Columna: RM, Tipo: C
Columna: ESTADO, Tipo: N
Columna: RUC, Tipo: C
Columna: OTRONRO, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\GUIAPH\AYUDA.dbf':
Columna: NRO, Tipo: C
Columna: ITEM, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\GUIAPH\CIUDAD.dbf':
Columna: COD_CIU, Tipo: N
Columna: DESCRI, Tipo: C
Columna: ACCESO, Tipo: C
Columna: COD_PAIS, Tipo: N

Estructura de la tabla DBF 'D:\PADRONES\GUIAPH\C_SALUD.dbf':
Columna: DIRECC, Tipo: C
Columna: TELEFO, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\GUIAPH\DETALLE.dbf':
Columna: NRO, Tipo: C
Columna: INFORMA, Tipo: M

Estructura de la tabla DBF 'D:\PADRONES\GUIAPH\EMBAJADA.dbf':
Columna: PAIS, Tipo: C
Columna: DIRECC, Tipo: C
Columna: TELEFO1, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\GUIAPH\FOXUSER.dbf':
Columna: TYPE, Tipo: C
Columna: ID, Tipo: C
Columna: NAME, Tipo: M
Columna: READONLY, Tipo: L
Columna: CKVAL, Tipo: N
Columna: DATA, Tipo: M
Columna: UPDATED, Tipo: D

Estructura de la tabla DBF 'D:\PADRONES\GUIAPH\GUIA.dbf':
Columna: ACCESO, Tipo: C
Columna: TELEFO, Tipo: C
Columna: APENOM, Tipo: C
Columna: DIRECC, Tipo: C
Columna: CIUDAD, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\GUIAPH\HOSPITAL.dbf':
Columna: NOMBRE, Tipo: C
Columna: DIRECC, Tipo: C
Columna: TELEFO, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\GUIAPH\INDICEB.dbf':
Columna: NRO, Tipo: C
Columna: ITEM, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\GUIAPH\INDICEP.dbf':
Columna: NRO, Tipo: C
Columna: ITEM, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\GUIAPH\INFOBAS.dbf':
Columna: NRO, Tipo: C
Columna: INFORMA, Tipo: M

Estructura de la tabla DBF 'D:\PADRONES\GUIAPH\INFOPRO.dbf':
Columna: NRO, Tipo: C
Columna: INFORMA, Tipo: M

Estructura de la tabla DBF 'D:\PADRONES\GUIAPH\PAIS.dbf':
Columna: COD_PAIS, Tipo: N
Columna: DESCRI, Tipo: C
Columna: ACCESO, Tipo: C
Columna: COD_ZONA, Tipo: N

Estructura de la tabla DBF 'D:\PADRONES\GUIAPH\POLI_CAP.dbf':
Columna: NRO, Tipo: C
Columna: DIRECC, Tipo: C
Columna: TELEFO1, Tipo: C
Columna: TELEFO2, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\GUIAPH\POLI_INT.dbf':
Columna: NRO, Tipo: C
Columna: LOCALIDAD, Tipo: C
Columna: TELEFO1, Tipo: C
Columna: TELEFO2, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\GUIAPH\PROCARD.dbf':
Columna: ACCESO, Tipo: C
Columna: TELEFO, Tipo: C
Columna: DESCRI, Tipo: C
Columna: DESCRI1, Tipo: C
Columna: COMERC, Tipo: C
Columna: APENOM, Tipo: C
Columna: DIRECC, Tipo: C
Columna: CODRUB, Tipo: N
Columna: EMAIL, Tipo: C
Columna: LUGAR, Tipo: C
Columna: RM, Tipo: C
Columna: ESTADO, Tipo: N
Columna: RUC, Tipo: C
Columna: OTRONRO, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\GUIAPH\PROFE.dbf':
Columna: CODPRO, Tipo: N
Columna: AUX, Tipo: N
Columna: DESCRI, Tipo: C
Columna: ESTADO, Tipo: N

Estructura de la tabla DBF 'D:\PADRONES\GUIAPH\PROFESI.dbf':
Columna: ACCESO, Tipo: C
Columna: TELEFO, Tipo: C
Columna: DESCRI, Tipo: C
Columna: APENOM, Tipo: C
Columna: DIRECC, Tipo: C
Columna: CODPRO, Tipo: N
Columna: AUX, Tipo: N
Columna: ESTADO, Tipo: N

Estructura de la tabla DBF 'D:\PADRONES\GUIAPH\RUBROS.dbf':
Columna: CODRUB, Tipo: N
Columna: DESCRI, Tipo: C
Columna: ESTADO, Tipo: N

Estructura de la tabla DBF 'D:\PADRONES\GUIAPH\SANATOR.dbf':
Columna: NOMBRE, Tipo: C
Columna: DIRECC, Tipo: C
Columna: TELEFO, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\GUIAPH\TAXI.dbf':
Columna: NRO, Tipo: C
Columna: DIRECC, Tipo: C
Columna: TELEFO1, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\GUIAPH\ZONA.dbf':
Columna: COD_ZONA, Tipo: N
Columna: DESCRI, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\padron_31-08-2010 (rcp2008.dbc)\FOXUSER.dbf':
Columna: TYPE, Tipo: C
Columna: ID, Tipo: C
Columna: NAME, Tipo: M
Columna: READONLY, Tipo: L
Columna: CKVAL, Tipo: N
Columna: DATA, Tipo: M
Columna: UPDATED, Tipo: D

Estructura de la tabla DBF 'D:\PADRONES\padron_31-08-2010 (rcp2008.dbc)\data\dep.dbf':
Columna: DEPART, Tipo: N
Columna: DESCRIP, Tipo: C
Columna: TOT_HAB, Tipo: N
Columna: CAN_MESA, Tipo: N

Estructura de la tabla DBF 'D:\PADRONES\padron_31-08-2010 (rcp2008.dbc)\data\deshabilitados.dbf':
Columna: DEPART, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: ZONA, Tipo: N
Columna: LOCAL, Tipo: N
Columna: TALON, Tipo: N
Columna: BOLETA, Tipo: N
Columna: CEDULA, Tipo: C
Columna: FEC_INSCRI, Tipo: C
Columna: NOMBRE, Tipo: C
Columna: APELLIDO, Tipo: C
Columna: FEC_NAC, Tipo: N
Columna: SEXO, Tipo: C
Columna: NACIONAL, Tipo: C
Columna: OBS, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\padron_31-08-2010 (rcp2008.dbc)\data\difuntos.dbf':
Columna: CEDULA, Tipo: C
Columna: NOMBRE, Tipo: C
Columna: APELLIDO, Tipo: C
Columna: FEC_NAC, Tipo: N
Columna: FEC_DEF, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\padron_31-08-2010 (rcp2008.dbc)\data\dis.dbf':
Columna: DEPART, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: DESCRIP, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\padron_31-08-2010 (rcp2008.dbc)\data\dobles.dbf':
Columna: DEPART, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: ZONA, Tipo: N
Columna: LOCAL, Tipo: N
Columna: TALON, Tipo: N
Columna: BOLETA, Tipo: N
Columna: CEDULA, Tipo: C
Columna: FEC_INSCRI, Tipo: C
Columna: NOMBRE, Tipo: C
Columna: APELLIDO, Tipo: C
Columna: FEC_NAC, Tipo: N
Columna: SEXO, Tipo: C
Columna: NACIONAL, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\padron_31-08-2010 (rcp2008.dbc)\data\interdictos.dbf':
Columna: DEPART, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: ZONA, Tipo: N
Columna: LOCAL, Tipo: N
Columna: TALON, Tipo: N
Columna: BOLETA, Tipo: N
Columna: FECINS, Tipo: C
Columna: CEDULA, Tipo: C
Columna: NOMBRE, Tipo: C
Columna: APELLIDO, Tipo: C
Columna: FEC_NAC, Tipo: N
Columna: SEXO, Tipo: C
Columna: NACIONAL, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\padron_31-08-2010 (rcp2008.dbc)\data\loc.dbf':
Columna: DPTO, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: ZONA, Tipo: N
Columna: LOCAL, Tipo: N
Columna: DESCRIP, Tipo: C
Columna: DIREC, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\padron_31-08-2010 (rcp2008.dbc)\data\menores.dbf':
Columna: DEPART, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: ZONA, Tipo: N
Columna: LOCAL, Tipo: N
Columna: TALON, Tipo: N
Columna: BOLETA, Tipo: N
Columna: CEDULA, Tipo: C
Columna: FEC_INSCRI, Tipo: C
Columna: NOMBRE, Tipo: C
Columna: APELLIDO, Tipo: C
Columna: FEC_NAC, Tipo: N
Columna: SEXO, Tipo: C
Columna: NACIONAL, Tipo: C
Columna: DIRECCION, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\padron_31-08-2010 (rcp2008.dbc)\data\part.dbf':
Columna: LISTA, Tipo: N
Columna: COD, Tipo: C
Columna: DESCRIP, Tipo: C
Columna: SIGLAS, Tipo: C
Columna: AFILS, Tipo: C
Columna: ESPARTIDO, Tipo: L
Columna: _NullFlags, Tipo: 0

Estructura de la tabla DBF 'D:\PADRONES\padron_31-08-2010 (rcp2008.dbc)\data\pol_y_mil.dbf':
Columna: DEPART, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: ZONA, Tipo: N
Columna: LOCAL, Tipo: N
Columna: TALON, Tipo: N
Columna: BOLETA, Tipo: N
Columna: CEDULA, Tipo: C
Columna: FECINS, Tipo: C
Columna: NOMBRE, Tipo: C
Columna: APELLIDO, Tipo: C
Columna: FEC_NAC, Tipo: N
Columna: SEXO, Tipo: C
Columna: NACIONAL, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\padron_31-08-2010 (rcp2008.dbc)\data\regciv.dbf':
Columna: DEPART, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: ZONA, Tipo: N
Columna: LOCAL, Tipo: N
Columna: MESA, Tipo: N
Columna: ORDEN, Tipo: N
Columna: CEDULA, Tipo: C
Columna: NOMBRE, Tipo: C
Columna: APELLIDO, Tipo: C
Columna: ID_INTERNO, Tipo: N
Columna: NACIONAL, Tipo: C
Columna: SEXO, Tipo: C
Columna: FEC_NAC, Tipo: N
Columna: ESTATUS, Tipo: C
Columna: NAC, Tipo: N

Estructura de la tabla DBF 'D:\PADRONES\padron_31-08-2010 (rcp2008.dbc)\data\zon.dbf':
Columna: DEPART, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: ZONA, Tipo: N
Columna: DESCRIP, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2010 (PLRA)\barrios.dbf':
Columna: COD_DEP, Tipo: N
Columna: COD_DIS, Tipo: N
Columna: COD_ZON, Tipo: N
Columna: COD_LOC, Tipo: N
Columna: NOM_LOC, Tipo: C
Columna: NOM_ZON, Tipo: C
Columna: ABREVIADO, Tipo: C
Columna: TOTAL, Tipo: N
Columna: OBJETIVO, Tipo: N
Columna: INTERNA, Tipo: N
Columna: VOTANTES, Tipo: N
Columna: UNACE, Tipo: N
Columna: ANR, Tipo: N
Columna: SEGUROS, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2010 (PLRA)\dirigentes.dbf':
Columna: CEDULA, Tipo: N
Columna: APELLIDO, Tipo: C
Columna: NOMBRE, Tipo: C
Columna: DIRECCION, Tipo: C
Columna: COD_DEP, Tipo: N
Columna: COD_DIS, Tipo: N
Columna: CELULAR, Tipo: N

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2010 (PLRA)\FOXUSER.dbf':
Columna: TYPE, Tipo: C
Columna: ID, Tipo: C
Columna: NAME, Tipo: M
Columna: READONLY, Tipo: L
Columna: CKVAL, Tipo: N
Columna: DATA, Tipo: M
Columna: UPDATED, Tipo: D

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2010 (PLRA)\miembromesa.dbf':
Columna: CEDULA, Tipo: N
Columna: APELLIDO, Tipo: C
Columna: NOMBRE, Tipo: C
Columna: BARRIO, Tipo: C
Columna: COD_DEP, Tipo: N
Columna: COD_DIS, Tipo: N
Columna: CELULAR, Tipo: N
Columna: DIRECCION, Tipo: C
Columna: MESA, Tipo: N

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2010 (rcp2008.dbc)\FOXUSER.dbf':
Columna: TYPE, Tipo: C
Columna: ID, Tipo: C
Columna: NAME, Tipo: M
Columna: READONLY, Tipo: L
Columna: CKVAL, Tipo: N
Columna: DATA, Tipo: M
Columna: UPDATED, Tipo: D

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2010 (rcp2008.dbc)\data\boletas_deshabilitadas.dbf':
Columna: DEPART, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: ZONA, Tipo: N
Columna: LOCAL, Tipo: N
Columna: TALON, Tipo: N
Columna: BOLETA, Tipo: N
Columna: SERIE_BOLE, Tipo: N
Columna: CEDULA, Tipo: N
Columna: FEC_INSCRI, Tipo: D
Columna: NOMBRE, Tipo: C
Columna: APELLIDO, Tipo: C
Columna: SEXO, Tipo: C
Columna: ID_NACION, Tipo: N
Columna: SECUENCIA, Tipo: N
Columna: IDENTIFICA, Tipo: N
Columna: ANO, Tipo: N
Columna: DESCRI_EST, Tipo: C
Columna: FECHA_HABI, Tipo: D
Columna: TIPO, Tipo: C
Columna: FECHA_INGR, Tipo: D
Columna: FEC_NAC, Tipo: D
Columna: TIPO_INSCR, Tipo: C
Columna: _NullFlags, Tipo: 0

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2010 (rcp2008.dbc)\data\ciudades.dbf':
Columna: ID_CIUDAD, Tipo: N
Columna: ID_PAIS, Tipo: N
Columna: DES_CIUDAD, Tipo: C
Columna: _NullFlags, Tipo: 0

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2010 (rcp2008.dbc)\data\dep.dbf':
Columna: DEPART, Tipo: N
Columna: DESCRIP, Tipo: C
Columna: TOT_HAB, Tipo: N
Columna: CAN_MESA, Tipo: N

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2010 (rcp2008.dbc)\data\desafiliaciones.dbf':
Columna: CEDULA, Tipo: N
Columna: APELLIDO, Tipo: C
Columna: NOMBRE, Tipo: C
Columna: LETRA_PART, Tipo: C
Columna: USUARIO, Tipo: C
Columna: FECHA, Tipo: D
Columna: PROCESADO, Tipo: C
Columna: LUGAR_PRES, Tipo: C
Columna: TIPO_DOC, Tipo: C
Columna: FECHA_DOC, Tipo: D
Columna: PARTIDO, Tipo: N
Columna: OLDCODPART, Tipo: N
Columna: _NullFlags, Tipo: 0

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2010 (rcp2008.dbc)\data\deshabilitados.dbf':
Columna: DEPART, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: ZONA, Tipo: N
Columna: LOCAL, Tipo: N
Columna: TALON, Tipo: N
Columna: BOLETA, Tipo: N
Columna: CEDULA, Tipo: C
Columna: FEC_INSCRI, Tipo: C
Columna: NOMBRE, Tipo: C
Columna: APELLIDO, Tipo: C
Columna: FEC_NAC, Tipo: N
Columna: SEXO, Tipo: C
Columna: NACIONAL, Tipo: C
Columna: OBS, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2010 (rcp2008.dbc)\data\desh_exte.dbf':
Columna: IDENTIFICA, Tipo: N
Columna: ANO, Tipo: N
Columna: PAIS, Tipo: N
Columna: CIUDAD, Tipo: N
Columna: TIPO, Tipo: C
Columna: TALON, Tipo: N
Columna: BOLETA, Tipo: N
Columna: SERIE_BOLE, Tipo: N
Columna: CEDULA, Tipo: N
Columna: FEC_INSCRI, Tipo: D
Columna: NOMBRE, Tipo: C
Columna: APELLIDO, Tipo: C
Columna: FEC_NAC, Tipo: D
Columna: BARRIO, Tipo: C
Columna: SEXO, Tipo: C
Columna: ID_NACION, Tipo: N
Columna: SECUENCIA, Tipo: N
Columna: FECHA_HABI, Tipo: D
Columna: FECHA_INGR, Tipo: D
Columna: MOTIVO, Tipo: C
Columna: COD_DESHAB, Tipo: N
Columna: _NullFlags, Tipo: 0

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2010 (rcp2008.dbc)\data\difuntos.dbf':
Columna: CEDULA, Tipo: C
Columna: NOMBRE, Tipo: C
Columna: APELLIDO, Tipo: C
Columna: FEC_NAC, Tipo: N
Columna: FEC_DEF, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2010 (rcp2008.dbc)\data\dis.dbf':
Columna: DEPART, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: DESCRIP, Tipo: C
Columna: _NullFlags, Tipo: 0

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2010 (rcp2008.dbc)\data\dobles.dbf':
Columna: DEPART, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: ZONA, Tipo: N
Columna: LOCAL, Tipo: N
Columna: TALON, Tipo: N
Columna: BOLETA, Tipo: N
Columna: SERIE_BOLE, Tipo: N
Columna: CEDULA, Tipo: N
Columna: FEC_INSCRI, Tipo: D
Columna: NOMBRE, Tipo: C
Columna: APELLIDO, Tipo: C
Columna: SEXO, Tipo: C
Columna: ID_NACION, Tipo: N
Columna: TIPO, Tipo: C
Columna: FEC_NAC, Tipo: D
Columna: ID_TIPOREG, Tipo: N
Columna: _NullFlags, Tipo: 0

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2010 (rcp2008.dbc)\data\dos.dbf':
Columna: CEDULA, Tipo: C
Columna: CNT, Tipo: N

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2010 (rcp2008.dbc)\data\inhabilitados.dbf':
Columna: ID_INHABIL, Tipo: N
Columna: DEPART, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: ZONA, Tipo: N
Columna: LOCAL, Tipo: N
Columna: TALON, Tipo: N
Columna: BOLETA, Tipo: N
Columna: CEDULA, Tipo: N
Columna: NOMBRE, Tipo: C
Columna: APELLIDO, Tipo: C
Columna: SEXO, Tipo: C
Columna: FEC_NAC, Tipo: D
Columna: FEC_DEFUNC, Tipo: D
Columna: FEC_INSCRI, Tipo: D
Columna: SERIE_BOLE, Tipo: N
Columna: DIRECCION, Tipo: C
Columna: LUGNAC, Tipo: C
Columna: BARRIO, Tipo: C
Columna: FECHA_EST, Tipo: D
Columna: DESCRI_EST, Tipo: C
Columna: ID_NACION, Tipo: N
Columna: ID_TIPOREG, Tipo: N
Columna: TIPO, Tipo: C
Columna: _NullFlags, Tipo: 0

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2010 (rcp2008.dbc)\data\interdictos.dbf':
Columna: DEPART, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: ZONA, Tipo: N
Columna: LOCAL, Tipo: N
Columna: TALON, Tipo: N
Columna: BOLETA, Tipo: N
Columna: FECINS, Tipo: C
Columna: CEDULA, Tipo: C
Columna: NOMBRE, Tipo: C
Columna: APELLIDO, Tipo: C
Columna: FEC_NAC, Tipo: N
Columna: SEXO, Tipo: C
Columna: NACIONAL, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2010 (rcp2008.dbc)\data\loc.dbf':
Columna: DPTO, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: ZONA, Tipo: N
Columna: LOCAL, Tipo: N
Columna: DESCRIP, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2010 (rcp2008.dbc)\data\menores.dbf':
Columna: DEPART, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: ZONA, Tipo: N
Columna: LOCAL, Tipo: N
Columna: TALON, Tipo: N
Columna: BOLETA, Tipo: N
Columna: CEDULA, Tipo: C
Columna: FEC_INSCRI, Tipo: C
Columna: NOMBRE, Tipo: C
Columna: APELLIDO, Tipo: C
Columna: FEC_NAC, Tipo: N
Columna: SEXO, Tipo: C
Columna: NACIONAL, Tipo: C
Columna: DIRECCION, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2010 (rcp2008.dbc)\data\nacionalidades.dbf':
Columna: ID_NACION, Tipo: N
Columna: DES_NACION, Tipo: C
Columna: _NullFlags, Tipo: 0

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2010 (rcp2008.dbc)\data\part.dbf':
Columna: CODIGO, Tipo: N
Columna: ANIO, Tipo: N
Columna: CRUZAR, Tipo: L
Columna: NOMBRE, Tipo: C
Columna: ESPARTIDO, Tipo: L
Columna: SIGLAS, Tipo: C
Columna: CERTIFICA, Tipo: L
Columna: PRI_ENTRE, Tipo: D
Columna: SEG_ENTRE, Tipo: D
Columna: RUTA, Tipo: C
Columna: NACIONAL, Tipo: C
Columna: EXTERIOR, Tipo: C
Columna: VIEJO, Tipo: C
Columna: _NullFlags, Tipo: 0

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2010 (rcp2008.dbc)\data\pol_y_mil.dbf':
Columna: DEPART, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: ZONA, Tipo: N
Columna: LOCAL, Tipo: N
Columna: TALON, Tipo: N
Columna: BOLETA, Tipo: N
Columna: CEDULA, Tipo: C
Columna: FECINS, Tipo: C
Columna: NOMBRE, Tipo: C
Columna: APELLIDO, Tipo: C
Columna: FEC_NAC, Tipo: N
Columna: SEXO, Tipo: C
Columna: NACIONAL, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2010 (rcp2008.dbc)\data\regciv.dbf':
Columna: DEPART, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: ZONA, Tipo: N
Columna: LOCAL, Tipo: N
Columna: MESA, Tipo: N
Columna: ORDEN, Tipo: N
Columna: CEDULA, Tipo: C
Columna: NOMBRE, Tipo: C
Columna: APELLIDO, Tipo: C
Columna: ID_INTERNO, Tipo: N
Columna: NACIONAL, Tipo: C
Columna: SEXO, Tipo: C
Columna: FEC_NAC, Tipo: N
Columna: ESTATUS, Tipo: C
Columna: NAC, Tipo: N

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2010 (rcp2008.dbc)\data\regciv_exte.dbf':
Columna: IDENTIFICA, Tipo: N
Columna: ANO, Tipo: N
Columna: PAIS, Tipo: N
Columna: CIUDAD, Tipo: N
Columna: TIPO, Tipo: C
Columna: TALON, Tipo: N
Columna: BOLETA, Tipo: N
Columna: SERIE_BOLE, Tipo: N
Columna: CEDULA, Tipo: N
Columna: FEC_INSCRI, Tipo: D
Columna: NOMBRE, Tipo: C
Columna: APELLIDO, Tipo: C
Columna: FEC_NAC, Tipo: D
Columna: BARRIO, Tipo: C
Columna: SEXO, Tipo: C
Columna: ID_NACION, Tipo: N
Columna: DIRECC, Tipo: C
Columna: APE2, Tipo: C
Columna: NOM2, Tipo: C
Columna: PART, Tipo: C
Columna: SIGLAS, Tipo: C
Columna: _NullFlags, Tipo: 0

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2010 (rcp2008.dbc)\data\tgen.dbf':
Columna: ETIQUETA, Tipo: C
Columna: CODIGO, Tipo: N
Columna: DESCRIP, Tipo: C
Columna: REFERENCIA, Tipo: C
Columna: _NullFlags, Tipo: 0

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2010 (rcp2008.dbc)\data\tiporeg.dbf':
Columna: ID_TIPOREG, Tipo: N
Columna: ESTADO, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2010 (rcp2008.dbc)\data\zon.dbf':
Columna: DEPART, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: ZONA, Tipo: N
Columna: DESCRIP, Tipo: C
Columna: _NullFlags, Tipo: 0

El archivo 'D:\PADRONES\Padrón 2010 (rcp2008.dbc) 31-08\FOXUSER.dbf' no existe.

El archivo 'D:\PADRONES\Padrón 2010 (rcp2008.dbc) 31-08\data\dep.dbf' no existe.

El archivo 'D:\PADRONES\Padrón 2010 (rcp2008.dbc) 31-08\data\deshabilitados.dbf' no existe.

El archivo 'D:\PADRONES\Padrón 2010 (rcp2008.dbc) 31-08\data\difuntos.dbf' no existe.

El archivo 'D:\PADRONES\Padrón 2010 (rcp2008.dbc) 31-08\data\dis.dbf' no existe.

El archivo 'D:\PADRONES\Padrón 2010 (rcp2008.dbc) 31-08\data\dobles.dbf' no existe.

El archivo 'D:\PADRONES\Padrón 2010 (rcp2008.dbc) 31-08\data\interdictos.dbf' no existe.

El archivo 'D:\PADRONES\Padrón 2010 (rcp2008.dbc) 31-08\data\loc.dbf' no existe.

El archivo 'D:\PADRONES\Padrón 2010 (rcp2008.dbc) 31-08\data\menores.dbf' no existe.

El archivo 'D:\PADRONES\Padrón 2010 (rcp2008.dbc) 31-08\data\part.dbf' no existe.

El archivo 'D:\PADRONES\Padrón 2010 (rcp2008.dbc) 31-08\data\pol_y_mil.dbf' no existe.

El archivo 'D:\PADRONES\Padrón 2010 (rcp2008.dbc) 31-08\data\regciv.dbf' no existe.

El archivo 'D:\PADRONES\Padrón 2010 (rcp2008.dbc) 31-08\data\zon.dbf' no existe.

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2010 ANR pre\FOXUSER.dbf':
Columna: TYPE, Tipo: C
Columna: ID, Tipo: C
Columna: NAME, Tipo: M
Columna: READONLY, Tipo: L
Columna: CKVAL, Tipo: N
Columna: DATA, Tipo: M
Columna: UPDATED, Tipo: D

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2013 Generales (rcp2008.dbc)\FOXUSER.dbf':
Columna: TYPE, Tipo: C
Columna: ID, Tipo: C
Columna: NAME, Tipo: M
Columna: READONLY, Tipo: L
Columna: CKVAL, Tipo: N
Columna: DATA, Tipo: M
Columna: UPDATED, Tipo: D

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2013 Generales (rcp2008.dbc)\data\ciudades.dbf':
Columna: ID_PAIS, Tipo: N
Columna: ID_CIUDAD, Tipo: N
Columna: DES_CIUDAD, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2013 Generales (rcp2008.dbc)\data\dep.dbf':
Columna: DEPART, Tipo: N
Columna: DESCRIP, Tipo: C
Columna: TOT_HAB, Tipo: N
Columna: CAN_MESA, Tipo: N

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2013 Generales (rcp2008.dbc)\data\desafiliaciones.dbf':
Columna: NUM, Tipo: N
Columna: CEDULA, Tipo: C
Columna: APELLIDO, Tipo: C
Columna: NOMBRE, Tipo: C
Columna: FECHA, Tipo: D
Columna: PROCESADO, Tipo: C
Columna: LUGAR_PRES, Tipo: C
Columna: TIPO_DOC, Tipo: C
Columna: FECHA_DOC, Tipo: C
Columna: PARTIDO, Tipo: N
Columna: OBSERVACIO, Tipo: C
Columna: VIEJO, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2013 Generales (rcp2008.dbc)\data\deshabilitados.dbf':
Columna: DEPART, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: ZONA, Tipo: N
Columna: LOCAL, Tipo: N
Columna: TALON, Tipo: N
Columna: BOLETA, Tipo: N
Columna: FEC_INSCRI, Tipo: D
Columna: CEDULA, Tipo: C
Columna: NOMBRE, Tipo: C
Columna: APELLIDO, Tipo: C
Columna: FEC_NAC, Tipo: D
Columna: SEXO, Tipo: C
Columna: NACIONAL, Tipo: C
Columna: OBS, Tipo: C
Columna: _NullFlags, Tipo: 0

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2013 Generales (rcp2008.dbc)\data\desh_exte.dbf':
Columna: PAIS, Tipo: N
Columna: CIUDAD, Tipo: N
Columna: TIPO, Tipo: C
Columna: TALON, Tipo: N
Columna: BOLETA, Tipo: N
Columna: FEC_INSCRI, Tipo: D
Columna: CEDULA, Tipo: C
Columna: NOMBRE, Tipo: C
Columna: APELLIDO, Tipo: C
Columna: FECHA_NACI, Tipo: D
Columna: BARRIO, Tipo: C
Columna: SEXO, Tipo: C
Columna: NACIONALID, Tipo: N
Columna: DESCRI_EST, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2013 Generales (rcp2008.dbc)\data\difuntos.dbf':
Columna: CEDULA, Tipo: C
Columna: NOMBRE, Tipo: C
Columna: APELLIDO, Tipo: C
Columna: FEC_NAC, Tipo: D
Columna: FEC_DEF, Tipo: D

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2013 Generales (rcp2008.dbc)\data\dis.dbf':
Columna: DEPART, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: DESCRIP, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2013 Generales (rcp2008.dbc)\data\dobles.dbf':
Columna: DEPART, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: ZONA, Tipo: N
Columna: LOCAL, Tipo: N
Columna: TALON, Tipo: N
Columna: BOLETA, Tipo: N
Columna: FEC_INSCRI, Tipo: D
Columna: CEDULA, Tipo: C
Columna: NOMBRE, Tipo: C
Columna: APELLIDO, Tipo: C
Columna: FEC_NAC, Tipo: D
Columna: SEXO, Tipo: C
Columna: NACIONAL, Tipo: C
Columna: _NullFlags, Tipo: 0

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2013 Generales (rcp2008.dbc)\data\dos.dbf':
Columna: CEDULA, Tipo: C
Columna: CNT, Tipo: N

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2013 Generales (rcp2008.dbc)\data\extranjeros.dbf':
Columna: DEPART, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: ZONA, Tipo: N
Columna: LOCAL, Tipo: N
Columna: TALON, Tipo: N
Columna: BOLETA, Tipo: N
Columna: FEC_INS, Tipo: D
Columna: CEDULA, Tipo: C
Columna: NOMBRE, Tipo: C
Columna: APELLIDO, Tipo: C
Columna: SEXO, Tipo: C
Columna: FEC_NAC, Tipo: D
Columna: NACIONAL, Tipo: C
Columna: DIRECCION, Tipo: C
Columna: _NullFlags, Tipo: 0

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2013 Generales (rcp2008.dbc)\data\interdictos.dbf':
Columna: DEPART, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: ZONA, Tipo: N
Columna: LOCAL, Tipo: N
Columna: TALON, Tipo: N
Columna: BOLETA, Tipo: N
Columna: FECINS, Tipo: C
Columna: CEDULA, Tipo: C
Columna: NOMBRE, Tipo: C
Columna: APELLIDO, Tipo: C
Columna: FEC_NAC, Tipo: D
Columna: SEXO, Tipo: C
Columna: NACIONAL, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2013 Generales (rcp2008.dbc)\data\loc.dbf':
Columna: DPTO, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: ZONA, Tipo: N
Columna: LOCAL, Tipo: N
Columna: DESCRIP, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2013 Generales (rcp2008.dbc)\data\menores.dbf':
Columna: DEPART, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: ZONA, Tipo: N
Columna: LOCAL, Tipo: N
Columna: TALON, Tipo: N
Columna: BOLETA, Tipo: N
Columna: FEC_INS, Tipo: D
Columna: CEDULA, Tipo: C
Columna: NOMBRE, Tipo: C
Columna: APELLIDO, Tipo: C
Columna: FEC_NAC, Tipo: D
Columna: SEXO, Tipo: C
Columna: NACIONAL, Tipo: C
Columna: DES_MENOR, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2013 Generales (rcp2008.dbc)\data\nacionalidades.dbf':
Columna: ID_NACION, Tipo: N
Columna: DES_NACION, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2013 Generales (rcp2008.dbc)\data\part.dbf':
Columna: CODIGO, Tipo: N
Columna: ANIO, Tipo: N
Columna: CRUZAR, Tipo: L
Columna: NOMBRE, Tipo: C
Columna: ESPARTIDO, Tipo: L
Columna: SIGLAS, Tipo: C
Columna: CERTIFICA, Tipo: L
Columna: PRI_ENTRE, Tipo: D
Columna: SEG_ENTRE, Tipo: D
Columna: RUTA, Tipo: C
Columna: NACIONAL, Tipo: C
Columna: EXTERIOR, Tipo: C
Columna: VIEJO, Tipo: C
Columna: _NullFlags, Tipo: 0

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2013 Generales (rcp2008.dbc)\data\pol_y_mil.dbf':
Columna: TIPO, Tipo: C
Columna: GRADO, Tipo: C
Columna: DEPART, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: ZONA, Tipo: N
Columna: LOCAL, Tipo: N
Columna: TALON, Tipo: N
Columna: BOLETA, Tipo: N
Columna: CEDULA, Tipo: C
Columna: FECINS, Tipo: D
Columna: NOMBRE, Tipo: C
Columna: APELLIDO, Tipo: C
Columna: FEC_NAC, Tipo: D
Columna: SEXO, Tipo: C
Columna: NACIONAL, Tipo: C
Columna: _NullFlags, Tipo: 0

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2013 Generales (rcp2008.dbc)\data\regciv.dbf':
Columna: DEPART, Tipo: I
Columna: DISTRITO, Tipo: I
Columna: ZONA, Tipo: I
Columna: LOCAL, Tipo: I
Columna: MESA, Tipo: I
Columna: ORDEN, Tipo: I
Columna: CEDULA, Tipo: C
Columna: NOMBRE, Tipo: C
Columna: APELLIDO, Tipo: C
Columna: SEXO, Tipo: C
Columna: NACIONAL, Tipo: C
Columna: FEC_NAC, Tipo: D

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2013 Generales (rcp2008.dbc)\data\regciv_exte.dbf':
Columna: PAIS, Tipo: N
Columna: CIUDAD, Tipo: N
Columna: TIPO, Tipo: C
Columna: TALON, Tipo: N
Columna: BOLETA, Tipo: N
Columna: CEDULA, Tipo: C
Columna: FEC_INSCRI, Tipo: D
Columna: NOMBRE, Tipo: C
Columna: APELLIDO, Tipo: C
Columna: FEC_NAC, Tipo: D
Columna: SEXO, Tipo: C
Columna: NACIONAL, Tipo: C
Columna: DEPART_ULT, Tipo: N
Columna: DISTRI_ULT, Tipo: N
Columna: BARRIO, Tipo: C
Columna: PART, Tipo: C
Columna: SIGLAS, Tipo: C
Columna: DES_MENOR, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2013 Generales (rcp2008.dbc)\data\zon.dbf':
Columna: DEPART, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: ZONA, Tipo: N
Columna: DESCRIP, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2013 Generales (rcp2008.dbc)-\FOXUSER.dbf':
Columna: TYPE, Tipo: C
Columna: ID, Tipo: C
Columna: NAME, Tipo: M
Columna: READONLY, Tipo: L
Columna: CKVAL, Tipo: N
Columna: DATA, Tipo: M
Columna: UPDATED, Tipo: D

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2013 Generales (rcp2008.dbc)-\data\ciudades.dbf':
Columna: ID_PAIS, Tipo: N
Columna: ID_CIUDAD, Tipo: N
Columna: DES_CIUDAD, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2013 Generales (rcp2008.dbc)-\data\dep.dbf':
Columna: DEPART, Tipo: N
Columna: DESCRIP, Tipo: C
Columna: TOT_HAB, Tipo: N
Columna: CAN_MESA, Tipo: N

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2013 Generales (rcp2008.dbc)-\data\desafiliaciones.dbf':
Columna: NUM, Tipo: N
Columna: CEDULA, Tipo: C
Columna: APELLIDO, Tipo: C
Columna: NOMBRE, Tipo: C
Columna: FECHA, Tipo: D
Columna: PROCESADO, Tipo: C
Columna: LUGAR_PRES, Tipo: C
Columna: TIPO_DOC, Tipo: C
Columna: FECHA_DOC, Tipo: C
Columna: PARTIDO, Tipo: N
Columna: OBSERVACIO, Tipo: C
Columna: VIEJO, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2013 Generales (rcp2008.dbc)-\data\deshabilitados.dbf':
Columna: DEPART, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: ZONA, Tipo: N
Columna: LOCAL, Tipo: N
Columna: TALON, Tipo: N
Columna: BOLETA, Tipo: N
Columna: FEC_INSCRI, Tipo: D
Columna: CEDULA, Tipo: C
Columna: NOMBRE, Tipo: C
Columna: APELLIDO, Tipo: C
Columna: FEC_NAC, Tipo: D
Columna: SEXO, Tipo: C
Columna: NACIONAL, Tipo: C
Columna: OBS, Tipo: C
Columna: _NullFlags, Tipo: 0

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2013 Generales (rcp2008.dbc)-\data\desh_exte.dbf':
Columna: PAIS, Tipo: N
Columna: CIUDAD, Tipo: N
Columna: TIPO, Tipo: C
Columna: TALON, Tipo: N
Columna: BOLETA, Tipo: N
Columna: FEC_INSCRI, Tipo: D
Columna: CEDULA, Tipo: C
Columna: NOMBRE, Tipo: C
Columna: APELLIDO, Tipo: C
Columna: FECHA_NACI, Tipo: D
Columna: BARRIO, Tipo: C
Columna: SEXO, Tipo: C
Columna: NACIONALID, Tipo: N
Columna: DESCRI_EST, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2013 Generales (rcp2008.dbc)-\data\difuntos.dbf':
Columna: CEDULA, Tipo: C
Columna: NOMBRE, Tipo: C
Columna: APELLIDO, Tipo: C
Columna: FEC_NAC, Tipo: D
Columna: FEC_DEF, Tipo: D

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2013 Generales (rcp2008.dbc)-\data\dis.dbf':
Columna: DEPART, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: DESCRIP, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2013 Generales (rcp2008.dbc)-\data\dobles.dbf':
Columna: DEPART, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: ZONA, Tipo: N
Columna: LOCAL, Tipo: N
Columna: TALON, Tipo: N
Columna: BOLETA, Tipo: N
Columna: FEC_INSCRI, Tipo: D
Columna: CEDULA, Tipo: C
Columna: NOMBRE, Tipo: C
Columna: APELLIDO, Tipo: C
Columna: FEC_NAC, Tipo: D
Columna: SEXO, Tipo: C
Columna: NACIONAL, Tipo: C
Columna: _NullFlags, Tipo: 0

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2013 Generales (rcp2008.dbc)-\data\dos.dbf':
Columna: CEDULA, Tipo: C
Columna: CNT, Tipo: N

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2013 Generales (rcp2008.dbc)-\data\extranjeros.dbf':
Columna: DEPART, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: ZONA, Tipo: N
Columna: LOCAL, Tipo: N
Columna: TALON, Tipo: N
Columna: BOLETA, Tipo: N
Columna: FEC_INS, Tipo: D
Columna: CEDULA, Tipo: C
Columna: NOMBRE, Tipo: C
Columna: APELLIDO, Tipo: C
Columna: SEXO, Tipo: C
Columna: FEC_NAC, Tipo: D
Columna: NACIONAL, Tipo: C
Columna: DIRECCION, Tipo: C
Columna: _NullFlags, Tipo: 0

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2013 Generales (rcp2008.dbc)-\data\interdictos.dbf':
Columna: DEPART, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: ZONA, Tipo: N
Columna: LOCAL, Tipo: N
Columna: TALON, Tipo: N
Columna: BOLETA, Tipo: N
Columna: FECINS, Tipo: C
Columna: CEDULA, Tipo: C
Columna: NOMBRE, Tipo: C
Columna: APELLIDO, Tipo: C
Columna: FEC_NAC, Tipo: D
Columna: SEXO, Tipo: C
Columna: NACIONAL, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2013 Generales (rcp2008.dbc)-\data\loc.dbf':
Columna: DPTO, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: ZONA, Tipo: N
Columna: LOCAL, Tipo: N
Columna: DESCRIP, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2013 Generales (rcp2008.dbc)-\data\menores.dbf':
Columna: DEPART, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: ZONA, Tipo: N
Columna: LOCAL, Tipo: N
Columna: TALON, Tipo: N
Columna: BOLETA, Tipo: N
Columna: FEC_INS, Tipo: D
Columna: CEDULA, Tipo: C
Columna: NOMBRE, Tipo: C
Columna: APELLIDO, Tipo: C
Columna: FEC_NAC, Tipo: D
Columna: SEXO, Tipo: C
Columna: NACIONAL, Tipo: C
Columna: DES_MENOR, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2013 Generales (rcp2008.dbc)-\data\nacionalidades.dbf':
Columna: ID_NACION, Tipo: N
Columna: DES_NACION, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2013 Generales (rcp2008.dbc)-\data\part.dbf':
Columna: CODIGO, Tipo: N
Columna: ANIO, Tipo: N
Columna: CRUZAR, Tipo: L
Columna: NOMBRE, Tipo: C
Columna: ESPARTIDO, Tipo: L
Columna: SIGLAS, Tipo: C
Columna: CERTIFICA, Tipo: L
Columna: PRI_ENTRE, Tipo: D
Columna: SEG_ENTRE, Tipo: D
Columna: RUTA, Tipo: C
Columna: NACIONAL, Tipo: C
Columna: EXTERIOR, Tipo: C
Columna: VIEJO, Tipo: C
Columna: _NullFlags, Tipo: 0

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2013 Generales (rcp2008.dbc)-\data\pol_y_mil.dbf':
Columna: TIPO, Tipo: C
Columna: GRADO, Tipo: C
Columna: DEPART, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: ZONA, Tipo: N
Columna: LOCAL, Tipo: N
Columna: TALON, Tipo: N
Columna: BOLETA, Tipo: N
Columna: CEDULA, Tipo: C
Columna: FECINS, Tipo: D
Columna: NOMBRE, Tipo: C
Columna: APELLIDO, Tipo: C
Columna: FEC_NAC, Tipo: D
Columna: SEXO, Tipo: C
Columna: NACIONAL, Tipo: C
Columna: _NullFlags, Tipo: 0

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2015 (rcp2008.dbc)\FOXUSER.dbf':
Columna: TYPE, Tipo: C
Columna: ID, Tipo: C
Columna: NAME, Tipo: M
Columna: READONLY, Tipo: L
Columna: CKVAL, Tipo: N
Columna: DATA, Tipo: M
Columna: UPDATED, Tipo: D

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2015 (rcp2008.dbc)\data\boletas_deshabilitadas.dbf':
Columna: DEPART, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: ZONA, Tipo: N
Columna: LOCAL, Tipo: N
Columna: TALON, Tipo: N
Columna: BOLETA, Tipo: N
Columna: SERIE_BOLE, Tipo: N
Columna: CEDULA, Tipo: N
Columna: FEC_INSCRI, Tipo: D
Columna: NOMBRE, Tipo: C
Columna: APELLIDO, Tipo: C
Columna: SEXO, Tipo: C
Columna: ID_NACION, Tipo: N
Columna: SECUENCIA, Tipo: N
Columna: IDENTIFICA, Tipo: N
Columna: ANO, Tipo: N
Columna: DESCRI_EST, Tipo: C
Columna: FECHA_HABI, Tipo: D
Columna: TIPO, Tipo: C
Columna: FECHA_INGR, Tipo: D
Columna: FEC_NAC, Tipo: D
Columna: TIPO_INSCR, Tipo: C
Columna: _NullFlags, Tipo: 0

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2015 (rcp2008.dbc)\data\ciudades.dbf':
Columna: ID_CIUDAD, Tipo: N
Columna: ID_PAIS, Tipo: N
Columna: DES_CIUDAD, Tipo: C
Columna: _NullFlags, Tipo: 0

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2015 (rcp2008.dbc)\data\dep.dbf':
Columna: DEPART, Tipo: N
Columna: DESCRIP, Tipo: C
Columna: TOT_HAB, Tipo: N
Columna: CAN_MESA, Tipo: N

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2015 (rcp2008.dbc)\data\desafiliaciones.dbf':
Columna: CEDULA, Tipo: N
Columna: APELLIDO, Tipo: C
Columna: NOMBRE, Tipo: C
Columna: LETRA_PART, Tipo: C
Columna: USUARIO, Tipo: C
Columna: FECHA, Tipo: D
Columna: PROCESADO, Tipo: C
Columna: LUGAR_PRES, Tipo: C
Columna: TIPO_DOC, Tipo: C
Columna: FECHA_DOC, Tipo: D
Columna: PARTIDO, Tipo: N
Columna: OLDCODPART, Tipo: N
Columna: _NullFlags, Tipo: 0

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2015 (rcp2008.dbc)\data\desh_exte.dbf':
Columna: IDENTIFICA, Tipo: N
Columna: ANO, Tipo: N
Columna: PAIS, Tipo: N
Columna: CIUDAD, Tipo: N
Columna: TIPO, Tipo: C
Columna: TALON, Tipo: N
Columna: BOLETA, Tipo: N
Columna: SERIE_BOLE, Tipo: N
Columna: CEDULA, Tipo: N
Columna: FEC_INSCRI, Tipo: D
Columna: NOMBRE, Tipo: C
Columna: APELLIDO, Tipo: C
Columna: FEC_NAC, Tipo: D
Columna: BARRIO, Tipo: C
Columna: SEXO, Tipo: C
Columna: ID_NACION, Tipo: N
Columna: SECUENCIA, Tipo: N
Columna: FECHA_HABI, Tipo: D
Columna: FECHA_INGR, Tipo: D
Columna: MOTIVO, Tipo: C
Columna: COD_DESHAB, Tipo: N
Columna: _NullFlags, Tipo: 0

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2015 (rcp2008.dbc)\data\dis.dbf':
Columna: DEPART, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: DESCRIP, Tipo: C
Columna: _NullFlags, Tipo: 0

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2015 (rcp2008.dbc)\data\dobles.dbf':
Columna: DEPART, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: ZONA, Tipo: N
Columna: LOCAL, Tipo: N
Columna: TALON, Tipo: N
Columna: BOLETA, Tipo: N
Columna: SERIE_BOLE, Tipo: N
Columna: CEDULA, Tipo: N
Columna: FEC_INSCRI, Tipo: D
Columna: NOMBRE, Tipo: C
Columna: APELLIDO, Tipo: C
Columna: SEXO, Tipo: C
Columna: ID_NACION, Tipo: N
Columna: TIPO, Tipo: C
Columna: FEC_NAC, Tipo: D
Columna: ID_TIPOREG, Tipo: N
Columna: _NullFlags, Tipo: 0

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2015 (rcp2008.dbc)\data\dos.dbf':
Columna: CEDULA, Tipo: C
Columna: CNT, Tipo: N

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2015 (rcp2008.dbc)\data\inhabilitados.dbf':
Columna: ID_INHABIL, Tipo: N
Columna: DEPART, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: ZONA, Tipo: N
Columna: LOCAL, Tipo: N
Columna: TALON, Tipo: N
Columna: BOLETA, Tipo: N
Columna: CEDULA, Tipo: N
Columna: NOMBRE, Tipo: C
Columna: APELLIDO, Tipo: C
Columna: SEXO, Tipo: C
Columna: FEC_NAC, Tipo: D
Columna: FEC_DEFUNC, Tipo: D
Columna: FEC_INSCRI, Tipo: D
Columna: SERIE_BOLE, Tipo: N
Columna: DIRECCION, Tipo: C
Columna: LUGNAC, Tipo: C
Columna: BARRIO, Tipo: C
Columna: FECHA_EST, Tipo: D
Columna: DESCRI_EST, Tipo: C
Columna: ID_NACION, Tipo: N
Columna: ID_TIPOREG, Tipo: N
Columna: TIPO, Tipo: C
Columna: _NullFlags, Tipo: 0

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2015 (rcp2008.dbc)\data\loc.dbf':
Columna: DPTO, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: ZONA, Tipo: N
Columna: LOCAL, Tipo: N
Columna: DESCRIP, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2015 (rcp2008.dbc)\data\nacionalidades.dbf':
Columna: ID_NACION, Tipo: N
Columna: DES_NACION, Tipo: C
Columna: _NullFlags, Tipo: 0

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2015 (rcp2008.dbc)\data\part.dbf':
Columna: CODIGO, Tipo: N
Columna: ANIO, Tipo: N
Columna: CRUZAR, Tipo: L
Columna: NOMBRE, Tipo: C
Columna: ESPARTIDO, Tipo: L
Columna: SIGLAS, Tipo: C
Columna: CERTIFICA, Tipo: L
Columna: PRI_ENTRE, Tipo: D
Columna: SEG_ENTRE, Tipo: D
Columna: RUTA, Tipo: C
Columna: NACIONAL, Tipo: C
Columna: EXTERIOR, Tipo: C
Columna: VIEJO, Tipo: C
Columna: _NullFlags, Tipo: 0

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2015 (rcp2008.dbc)\data\regciv.dbf':
Columna: DEPART, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: ZONA, Tipo: N
Columna: LOCAL, Tipo: N
Columna: TALON, Tipo: N
Columna: BOLETA, Tipo: N
Columna: CEDULA, Tipo: N
Columna: NOMBRE, Tipo: C
Columna: APELLIDO, Tipo: C
Columna: SEXO, Tipo: C
Columna: FEC_NAC, Tipo: D
Columna: FEC_INSCRI, Tipo: D
Columna: TIPO, Tipo: C
Columna: ID_NACION, Tipo: N
Columna: DIRECC, Tipo: C
Columna: PART, Tipo: C
Columna: SIGLAS, Tipo: C
Columna: MESA, Tipo: N
Columna: ORDEN, Tipo: N
Columna: COD_VOTO, Tipo: N
Columna: DES_VOTO, Tipo: C
Columna: _NullFlags, Tipo: 0

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2015 (rcp2008.dbc)\data\regciv_exte.dbf':
Columna: IDENTIFICA, Tipo: N
Columna: ANO, Tipo: N
Columna: PAIS, Tipo: N
Columna: CIUDAD, Tipo: N
Columna: TIPO, Tipo: C
Columna: TALON, Tipo: N
Columna: BOLETA, Tipo: N
Columna: SERIE_BOLE, Tipo: N
Columna: CEDULA, Tipo: N
Columna: FEC_INSCRI, Tipo: D
Columna: NOMBRE, Tipo: C
Columna: APELLIDO, Tipo: C
Columna: FEC_NAC, Tipo: D
Columna: BARRIO, Tipo: C
Columna: SEXO, Tipo: C
Columna: ID_NACION, Tipo: N
Columna: DIRECC, Tipo: C
Columna: APE2, Tipo: C
Columna: NOM2, Tipo: C
Columna: PART, Tipo: C
Columna: SIGLAS, Tipo: C
Columna: _NullFlags, Tipo: 0

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2015 (rcp2008.dbc)\data\tgen.dbf':
Columna: ETIQUETA, Tipo: C
Columna: CODIGO, Tipo: N
Columna: DESCRIP, Tipo: C
Columna: REFERENCIA, Tipo: C
Columna: _NullFlags, Tipo: 0

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2015 (rcp2008.dbc)\data\tiporeg.dbf':
Columna: ID_TIPOREG, Tipo: N
Columna: ESTADO, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2015 (rcp2008.dbc)\data\zon.dbf':
Columna: DEPART, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: ZONA, Tipo: N
Columna: DESCRIP, Tipo: C
Columna: _NullFlags, Tipo: 0

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2015 ANR (rcp2008.dbc)\FOXUSER.dbf':
Columna: TYPE, Tipo: C
Columna: ID, Tipo: C
Columna: NAME, Tipo: M
Columna: READONLY, Tipo: L
Columna: CKVAL, Tipo: N
Columna: DATA, Tipo: M
Columna: UPDATED, Tipo: D

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2017 HC (datos.dbc)\FOXUSER.dbf':
Columna: TYPE, Tipo: C
Columna: ID, Tipo: C
Columna: NAME, Tipo: M
Columna: READONLY, Tipo: L
Columna: CKVAL, Tipo: N
Columna: DATA, Tipo: M
Columna: UPDATED, Tipo: D

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2017 HC (datos.dbc)\mas_pda.dbf':
Columna: MESA, Tipo: N
Columna: ORDEN, Tipo: N
Columna: NUMERO_CED, Tipo: N
Columna: CODIGO_SEC, Tipo: N
Columna: SLOCAL, Tipo: N
Columna: APELLIDO, Tipo: C
Columna: NOMBRE, Tipo: C
Columna: FECHA_NACI, Tipo: D
Columna: COD_DPTO, Tipo: N
Columna: COD_DIST, Tipo: N
Columna: DIRECCION, Tipo: C
Columna: NUMERO_CAS, Tipo: C
Columna: CODIGO_SEX, Tipo: N
Columna: FECHA_AFIL, Tipo: D
Columna: DEP_05, Tipo: N
Columna: DIS_05, Tipo: N
Columna: ZON_05, Tipo: N
Columna: LOC_05, Tipo: N
Columna: PARTIDO, Tipo: C
Columna: KEY_DDS, Tipo: C
Columna: KEY_DD, Tipo: C
Columna: KEY_DDZ, Tipo: C
Columna: KEY_DDZL, Tipo: C
Columna: VOTO, Tipo: C
Columna: VOTO1, Tipo: C
Columna: VOTO2, Tipo: C
Columna: VOTO3, Tipo: C
Columna: VOTO4, Tipo: C
Columna: VOTO5, Tipo: C
Columna: CED_APE, Tipo: C
Columna: SEC_LOC, Tipo: N
Columna: OK, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2017 pre ANR (datos.dbc)\mas_pda.dbf':
Columna: MESA, Tipo: N
Columna: ORDEN, Tipo: N
Columna: NUMERO_CED, Tipo: N
Columna: APELLIDO, Tipo: C
Columna: NOMBRE, Tipo: C
Columna: FECHA_NACI, Tipo: D
Columna: COD_DPTO, Tipo: N
Columna: COD_DIST, Tipo: N
Columna: CODIGO_SEC, Tipo: N
Columna: SLOCAL, Tipo: N
Columna: DIRECCION, Tipo: C
Columna: NUMERO_CAS, Tipo: C
Columna: CODIGO_SEX, Tipo: N
Columna: FECHA_AFIL, Tipo: D
Columna: HABILITADO, Tipo: N
Columna: PAIS_05, Tipo: N
Columna: CIUDAD_05, Tipo: N
Columna: KEY_DDS, Tipo: C
Columna: KEY_DD, Tipo: C
Columna: KEY_PC, Tipo: C
Columna: KEY_DDZ, Tipo: C
Columna: KEY_DDZL, Tipo: C
Columna: VOTO1, Tipo: C
Columna: VOTO2, Tipo: C
Columna: VOTO3, Tipo: C
Columna: VOTO4, Tipo: C
Columna: VOTO5, Tipo: C
Columna: FECHA_INSC, Tipo: D
Columna: PARTIDO, Tipo: C
Columna: DEP_05, Tipo: N
Columna: DIS_05, Tipo: N
Columna: ZON_05, Tipo: N
Columna: LOC_05, Tipo: N
Columna: ZONA_RCP, Tipo: N
Columna: LOCAL_RCP, Tipo: N
Columna: RCP, Tipo: C
Columna: CEDULA_REA, Tipo: N
Columna: NRO_TALON_, Tipo: N
Columna: NRO_BOLETA, Tipo: N
Columna: ANT_FEC_IN, Tipo: D
Columna: NRO_CASA, Tipo: N
Columna: VOTO, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2018 (rcp2008.dbc)\FOXUSER.dbf':
Columna: TYPE, Tipo: C
Columna: ID, Tipo: C
Columna: NAME, Tipo: M
Columna: READONLY, Tipo: L
Columna: CKVAL, Tipo: N
Columna: DATA, Tipo: M
Columna: UPDATED, Tipo: D

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2018 (rcp2008.dbc)\data\boletas_deshabilitadas.dbf':
Columna: DEPART, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: ZONA, Tipo: N
Columna: LOCAL, Tipo: N
Columna: TALON, Tipo: N
Columna: BOLETA, Tipo: N
Columna: SERIE_BOLE, Tipo: N
Columna: CEDULA, Tipo: N
Columna: FEC_INSCRI, Tipo: D
Columna: NOMBRE, Tipo: C
Columna: APELLIDO, Tipo: C
Columna: SEXO, Tipo: C
Columna: ID_NACION, Tipo: N
Columna: SECUENCIA, Tipo: N
Columna: IDENTIFICA, Tipo: N
Columna: ANO, Tipo: N
Columna: DESCRI_EST, Tipo: C
Columna: FECHA_HABI, Tipo: D
Columna: TIPO, Tipo: C
Columna: FECHA_INGR, Tipo: D
Columna: FEC_NAC, Tipo: D
Columna: TIPO_INSCR, Tipo: C
Columna: _NullFlags, Tipo: 0

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2018 (rcp2008.dbc)\data\ciudades.dbf':
Columna: ID_CIUDAD, Tipo: N
Columna: ID_PAIS, Tipo: N
Columna: DES_CIUDAD, Tipo: C
Columna: _NullFlags, Tipo: 0

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2018 (rcp2008.dbc)\data\dep.dbf':
Columna: DEPART, Tipo: N
Columna: DESCRIP, Tipo: C
Columna: TOT_HAB, Tipo: N
Columna: CAN_MESA, Tipo: N

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2018 (rcp2008.dbc)\data\desafiliaciones.dbf':
Columna: CEDULA, Tipo: N
Columna: APELLIDO, Tipo: C
Columna: NOMBRE, Tipo: C
Columna: LETRA_PART, Tipo: C
Columna: USUARIO, Tipo: C
Columna: FECHA, Tipo: D
Columna: PROCESADO, Tipo: C
Columna: LUGAR_PRES, Tipo: C
Columna: TIPO_DOC, Tipo: C
Columna: FECHA_DOC, Tipo: D
Columna: PARTIDO, Tipo: N
Columna: OLDCODPART, Tipo: N
Columna: _NullFlags, Tipo: 0

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2018 (rcp2008.dbc)\data\desh_exte.dbf':
Columna: IDENTIFICA, Tipo: N
Columna: ANO, Tipo: N
Columna: PAIS, Tipo: N
Columna: CIUDAD, Tipo: N
Columna: TIPO, Tipo: C
Columna: TALON, Tipo: N
Columna: BOLETA, Tipo: N
Columna: SERIE_BOLE, Tipo: N
Columna: CEDULA, Tipo: N
Columna: FEC_INSCRI, Tipo: D
Columna: NOMBRE, Tipo: C
Columna: APELLIDO, Tipo: C
Columna: FEC_NAC, Tipo: D
Columna: BARRIO, Tipo: C
Columna: SEXO, Tipo: C
Columna: ID_NACION, Tipo: N
Columna: SECUENCIA, Tipo: N
Columna: FECHA_HABI, Tipo: D
Columna: FECHA_INGR, Tipo: D
Columna: MOTIVO, Tipo: C
Columna: COD_DESHAB, Tipo: N
Columna: _NullFlags, Tipo: 0

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2018 (rcp2008.dbc)\data\dis.dbf':
Columna: DEPART, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: DESCRIP, Tipo: C
Columna: _NullFlags, Tipo: 0

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2018 (rcp2008.dbc)\data\dobles.dbf':
Columna: DEPART, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: ZONA, Tipo: N
Columna: LOCAL, Tipo: N
Columna: TALON, Tipo: N
Columna: BOLETA, Tipo: N
Columna: SERIE_BOLE, Tipo: N
Columna: CEDULA, Tipo: N
Columna: FEC_INSCRI, Tipo: D
Columna: NOMBRE, Tipo: C
Columna: APELLIDO, Tipo: C
Columna: SEXO, Tipo: C
Columna: ID_NACION, Tipo: N
Columna: TIPO, Tipo: C
Columna: FEC_NAC, Tipo: D
Columna: ID_TIPOREG, Tipo: N
Columna: _NullFlags, Tipo: 0

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2018 (rcp2008.dbc)\data\dos.dbf':
Columna: CEDULA, Tipo: C
Columna: CNT, Tipo: N

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2018 (rcp2008.dbc)\data\inhabilitados.dbf':
Columna: ID_INHABIL, Tipo: N
Columna: DEPART, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: ZONA, Tipo: N
Columna: LOCAL, Tipo: N
Columna: TALON, Tipo: N
Columna: BOLETA, Tipo: N
Columna: CEDULA, Tipo: N
Columna: NOMBRE, Tipo: C
Columna: APELLIDO, Tipo: C
Columna: SEXO, Tipo: C
Columna: FEC_NAC, Tipo: D
Columna: FEC_DEFUNC, Tipo: D
Columna: FEC_INSCRI, Tipo: D
Columna: SERIE_BOLE, Tipo: N
Columna: DIRECCION, Tipo: C
Columna: LUGNAC, Tipo: C
Columna: BARRIO, Tipo: C
Columna: FECHA_EST, Tipo: D
Columna: DESCRI_EST, Tipo: C
Columna: ID_NACION, Tipo: N
Columna: ID_TIPOREG, Tipo: N
Columna: TIPO, Tipo: C
Columna: _NullFlags, Tipo: 0

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2018 (rcp2008.dbc)\data\loc.dbf':
Columna: DPTO, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: ZONA, Tipo: N
Columna: LOCAL, Tipo: N
Columna: DESCRIP, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2018 (rcp2008.dbc)\data\nacionalidades.dbf':
Columna: ID_NACION, Tipo: N
Columna: DES_NACION, Tipo: C
Columna: _NullFlags, Tipo: 0

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2018 (rcp2008.dbc)\data\part.dbf':
Columna: CODIGO, Tipo: N
Columna: ANIO, Tipo: N
Columna: CRUZAR, Tipo: L
Columna: NOMBRE, Tipo: C
Columna: ESPARTIDO, Tipo: L
Columna: SIGLAS, Tipo: C
Columna: CERTIFICA, Tipo: L
Columna: PRI_ENTRE, Tipo: D
Columna: SEG_ENTRE, Tipo: D
Columna: RUTA, Tipo: C
Columna: NACIONAL, Tipo: C
Columna: EXTERIOR, Tipo: C
Columna: VIEJO, Tipo: C
Columna: _NullFlags, Tipo: 0

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2018 (rcp2008.dbc)\data\regciv.dbf':
Columna: DEPART, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: ZONA, Tipo: N
Columna: LOCAL, Tipo: N
Columna: TALON, Tipo: N
Columna: BOLETA, Tipo: N
Columna: CEDULA, Tipo: N
Columna: NOMBRE, Tipo: C
Columna: APELLIDO, Tipo: C
Columna: SEXO, Tipo: C
Columna: FEC_NAC, Tipo: D
Columna: FEC_INSCRI, Tipo: D
Columna: TIPO, Tipo: C
Columna: ID_NACION, Tipo: N
Columna: DIRECC, Tipo: C
Columna: PART, Tipo: C
Columna: SIGLAS, Tipo: C
Columna: MESA, Tipo: N
Columna: ORDEN, Tipo: N
Columna: COD_VOTO, Tipo: N
Columna: DES_VOTO, Tipo: C
Columna: _NullFlags, Tipo: 0

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2018 (rcp2008.dbc)\data\regciv_exte.dbf':
Columna: IDENTIFICA, Tipo: N
Columna: ANO, Tipo: N
Columna: PAIS, Tipo: N
Columna: CIUDAD, Tipo: N
Columna: TIPO, Tipo: C
Columna: TALON, Tipo: N
Columna: BOLETA, Tipo: N
Columna: SERIE_BOLE, Tipo: N
Columna: CEDULA, Tipo: N
Columna: FEC_INSCRI, Tipo: D
Columna: NOMBRE, Tipo: C
Columna: APELLIDO, Tipo: C
Columna: FEC_NAC, Tipo: D
Columna: BARRIO, Tipo: C
Columna: SEXO, Tipo: C
Columna: ID_NACION, Tipo: N
Columna: DIRECC, Tipo: C
Columna: APE2, Tipo: C
Columna: NOM2, Tipo: C
Columna: PART, Tipo: C
Columna: SIGLAS, Tipo: C
Columna: _NullFlags, Tipo: 0

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2018 (rcp2008.dbc)\data\tgen.dbf':
Columna: ETIQUETA, Tipo: C
Columna: CODIGO, Tipo: N
Columna: DESCRIP, Tipo: C
Columna: REFERENCIA, Tipo: C
Columna: _NullFlags, Tipo: 0

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2018 (rcp2008.dbc)\data\tiporeg.dbf':
Columna: ID_TIPOREG, Tipo: N
Columna: ESTADO, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2018 (rcp2008.dbc)\data\zon.dbf':
Columna: DEPART, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: ZONA, Tipo: N
Columna: DESCRIP, Tipo: C
Columna: _NullFlags, Tipo: 0

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2020 (rcp2008.dbc)\FOXUSER.dbf':
Columna: TYPE, Tipo: C
Columna: ID, Tipo: C
Columna: NAME, Tipo: M
Columna: READONLY, Tipo: L
Columna: CKVAL, Tipo: N
Columna: DATA, Tipo: M
Columna: UPDATED, Tipo: D

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2020 (rcp2008.dbc)\data\boletas_deshabilitadas.dbf':
Columna: DEPART, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: ZONA, Tipo: N
Columna: LOCAL, Tipo: N
Columna: TALON, Tipo: N
Columna: BOLETA, Tipo: N
Columna: SERIE_BOLE, Tipo: N
Columna: CEDULA, Tipo: N
Columna: FEC_INSCRI, Tipo: D
Columna: NOMBRE, Tipo: C
Columna: APELLIDO, Tipo: C
Columna: SEXO, Tipo: C
Columna: ID_NACION, Tipo: N
Columna: SECUENCIA, Tipo: N
Columna: IDENTIFICA, Tipo: N
Columna: ANO, Tipo: N
Columna: DESCRI_EST, Tipo: C
Columna: FECHA_HABI, Tipo: D
Columna: TIPO, Tipo: C
Columna: FECHA_INGR, Tipo: D
Columna: FEC_NAC, Tipo: D
Columna: TIPO_INSCR, Tipo: C
Columna: _NullFlags, Tipo: 0

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2020 (rcp2008.dbc)\data\ciudades.dbf':
Columna: ID_CIUDAD, Tipo: N
Columna: ID_PAIS, Tipo: N
Columna: DES_CIUDAD, Tipo: C
Columna: _NullFlags, Tipo: 0

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2020 (rcp2008.dbc)\data\dep.dbf':
Columna: DEPART, Tipo: N
Columna: DESCRIP, Tipo: C
Columna: TOT_HAB, Tipo: N
Columna: CAN_MESA, Tipo: N

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2020 (rcp2008.dbc)\data\desafiliaciones.dbf':
Columna: CEDULA, Tipo: N
Columna: APELLIDO, Tipo: C
Columna: NOMBRE, Tipo: C
Columna: LETRA_PART, Tipo: C
Columna: USUARIO, Tipo: C
Columna: FECHA, Tipo: D
Columna: PROCESADO, Tipo: C
Columna: LUGAR_PRES, Tipo: C
Columna: TIPO_DOC, Tipo: C
Columna: FECHA_DOC, Tipo: D
Columna: PARTIDO, Tipo: N
Columna: OLDCODPART, Tipo: N
Columna: _NullFlags, Tipo: 0

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2020 (rcp2008.dbc)\data\desh_exte.dbf':
Columna: IDENTIFICA, Tipo: N
Columna: ANO, Tipo: N
Columna: PAIS, Tipo: N
Columna: CIUDAD, Tipo: N
Columna: TIPO, Tipo: C
Columna: TALON, Tipo: N
Columna: BOLETA, Tipo: N
Columna: SERIE_BOLE, Tipo: N
Columna: CEDULA, Tipo: N
Columna: FEC_INSCRI, Tipo: D
Columna: NOMBRE, Tipo: C
Columna: APELLIDO, Tipo: C
Columna: FEC_NAC, Tipo: D
Columna: BARRIO, Tipo: C
Columna: SEXO, Tipo: C
Columna: ID_NACION, Tipo: N
Columna: SECUENCIA, Tipo: N
Columna: FECHA_HABI, Tipo: D
Columna: FECHA_INGR, Tipo: D
Columna: MOTIVO, Tipo: C
Columna: COD_DESHAB, Tipo: N
Columna: APE2, Tipo: C
Columna: NOM2, Tipo: C
Columna: _NullFlags, Tipo: 0

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2020 (rcp2008.dbc)\data\dis.dbf':
Columna: DEPART, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: DESCRIP, Tipo: C
Columna: _NullFlags, Tipo: 0

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2020 (rcp2008.dbc)\data\dobles.dbf':
Columna: DEPART, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: ZONA, Tipo: N
Columna: LOCAL, Tipo: N
Columna: TALON, Tipo: N
Columna: BOLETA, Tipo: N
Columna: SERIE_BOLE, Tipo: N
Columna: CEDULA, Tipo: N
Columna: FEC_INSCRI, Tipo: D
Columna: NOMBRE, Tipo: C
Columna: APELLIDO, Tipo: C
Columna: SEXO, Tipo: C
Columna: ID_NACION, Tipo: N
Columna: TIPO, Tipo: C
Columna: FEC_NAC, Tipo: D
Columna: ID_TIPOREG, Tipo: N
Columna: _NullFlags, Tipo: 0

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2020 (rcp2008.dbc)\data\inhabilitados.dbf':
Columna: DEPART, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: ZONA, Tipo: N
Columna: LOCAL, Tipo: N
Columna: TALON, Tipo: N
Columna: BOLETA, Tipo: N
Columna: CEDULA, Tipo: N
Columna: NOMBRE, Tipo: C
Columna: APELLIDO, Tipo: C
Columna: SEXO, Tipo: C
Columna: FEC_NAC, Tipo: D
Columna: FEC_DEFUNC, Tipo: D
Columna: FEC_INSCRI, Tipo: D
Columna: SERIE_BOLE, Tipo: N
Columna: DIRECCION, Tipo: C
Columna: LUGNAC, Tipo: C
Columna: BARRIO, Tipo: C
Columna: FECHA_EST, Tipo: D
Columna: DESCRI_EST, Tipo: C
Columna: ID_NACION, Tipo: N
Columna: ID_TIPOREG, Tipo: N
Columna: TIPO, Tipo: C
Columna: _NullFlags, Tipo: 0

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2020 (rcp2008.dbc)\data\loc.dbf':
Columna: DPTO, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: ZONA, Tipo: N
Columna: LOCAL, Tipo: N
Columna: DESCRIP, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2020 (rcp2008.dbc)\data\nacionalidades.dbf':
Columna: ID_NACION, Tipo: N
Columna: DES_NACION, Tipo: C
Columna: _NullFlags, Tipo: 0

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2020 (rcp2008.dbc)\data\part.dbf':
Columna: CODIGO, Tipo: N
Columna: ANIO, Tipo: N
Columna: CRUZAR, Tipo: L
Columna: NOMBRE, Tipo: C
Columna: ESPARTIDO, Tipo: L
Columna: SIGLAS, Tipo: C
Columna: CERTIFICA, Tipo: L
Columna: PRI_ENTRE, Tipo: D
Columna: SEG_ENTRE, Tipo: D
Columna: RUTA, Tipo: C
Columna: NACIONAL, Tipo: C
Columna: EXTERIOR, Tipo: C
Columna: VIEJO, Tipo: C
Columna: _NullFlags, Tipo: 0

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2020 (rcp2008.dbc)\data\regciv.dbf':
Columna: DEPART, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: ZONA, Tipo: N
Columna: LOCAL, Tipo: N
Columna: TALON, Tipo: N
Columna: BOLETA, Tipo: N
Columna: CEDULA, Tipo: N
Columna: NOMBRE, Tipo: C
Columna: APELLIDO, Tipo: C
Columna: SEXO, Tipo: C
Columna: FEC_NAC, Tipo: D
Columna: FEC_INSCRI, Tipo: D
Columna: TIPO, Tipo: C
Columna: ID_NACION, Tipo: N
Columna: _NullFlags, Tipo: 0

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2020 (rcp2008.dbc)\data\regciv_exte.dbf':
Columna: IDENTIFICA, Tipo: N
Columna: ANO, Tipo: N
Columna: PAIS, Tipo: N
Columna: CIUDAD, Tipo: N
Columna: TIPO, Tipo: C
Columna: TALON, Tipo: N
Columna: BOLETA, Tipo: N
Columna: SERIE_BOLE, Tipo: N
Columna: CEDULA, Tipo: N
Columna: FEC_INSCRI, Tipo: D
Columna: NOMBRE, Tipo: C
Columna: APELLIDO, Tipo: C
Columna: FEC_NAC, Tipo: D
Columna: BARRIO, Tipo: C
Columna: SEXO, Tipo: C
Columna: ID_NACION, Tipo: N
Columna: _NullFlags, Tipo: 0

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2020 (rcp2008.dbc)\data\tgen.dbf':
Columna: ETIQUETA, Tipo: C
Columna: CODIGO, Tipo: N
Columna: DESCRIP, Tipo: C
Columna: REFERENCIA, Tipo: C
Columna: _NullFlags, Tipo: 0

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2020 (rcp2008.dbc)\data\tiporeg.dbf':
Columna: ID_TIPOREG, Tipo: N
Columna: ESTADO, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2020 (rcp2008.dbc)\data\zon.dbf':
Columna: DEPART, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: ZONA, Tipo: N
Columna: DESCRIP, Tipo: C
Columna: _NullFlags, Tipo: 0

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2021\FOXUSER.dbf':
Columna: TYPE, Tipo: C
Columna: ID, Tipo: C
Columna: NAME, Tipo: M
Columna: READONLY, Tipo: L
Columna: CKVAL, Tipo: N
Columna: DATA, Tipo: M
Columna: UPDATED, Tipo: D

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2021\data\boletas_deshabilitadas.dbf':
Columna: DEPART, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: ZONA, Tipo: N
Columna: LOCAL, Tipo: N
Columna: TALON, Tipo: N
Columna: BOLETA, Tipo: N
Columna: SERIE_BOLE, Tipo: N
Columna: CEDULA, Tipo: N
Columna: FEC_INSCRI, Tipo: D
Columna: NOMBRE, Tipo: C
Columna: APELLIDO, Tipo: C
Columna: SEXO, Tipo: C
Columna: ID_NACION, Tipo: N
Columna: SECUENCIA, Tipo: N
Columna: IDENTIFICA, Tipo: N
Columna: ANO, Tipo: N
Columna: DESCRI_EST, Tipo: C
Columna: FECHA_HABI, Tipo: D
Columna: TIPO, Tipo: C
Columna: FECHA_INGR, Tipo: D
Columna: FEC_NAC, Tipo: D
Columna: TIPO_INSCR, Tipo: C
Columna: _NullFlags, Tipo: 0

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2021\data\ciudades.dbf':
Columna: ID_CIUDAD, Tipo: N
Columna: ID_PAIS, Tipo: N
Columna: DES_CIUDAD, Tipo: C
Columna: _NullFlags, Tipo: 0

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2021\data\dep.dbf':
Columna: DEPART, Tipo: N
Columna: DESCRIP, Tipo: C
Columna: TOT_HAB, Tipo: N
Columna: CAN_MESA, Tipo: N

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2021\data\desafiliaciones.dbf':
Columna: CEDULA, Tipo: N
Columna: APELLIDO, Tipo: C
Columna: NOMBRE, Tipo: C
Columna: LETRA_PART, Tipo: C
Columna: USUARIO, Tipo: C
Columna: FECHA, Tipo: D
Columna: PROCESADO, Tipo: C
Columna: LUGAR_PRES, Tipo: C
Columna: TIPO_DOC, Tipo: C
Columna: FECHA_DOC, Tipo: D
Columna: PARTIDO, Tipo: N
Columna: OLDCODPART, Tipo: N
Columna: _NullFlags, Tipo: 0

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2021\data\desh_exte.dbf':
Columna: IDENTIFICA, Tipo: N
Columna: ANO, Tipo: N
Columna: PAIS, Tipo: N
Columna: CIUDAD, Tipo: N
Columna: TIPO, Tipo: C
Columna: TALON, Tipo: N
Columna: BOLETA, Tipo: N
Columna: SERIE_BOLE, Tipo: N
Columna: CEDULA, Tipo: N
Columna: FEC_INSCRI, Tipo: D
Columna: NOMBRE, Tipo: C
Columna: APELLIDO, Tipo: C
Columna: FEC_NAC, Tipo: D
Columna: BARRIO, Tipo: C
Columna: SEXO, Tipo: C
Columna: ID_NACION, Tipo: N
Columna: SECUENCIA, Tipo: N
Columna: FECHA_HABI, Tipo: D
Columna: FECHA_INGR, Tipo: D
Columna: MOTIVO, Tipo: C
Columna: COD_DESHAB, Tipo: N
Columna: _NullFlags, Tipo: 0

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2021\data\dis.dbf':
Columna: DEPART, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: DESCRIP, Tipo: C
Columna: _NullFlags, Tipo: 0

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2021\data\dobles.dbf':
Columna: DEPART, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: ZONA, Tipo: N
Columna: LOCAL, Tipo: N
Columna: TALON, Tipo: N
Columna: BOLETA, Tipo: N
Columna: SERIE_BOLE, Tipo: N
Columna: CEDULA, Tipo: N
Columna: FEC_INSCRI, Tipo: D
Columna: NOMBRE, Tipo: C
Columna: APELLIDO, Tipo: C
Columna: SEXO, Tipo: C
Columna: ID_NACION, Tipo: N
Columna: TIPO, Tipo: C
Columna: FEC_NAC, Tipo: D
Columna: ID_TIPOREG, Tipo: N
Columna: _NullFlags, Tipo: 0

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2021\data\dos.dbf':
Columna: CEDULA, Tipo: C
Columna: CNT, Tipo: N

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2021\data\inhabilitados.dbf':
Columna: ID_INHABIL, Tipo: N
Columna: DEPART, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: ZONA, Tipo: N
Columna: LOCAL, Tipo: N
Columna: TALON, Tipo: N
Columna: BOLETA, Tipo: N
Columna: CEDULA, Tipo: N
Columna: NOMBRE, Tipo: C
Columna: APELLIDO, Tipo: C
Columna: SEXO, Tipo: C
Columna: FEC_NAC, Tipo: D
Columna: FEC_DEFUNC, Tipo: D
Columna: FEC_INSCRI, Tipo: D
Columna: SERIE_BOLE, Tipo: N
Columna: DIRECCION, Tipo: C
Columna: LUGNAC, Tipo: C
Columna: BARRIO, Tipo: C
Columna: FECHA_EST, Tipo: D
Columna: DESCRI_EST, Tipo: C
Columna: ID_NACION, Tipo: N
Columna: ID_TIPOREG, Tipo: N
Columna: TIPO, Tipo: C
Columna: _NullFlags, Tipo: 0

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2021\data\loc.dbf':
Columna: DPTO, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: ZONA, Tipo: N
Columna: LOCAL, Tipo: N
Columna: DESCRIP, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2021\data\nacionalidades.dbf':
Columna: ID_NACION, Tipo: N
Columna: DES_NACION, Tipo: C
Columna: _NullFlags, Tipo: 0

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2021\data\part.dbf':
Columna: CODIGO, Tipo: N
Columna: ANIO, Tipo: N
Columna: CRUZAR, Tipo: L
Columna: NOMBRE, Tipo: C
Columna: ESPARTIDO, Tipo: L
Columna: SIGLAS, Tipo: C
Columna: CERTIFICA, Tipo: L
Columna: PRI_ENTRE, Tipo: D
Columna: SEG_ENTRE, Tipo: D
Columna: RUTA, Tipo: C
Columna: NACIONAL, Tipo: C
Columna: EXTERIOR, Tipo: C
Columna: VIEJO, Tipo: C
Columna: _NullFlags, Tipo: 0

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2021\data\regciv.dbf':
Columna: DEPART, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: ZONA, Tipo: N
Columna: LOCAL, Tipo: N
Columna: TALON, Tipo: N
Columna: BOLETA, Tipo: N
Columna: CEDULA, Tipo: N
Columna: NOMBRE, Tipo: C
Columna: APELLIDO, Tipo: C
Columna: SEXO, Tipo: C
Columna: FEC_NAC, Tipo: D
Columna: FEC_INSCRI, Tipo: D
Columna: TIPO, Tipo: C
Columna: ID_NACION, Tipo: N
Columna: DIRECC, Tipo: C
Columna: PART, Tipo: C
Columna: SIGLAS, Tipo: C
Columna: MESA, Tipo: N
Columna: ORDEN, Tipo: N
Columna: COD_VOTO, Tipo: N
Columna: DES_VOTO, Tipo: C
Columna: NACIONAL, Tipo: C
Columna: _NullFlags, Tipo: 0

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2021\data\regciv_exte.dbf':
Columna: IDENTIFICA, Tipo: N
Columna: ANO, Tipo: N
Columna: PAIS, Tipo: N
Columna: CIUDAD, Tipo: N
Columna: TIPO, Tipo: C
Columna: TALON, Tipo: N
Columna: BOLETA, Tipo: N
Columna: SERIE_BOLE, Tipo: N
Columna: CEDULA, Tipo: N
Columna: FEC_INSCRI, Tipo: D
Columna: NOMBRE, Tipo: C
Columna: APELLIDO, Tipo: C
Columna: FEC_NAC, Tipo: D
Columna: BARRIO, Tipo: C
Columna: SEXO, Tipo: C
Columna: ID_NACION, Tipo: N
Columna: DIRECC, Tipo: C
Columna: APE2, Tipo: C
Columna: NOM2, Tipo: C
Columna: PART, Tipo: C
Columna: SIGLAS, Tipo: C
Columna: _NullFlags, Tipo: 0

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2021\data\tgen.dbf':
Columna: ETIQUETA, Tipo: C
Columna: CODIGO, Tipo: N
Columna: DESCRIP, Tipo: C
Columna: REFERENCIA, Tipo: C
Columna: _NullFlags, Tipo: 0

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2021\data\tiporeg.dbf':
Columna: ID_TIPOREG, Tipo: N
Columna: ESTADO, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2021\data\zon.dbf':
Columna: DEPART, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: ZONA, Tipo: N
Columna: DESCRIP, Tipo: C
Columna: _NullFlags, Tipo: 0

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2021 (rcp2008.dbc)\FOXUSER.dbf':
Columna: TYPE, Tipo: C
Columna: ID, Tipo: C
Columna: NAME, Tipo: M
Columna: READONLY, Tipo: L
Columna: CKVAL, Tipo: N
Columna: DATA, Tipo: M
Columna: UPDATED, Tipo: D

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2021 (rcp2008.dbc)\regciv.dbf':
Columna: DEPART, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: ZONA, Tipo: N
Columna: LOCAL, Tipo: N
Columna: TALON, Tipo: N
Columna: BOLETA, Tipo: N
Columna: CEDULA, Tipo: N
Columna: NOMBRE, Tipo: C
Columna: APELLIDO, Tipo: C
Columna: SEXO, Tipo: C
Columna: FEC_NAC, Tipo: D
Columna: FEC_INSCRI, Tipo: D
Columna: TIPO, Tipo: C
Columna: ID_NACION, Tipo: N
Columna: DIRECC, Tipo: C
Columna: PART, Tipo: C
Columna: SIGLAS, Tipo: C
Columna: MESA, Tipo: N
Columna: ORDEN, Tipo: N
Columna: COD_VOTO, Tipo: N
Columna: DES_VOTO, Tipo: C
Columna: NACIONAL, Tipo: C
Columna: _NullFlags, Tipo: 0

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2021 (rcp2008.dbc)\Back\FOXUSER.dbf':
Columna: TYPE, Tipo: C
Columna: ID, Tipo: C
Columna: NAME, Tipo: M
Columna: READONLY, Tipo: L
Columna: CKVAL, Tipo: N
Columna: DATA, Tipo: M
Columna: UPDATED, Tipo: D

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2021 (rcp2008.dbc)\data\boletas_deshabilitadas.dbf':
Columna: DEPART, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: ZONA, Tipo: N
Columna: LOCAL, Tipo: N
Columna: TALON, Tipo: N
Columna: BOLETA, Tipo: N
Columna: SERIE_BOLE, Tipo: N
Columna: CEDULA, Tipo: N
Columna: FEC_INSCRI, Tipo: D
Columna: NOMBRE, Tipo: C
Columna: APELLIDO, Tipo: C
Columna: SEXO, Tipo: C
Columna: ID_NACION, Tipo: N
Columna: SECUENCIA, Tipo: N
Columna: IDENTIFICA, Tipo: N
Columna: ANO, Tipo: N
Columna: DESCRI_EST, Tipo: C
Columna: FECHA_HABI, Tipo: D
Columna: TIPO, Tipo: C
Columna: FECHA_INGR, Tipo: D
Columna: FEC_NAC, Tipo: D
Columna: TIPO_INSCR, Tipo: C
Columna: _NullFlags, Tipo: 0

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2021 (rcp2008.dbc)\data\ciudades.dbf':
Columna: ID_CIUDAD, Tipo: N
Columna: ID_PAIS, Tipo: N
Columna: DES_CIUDAD, Tipo: C
Columna: _NullFlags, Tipo: 0

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2021 (rcp2008.dbc)\data\dep.dbf':
Columna: DEPART, Tipo: N
Columna: DESCRIP, Tipo: C
Columna: TOT_HAB, Tipo: N
Columna: CAN_MESA, Tipo: N

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2021 (rcp2008.dbc)\data\desafiliaciones.dbf':
Columna: CEDULA, Tipo: N
Columna: APELLIDO, Tipo: C
Columna: NOMBRE, Tipo: C
Columna: LETRA_PART, Tipo: C
Columna: USUARIO, Tipo: C
Columna: FECHA, Tipo: D
Columna: PROCESADO, Tipo: C
Columna: LUGAR_PRES, Tipo: C
Columna: TIPO_DOC, Tipo: C
Columna: FECHA_DOC, Tipo: D
Columna: PARTIDO, Tipo: N
Columna: OLDCODPART, Tipo: N
Columna: _NullFlags, Tipo: 0

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2021 (rcp2008.dbc)\data\desh_exte.dbf':
Columna: IDENTIFICA, Tipo: N
Columna: ANO, Tipo: N
Columna: PAIS, Tipo: N
Columna: CIUDAD, Tipo: N
Columna: TIPO, Tipo: C
Columna: TALON, Tipo: N
Columna: BOLETA, Tipo: N
Columna: SERIE_BOLE, Tipo: N
Columna: CEDULA, Tipo: N
Columna: FEC_INSCRI, Tipo: D
Columna: NOMBRE, Tipo: C
Columna: APELLIDO, Tipo: C
Columna: FEC_NAC, Tipo: D
Columna: BARRIO, Tipo: C
Columna: SEXO, Tipo: C
Columna: ID_NACION, Tipo: N
Columna: SECUENCIA, Tipo: N
Columna: FECHA_HABI, Tipo: D
Columna: FECHA_INGR, Tipo: D
Columna: MOTIVO, Tipo: C
Columna: COD_DESHAB, Tipo: N
Columna: _NullFlags, Tipo: 0

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2021 (rcp2008.dbc)\data\dis.dbf':
Columna: DEPART, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: DESCRIP, Tipo: C
Columna: _NullFlags, Tipo: 0

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2021 (rcp2008.dbc)\data\dobles.dbf':
Columna: DEPART, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: ZONA, Tipo: N
Columna: LOCAL, Tipo: N
Columna: TALON, Tipo: N
Columna: BOLETA, Tipo: N
Columna: SERIE_BOLE, Tipo: N
Columna: CEDULA, Tipo: N
Columna: FEC_INSCRI, Tipo: D
Columna: NOMBRE, Tipo: C
Columna: APELLIDO, Tipo: C
Columna: SEXO, Tipo: C
Columna: ID_NACION, Tipo: N
Columna: TIPO, Tipo: C
Columna: FEC_NAC, Tipo: D
Columna: ID_TIPOREG, Tipo: N
Columna: _NullFlags, Tipo: 0

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2021 (rcp2008.dbc)\data\dos.dbf':
Columna: CEDULA, Tipo: C
Columna: CNT, Tipo: N

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2021 (rcp2008.dbc)\data\inhabilitados.dbf':
Columna: ID_INHABIL, Tipo: N
Columna: DEPART, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: ZONA, Tipo: N
Columna: LOCAL, Tipo: N
Columna: TALON, Tipo: N
Columna: BOLETA, Tipo: N
Columna: CEDULA, Tipo: N
Columna: NOMBRE, Tipo: C
Columna: APELLIDO, Tipo: C
Columna: SEXO, Tipo: C
Columna: FEC_NAC, Tipo: D
Columna: FEC_DEFUNC, Tipo: D
Columna: FEC_INSCRI, Tipo: D
Columna: SERIE_BOLE, Tipo: N
Columna: DIRECCION, Tipo: C
Columna: LUGNAC, Tipo: C
Columna: BARRIO, Tipo: C
Columna: FECHA_EST, Tipo: D
Columna: DESCRI_EST, Tipo: C
Columna: ID_NACION, Tipo: N
Columna: ID_TIPOREG, Tipo: N
Columna: TIPO, Tipo: C
Columna: _NullFlags, Tipo: 0

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2021 (rcp2008.dbc)\data\loc.dbf':
Columna: DPTO, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: ZONA, Tipo: N
Columna: LOCAL, Tipo: N
Columna: DESCRIP, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2021 (rcp2008.dbc)\data\nacionalidades.dbf':
Columna: ID_NACION, Tipo: N
Columna: DES_NACION, Tipo: C
Columna: _NullFlags, Tipo: 0

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2021 (rcp2008.dbc)\data\part.dbf':
Columna: CODIGO, Tipo: N
Columna: ANIO, Tipo: N
Columna: CRUZAR, Tipo: L
Columna: NOMBRE, Tipo: C
Columna: ESPARTIDO, Tipo: L
Columna: SIGLAS, Tipo: C
Columna: CERTIFICA, Tipo: L
Columna: PRI_ENTRE, Tipo: D
Columna: SEG_ENTRE, Tipo: D
Columna: RUTA, Tipo: C
Columna: NACIONAL, Tipo: C
Columna: EXTERIOR, Tipo: C
Columna: VIEJO, Tipo: C
Columna: _NullFlags, Tipo: 0

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2021 (rcp2008.dbc)\data\regciv.dbf':
Columna: DEPART, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: ZONA, Tipo: N
Columna: LOCAL, Tipo: N
Columna: TALON, Tipo: N
Columna: BOLETA, Tipo: N
Columna: CEDULA, Tipo: N
Columna: NOMBRE, Tipo: C
Columna: APELLIDO, Tipo: C
Columna: SEXO, Tipo: C
Columna: FEC_NAC, Tipo: D
Columna: FEC_INSCRI, Tipo: D
Columna: TIPO, Tipo: C
Columna: ID_NACION, Tipo: N
Columna: DIRECC, Tipo: C
Columna: PART, Tipo: C
Columna: SIGLAS, Tipo: C
Columna: MESA, Tipo: N
Columna: ORDEN, Tipo: N
Columna: COD_VOTO, Tipo: N
Columna: DES_VOTO, Tipo: C
Columna: NACIONAL, Tipo: C
Columna: _NullFlags, Tipo: 0

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2021 (rcp2008.dbc)\data\regciv_exte.dbf':
Columna: IDENTIFICA, Tipo: N
Columna: ANO, Tipo: N
Columna: PAIS, Tipo: N
Columna: CIUDAD, Tipo: N
Columna: TIPO, Tipo: C
Columna: TALON, Tipo: N
Columna: BOLETA, Tipo: N
Columna: SERIE_BOLE, Tipo: N
Columna: CEDULA, Tipo: N
Columna: FEC_INSCRI, Tipo: D
Columna: NOMBRE, Tipo: C
Columna: APELLIDO, Tipo: C
Columna: FEC_NAC, Tipo: D
Columna: BARRIO, Tipo: C
Columna: SEXO, Tipo: C
Columna: ID_NACION, Tipo: N
Columna: DIRECC, Tipo: C
Columna: APE2, Tipo: C
Columna: NOM2, Tipo: C
Columna: PART, Tipo: C
Columna: SIGLAS, Tipo: C
Columna: _NullFlags, Tipo: 0

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2021 (rcp2008.dbc)\data\tgen.dbf':
Columna: ETIQUETA, Tipo: C
Columna: CODIGO, Tipo: N
Columna: DESCRIP, Tipo: C
Columna: REFERENCIA, Tipo: C
Columna: _NullFlags, Tipo: 0

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2021 (rcp2008.dbc)\data\tiporeg.dbf':
Columna: ID_TIPOREG, Tipo: N
Columna: ESTADO, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2021 (rcp2008.dbc)\data\zon.dbf':
Columna: DEPART, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: ZONA, Tipo: N
Columna: DESCRIP, Tipo: C
Columna: _NullFlags, Tipo: 0

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2021 ANR (datos.dbc)\FOXUSER.dbf':
Columna: TYPE, Tipo: C
Columna: ID, Tipo: C
Columna: NAME, Tipo: M
Columna: READONLY, Tipo: L
Columna: CKVAL, Tipo: N
Columna: DATA, Tipo: M
Columna: UPDATED, Tipo: D

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2021 ANR (datos.dbc)\mas_pda.dbf':
Columna: MESA, Tipo: N
Columna: ORDEN, Tipo: N
Columna: NUMERO_CED, Tipo: N
Columna: CODIGO_SEC, Tipo: N
Columna: SEC_ANT, Tipo: N
Columna: SLOCAL, Tipo: N
Columna: APELLIDO, Tipo: C
Columna: NOMBRE, Tipo: C
Columna: FECHA_NACI, Tipo: D
Columna: COD_DPTO, Tipo: N
Columna: COD_DIST, Tipo: N
Columna: WESTA, Tipo: N
Columna: DIRECCION, Tipo: C
Columna: NUMERO_CAS, Tipo: C
Columna: CODIGO_SEX, Tipo: N
Columna: FECHA_AFIL, Tipo: D
Columna: PARTIDO, Tipo: C
Columna: DEP_RCP, Tipo: N
Columna: DIS_RCP, Tipo: N
Columna: ZON_RCP, Tipo: N
Columna: LOC_RCP, Tipo: N
Columna: INSC_RCP, Tipo: D
Columna: TALON_RCP, Tipo: N
Columna: BOLET_RCP, Tipo: N
Columna: VOTO1, Tipo: C
Columna: VOTO2, Tipo: C
Columna: VOTO3, Tipo: C
Columna: VOTO4, Tipo: C
Columna: VOTO5, Tipo: C
Columna: SEC_LOC, Tipo: N
Columna: KEY_DDS, Tipo: C
Columna: KEYDD, Tipo: C
Columna: KEYDDZ, Tipo: C
Columna: KEYDDZL, Tipo: C
Columna: CED_APE, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2021 ANR (datos.dbc)\seccio.dbf':
Columna: CODIGO_DEP, Tipo: N
Columna: NDEPART, Tipo: C
Columna: CODIGO_DIS, Tipo: N
Columna: NDISTRITO, Tipo: C
Columna: ZONA, Tipo: N
Columna: CODIGO_SEC, Tipo: N
Columna: DESCRIPCIO, Tipo: C
Columna: W_SECCIO, Tipo: C
Columna: DIRECCION, Tipo: C
Columna: LOCAL_VOTA, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2021 ANR (datos.dbc)\secc_local.dbf':
Columna: CODIGO_DEP, Tipo: N
Columna: CODIGO_DIS, Tipo: N
Columna: CODIGO_SEC, Tipo: N
Columna: COD_LOCAL, Tipo: N
Columna: NOMBRE_LOC, Tipo: C
Columna: DIRECCION, Tipo: C
Columna: SEC_LOCAL, Tipo: N

Estructura de la tabla DBF 'D:\PADRONES\Padrón 2021 PLRA (puros.dbc)\FOXUSER.dbf':
Columna: TYPE, Tipo: C
Columna: ID, Tipo: C
Columna: NAME, Tipo: M
Columna: READONLY, Tipo: L
Columna: CKVAL, Tipo: N
Columna: DATA, Tipo: M
Columna: UPDATED, Tipo: D

Estructura de la tabla DBF 'D:\PADRONES\Padrón UNACE (rcp2008.dbc)\auxpad.dbf':
Columna: CEDULA, Tipo: C
Columna: MARCA, Tipo: C
Columna: DEPART, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: ZONA, Tipo: N
Columna: LOCAL, Tipo: N
Columna: TALON, Tipo: N
Columna: BOLETA, Tipo: N
Columna: NOMBRE, Tipo: C
Columna: APELLIDO, Tipo: C
Columna: NACIONAL, Tipo: N
Columna: INS_RCP, Tipo: C
Columna: DIREC_RCP, Tipo: C
Columna: CODIGO_SEC, Tipo: N
Columna: LOCALVO, Tipo: C
Columna: MESA, Tipo: N
Columna: ORDEN, Tipo: N
Columna: DES_DIS, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\Padrón UNACE (rcp2008.dbc)\consulta_ref.dbf':
Columna: UNIQUEID, Tipo: C
Columna: SETID, Tipo: C
Columna: REFID, Tipo: C
Columna: REFTYPE, Tipo: C
Columna: FINDTYPE, Tipo: C
Columna: FILEID, Tipo: C
Columna: SYMBOL, Tipo: M
Columna: CLASSNAME, Tipo: M
Columna: PROCNAME, Tipo: M
Columna: PROCLINENO, Tipo: I
Columna: LINENO, Tipo: I
Columna: COLPOS, Tipo: I
Columna: MATCHLEN, Tipo: I
Columna: ABSTRACT, Tipo: M
Columna: RECORDID, Tipo: C
Columna: UPDFIELD, Tipo: C
Columna: CHECKED, Tipo: L
Columna: NOREPLACE, Tipo: L
Columna: TIMESTAMP, Tipo: T
Columna: INACTIVE, Tipo: L
Columna: _NullFlags, Tipo: 0

Estructura de la tabla DBF 'D:\PADRONES\Padrón UNACE (rcp2008.dbc)\DIST.dbf':
Columna: DEPART, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: DESCRI, Tipo: C
Columna: D_DI, Tipo: C
Columna: CAN_DI, Tipo: C
Columna: UDPTO, Tipo: C
Columna: UDISTRITO, Tipo: C
Columna: UDESCRI, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\Padrón UNACE (rcp2008.dbc)\dpto.dbf':
Columna: DPTO, Tipo: N
Columna: DESCRI, Tipo: C
Columna: D_DE, Tipo: C
Columna: CAN_DE, Tipo: N

Estructura de la tabla DBF 'D:\PADRONES\Padrón UNACE (rcp2008.dbc)\FOXUSER.dbf':
Columna: TYPE, Tipo: C
Columna: ID, Tipo: C
Columna: NAME, Tipo: M
Columna: READONLY, Tipo: L
Columna: CKVAL, Tipo: N
Columna: DATA, Tipo: M
Columna: UPDATED, Tipo: D

Estructura de la tabla DBF 'D:\PADRONES\Padrón UNACE (rcp2008.dbc)\local.dbf':
Columna: DPTO, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: ZONA, Tipo: N
Columna: LOCAL, Tipo: N
Columna: DESCRI, Tipo: C
Columna: SECTOR, Tipo: N
Columna: ESTATUTO, Tipo: C
Columna: D_LO, Tipo: C
Columna: D_ZO, Tipo: C
Columna: D_DI, Tipo: C
Columna: D_DE, Tipo: C
Columna: UDPTO, Tipo: C
Columna: UDISTRITO, Tipo: C
Columna: UZONA, Tipo: C
Columna: ULOCAL, Tipo: C
Columna: UDESCRI, Tipo: C
Columna: UDIRECCION, Tipo: C
Columna: LOCALDIRE, Tipo: C
Columna: ERADESCRI, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\Padrón UNACE (rcp2008.dbc)\padron.dbf':
Columna: CEDULA, Tipo: C
Columna: MARCA, Tipo: C
Columna: DEPART, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: ZONA, Tipo: N
Columna: LOCAL, Tipo: N
Columna: TALON, Tipo: N
Columna: BOLETA, Tipo: N
Columna: NOMBRE, Tipo: C
Columna: APELLIDO, Tipo: C
Columna: NACIONAL, Tipo: N
Columna: INS_RCP, Tipo: C
Columna: DIREC_RCP, Tipo: C
Columna: COD_SECREA, Tipo: N
Columna: CODIGO_SEC, Tipo: N
Columna: LOCALVO, Tipo: C
Columna: MESA, Tipo: N
Columna: ORDEN, Tipo: N
Columna: DES_DIS, Tipo: C
Columna: NUMERAL, Tipo: C
Columna: DES_DEP, Tipo: C
Columna: DES_ZON, Tipo: C
Columna: DES_LOC, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\Padrón UNACE (rcp2008.dbc)\raoviedo.dbf':
Columna: CEDULA, Tipo: C
Columna: MARCA, Tipo: C
Columna: DEPART, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: ZONA, Tipo: N
Columna: LOCAL, Tipo: N
Columna: TALON, Tipo: N
Columna: BOLETA, Tipo: N
Columna: NOMBRE, Tipo: C
Columna: APELLIDO, Tipo: C
Columna: NACIONAL, Tipo: N
Columna: INS_RCP, Tipo: C
Columna: DIREC_RCP, Tipo: C
Columna: COD_SECREA, Tipo: N
Columna: CODIGO_SEC, Tipo: N
Columna: LOCALVO, Tipo: C
Columna: MESA, Tipo: N
Columna: ORDEN, Tipo: N
Columna: DES_DIS, Tipo: C
Columna: NUMERAL, Tipo: C
Columna: DES_DEP, Tipo: C
Columna: DES_ZON, Tipo: C
Columna: DES_LOC, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\Padrón UNACE (rcp2008.dbc)\tembiapora.dbf':
Columna: CEDULA, Tipo: C
Columna: MARCA, Tipo: C
Columna: DEPART, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: ZONA, Tipo: N
Columna: LOCAL, Tipo: N
Columna: TALON, Tipo: N
Columna: BOLETA, Tipo: N
Columna: NOMBRE, Tipo: C
Columna: APELLIDO, Tipo: C
Columna: NACIONAL, Tipo: N
Columna: INS_RCP, Tipo: C
Columna: DIREC_RCP, Tipo: C
Columna: COD_SECREA, Tipo: N
Columna: CODIGO_SEC, Tipo: N
Columna: LOCALVO, Tipo: C
Columna: MESA, Tipo: N
Columna: ORDEN, Tipo: N
Columna: DES_DIS, Tipo: C
Columna: NUMERAL, Tipo: C
Columna: DES_DEP, Tipo: C
Columna: DES_ZON, Tipo: C
Columna: DES_LOC, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\Padrón UNACE (rcp2008.dbc)\tembiapora2.dbf':
Columna: CEDULA, Tipo: C
Columna: MARCA, Tipo: C
Columna: DEPART, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: ZONA, Tipo: N
Columna: LOCAL, Tipo: N
Columna: TALON, Tipo: N
Columna: BOLETA, Tipo: N
Columna: NOMBRE, Tipo: C
Columna: APELLIDO, Tipo: C
Columna: NACIONAL, Tipo: N
Columna: INS_RCP, Tipo: C
Columna: DIREC_RCP, Tipo: C
Columna: COD_SECREA, Tipo: N
Columna: CODIGO_SEC, Tipo: N
Columna: LOCALVO, Tipo: C
Columna: MESA, Tipo: N
Columna: ORDEN, Tipo: N
Columna: DES_DIS, Tipo: C
Columna: NUMERAL, Tipo: C
Columna: DES_DEP, Tipo: C
Columna: DES_ZON, Tipo: C
Columna: DES_LOC, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\Padrón UNACE (rcp2008.dbc)\ZONA.dbf':
Columna: DPTO, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: ZONA, Tipo: N
Columna: DESCRI, Tipo: C
Columna: D_ZO, Tipo: C
Columna: UDPTO, Tipo: C
Columna: UDISTRITO, Tipo: C
Columna: UZONA, Tipo: C
Columna: UDESCRI, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\Padrón UNACE (rcp2008.dbc)\data\dep.dbf':
Columna: DEPART, Tipo: N
Columna: DESCRIP, Tipo: C
Columna: TOT_HAB, Tipo: N
Columna: CAN_MESA, Tipo: N

Estructura de la tabla DBF 'D:\PADRONES\Padrón UNACE (rcp2008.dbc)\data\deshabilitados.dbf':
Columna: DEPART, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: ZONA, Tipo: N
Columna: LOCAL, Tipo: N
Columna: TALON, Tipo: N
Columna: BOLETA, Tipo: N
Columna: CEDULA, Tipo: C
Columna: FEC_INSCRI, Tipo: C
Columna: NOMBRE, Tipo: C
Columna: APELLIDO, Tipo: C
Columna: FEC_NAC, Tipo: N
Columna: SEXO, Tipo: C
Columna: NACIONAL, Tipo: C
Columna: OBS, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\Padrón UNACE (rcp2008.dbc)\data\difuntos.dbf':
Columna: CEDULA, Tipo: C
Columna: NOMBRE, Tipo: C
Columna: APELLIDO, Tipo: C
Columna: FEC_NAC, Tipo: N
Columna: FEC_DEF, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\Padrón UNACE (rcp2008.dbc)\data\dis.dbf':
Columna: DEPART, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: DESCRIP, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\Padrón UNACE (rcp2008.dbc)\data\dobles.dbf':
Columna: DEPART, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: ZONA, Tipo: N
Columna: LOCAL, Tipo: N
Columna: TALON, Tipo: N
Columna: BOLETA, Tipo: N
Columna: CEDULA, Tipo: C
Columna: FEC_INSCRI, Tipo: C
Columna: NOMBRE, Tipo: C
Columna: APELLIDO, Tipo: C
Columna: FEC_NAC, Tipo: N
Columna: SEXO, Tipo: C
Columna: NACIONAL, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\Padrón UNACE (rcp2008.dbc)\data\interdictos.dbf':
Columna: DEPART, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: ZONA, Tipo: N
Columna: LOCAL, Tipo: N
Columna: TALON, Tipo: N
Columna: BOLETA, Tipo: N
Columna: FECINS, Tipo: C
Columna: CEDULA, Tipo: C
Columna: NOMBRE, Tipo: C
Columna: APELLIDO, Tipo: C
Columna: FEC_NAC, Tipo: N
Columna: SEXO, Tipo: C
Columna: NACIONAL, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\Padrón UNACE (rcp2008.dbc)\data\loc.dbf':
Columna: DPTO, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: ZONA, Tipo: N
Columna: LOCAL, Tipo: N
Columna: DESCRIP, Tipo: C
Columna: DIREC, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\Padrón UNACE (rcp2008.dbc)\data\menores.dbf':
Columna: DEPART, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: ZONA, Tipo: N
Columna: LOCAL, Tipo: N
Columna: TALON, Tipo: N
Columna: BOLETA, Tipo: N
Columna: CEDULA, Tipo: C
Columna: FEC_INS, Tipo: C
Columna: NOMBRE, Tipo: C
Columna: APELLIDO, Tipo: C
Columna: FEC_NAC, Tipo: N
Columna: SEXO, Tipo: C
Columna: NACIONAL, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\Padrón UNACE (rcp2008.dbc)\data\NAZARET.dbf':
Columna: DEPART, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: ZONA, Tipo: N
Columna: LOCAL, Tipo: N
Columna: TALON, Tipo: N
Columna: BOLETA, Tipo: N
Columna: FEC_INSCRI, Tipo: C
Columna: CEDULA, Tipo: C
Columna: NOMBRE, Tipo: C
Columna: APELLIDO, Tipo: C
Columna: SEXO, Tipo: C
Columna: FEC_NAC, Tipo: N
Columna: NACIONAL, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\Padrón UNACE (rcp2008.dbc)\data\part.dbf':
Columna: LISTA, Tipo: N
Columna: COD, Tipo: C
Columna: DESCRIP, Tipo: C
Columna: SIGLAS, Tipo: C
Columna: AFILS, Tipo: N

Estructura de la tabla DBF 'D:\PADRONES\Padrón UNACE (rcp2008.dbc)\data\pol_y_mil.dbf':
Columna: DEPART, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: ZONA, Tipo: N
Columna: LOCAL, Tipo: N
Columna: TALON, Tipo: N
Columna: BOLETA, Tipo: N
Columna: CEDULA, Tipo: C
Columna: FECINS, Tipo: C
Columna: NOMBRE, Tipo: C
Columna: APELLIDO, Tipo: C
Columna: FEC_NAC, Tipo: N
Columna: SEXO, Tipo: C
Columna: NACIONAL, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\Padrón UNACE (rcp2008.dbc)\data\regciv.dbf':
Columna: DEPART, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: ZONA, Tipo: N
Columna: LOCAL, Tipo: N
Columna: TALON, Tipo: N
Columna: BOLETA, Tipo: N
Columna: FEC_INSCRI, Tipo: C
Columna: CEDULA, Tipo: C
Columna: NOMBRE, Tipo: C
Columna: APELLIDO, Tipo: C
Columna: SEXO, Tipo: C
Columna: FEC_NAC, Tipo: N
Columna: NACIONAL, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\Padrón UNACE (rcp2008.dbc)\data\SALAZAR.dbf':
Columna: DEPART, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: ZONA, Tipo: N
Columna: LOCAL, Tipo: N
Columna: TALON, Tipo: N
Columna: BOLETA, Tipo: N
Columna: FEC_INSCRI, Tipo: C
Columna: CEDULA, Tipo: C
Columna: NOMBRE, Tipo: C
Columna: APELLIDO, Tipo: C
Columna: SEXO, Tipo: C
Columna: FEC_NAC, Tipo: N
Columna: NACIONAL, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\Padrón UNACE (rcp2008.dbc)\data\zon.dbf':
Columna: DEPART, Tipo: N
Columna: DISTRITO, Tipo: N
Columna: ZONA, Tipo: N
Columna: DESCRIP, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\RUC\RUC.dbf':
Columna: ID_RUC, Tipo: N
Columna: RUCDIGITO, Tipo: C
Columna: RAZON, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\RUC\RUC2017.dbf':
Columna: ID_RUC, Tipo: N
Columna: RUCDIGITO, Tipo: C
Columna: RAZON, Tipo: C
Columna: DIGITO, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\SATI\APP\FOXUSER.dbf':
Columna: TYPE, Tipo: C
Columna: ID, Tipo: C
Columna: NAME, Tipo: M
Columna: READONLY, Tipo: L
Columna: CKVAL, Tipo: N
Columna: DATA, Tipo: M
Columna: UPDATED, Tipo: D

Estructura de la tabla DBF 'D:\PADRONES\SATI\DATOS\cedauto.dbf':
Columna: CED_TIPO, Tipo: C
Columna: CED_SITU, Tipo: C
Columna: CED_NROCED, Tipo: N
Columna: CED_FECHAG, Tipo: D
Columna: CED_VTO, Tipo: C
Columna: CED_FECHAE, Tipo: C
Columna: CED_NOMBRE, Tipo: C
Columna: CED_APELLI, Tipo: C
Columna: CED_NOMAPE, Tipo: C
Columna: CED_DOCTIT, Tipo: C
Columna: CED_DIRECC, Tipo: C
Columna: CED_LOCALI, Tipo: C
Columna: CED_DEPTO, Tipo: C
Columna: CED_CHAPA, Tipo: C
Columna: CED_MARCA, Tipo: C
Columna: CED_MODELO, Tipo: C
Columna: CED_TIPOVE, Tipo: C
Columna: CED_A_OMOD, Tipo: N
Columna: CED_CHASSI, Tipo: C
Columna: CED_MOTOR, Tipo: C
Columna: CED_COLOR, Tipo: C
Columna: OBSER, Tipo: N

Estructura de la tabla DBF 'D:\PADRONES\SATI\DATOS\celulares.dbf':
Columna: N1, Tipo: N
Columna: N2, Tipo: N
Columna: TRABAJO, Tipo: C
Columna: DIREC, Tipo: C
Columna: APELLIDO, Tipo: C
Columna: NOMBRE, Tipo: C
Columna: N7, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\SATI\DATOS\provisorios.dbf':
Columna: NROENT, Tipo: C
Columna: FECHAENT, Tipo: C
Columna: OFICINAREG, Tipo: C
Columna: DOCUMENTO, Tipo: C
Columna: SITUACION, Tipo: C
Columna: NOMBRE, Tipo: C
Columna: APELLIDO, Tipo: C
Columna: MARCA, Tipo: C
Columna: MODELO, Tipo: C
Columna: CHASSIS, Tipo: C
Columna: TIPO, Tipo: C
Columna: COLOR, Tipo: C
Columna: MATRICULA, Tipo: C
Columna: NROHOJA, Tipo: C
Columna: NROSTICKER, Tipo: C
Columna: FECHAIMP, Tipo: C

Estructura de la tabla DBF 'D:\PADRONES\SATI\Formularios\FOXUSER.dbf':
Columna: TYPE, Tipo: C
Columna: ID, Tipo: C
Columna: NAME, Tipo: M
Columna: READONLY, Tipo: L
Columna: CKVAL, Tipo: N
Columna: DATA, Tipo: M
Columna: UPDATED, Tipo: D

Estructura de la tabla DBF 'D:\PADRONES\zpt\Instalar\FOXUSER.dbf':
Columna: TYPE, Tipo: C
Columna: ID, Tipo: C
Columna: NAME, Tipo: M
Columna: READONLY, Tipo: L
Columna: CKVAL, Tipo: N
Columna: DATA, Tipo: M
Columna: UPDATED, Tipo: D

Estructura de la tabla DBF 'D:\PADRONES\zpt\Instalar\registro.dbf':
Columna: ID, Tipo: I
Columna: CEDULA_ID, Tipo: N
Columna: VENTA, Tipo: N
Columna: VENDEDOR, Tipo: N
Columna: FECHA, Tipo: D

Estructura de la tabla DBF 'D:\PADRONES\zpt\Instalar\seguridad\FOXUSER.dbf':
Columna: TYPE, Tipo: C
Columna: ID, Tipo: C
Columna: NAME, Tipo: M
Columna: READONLY, Tipo: L
Columna: CKVAL, Tipo: N
Columna: DATA, Tipo: M
Columna: UPDATED, Tipo: D

Estructura de la tabla DBF 'D:\PADRONES\zpt\instalar-2015\FOXUSER.dbf':
Columna: TYPE, Tipo: C
Columna: ID, Tipo: C
Columna: NAME, Tipo: M
Columna: READONLY, Tipo: L
Columna: CKVAL, Tipo: N
Columna: DATA, Tipo: M
Columna: UPDATED, Tipo: D

Estructura de la tabla DBF 'D:\PADRONES\zpt\instalar-2015\registro.dbf':
Columna: ID, Tipo: I
Columna: CEDULA_ID, Tipo: N
Columna: VENTA, Tipo: N
Columna: VENDEDOR, Tipo: N
Columna: FECHA, Tipo: D

Estructura de la tabla DBF 'D:\PADRONES\zpt\instalar-2015\seguridad\FOXUSER.dbf':
Columna: TYPE, Tipo: C
Columna: ID, Tipo: C
Columna: NAME, Tipo: M
Columna: READONLY, Tipo: L
Columna: CKVAL, Tipo: N
Columna: DATA, Tipo: M
Columna: UPDATED, Tipo: D

Estructura de la tabla DBF 'D:\PADRONES\zpt\instalar09\FOXUSER.dbf':
Columna: TYPE, Tipo: C
Columna: ID, Tipo: C
Columna: NAME, Tipo: M
Columna: READONLY, Tipo: L
Columna: CKVAL, Tipo: N
Columna: DATA, Tipo: M
Columna: UPDATED, Tipo: D

Estructura de la tabla DBF 'D:\PADRONES\zpt\instalar09\registro.dbf':
Columna: ID, Tipo: I
Columna: CEDULA_ID, Tipo: N
Columna: VENTA, Tipo: N
Columna: VENDEDOR, Tipo: N
Columna: FECHA, Tipo: D

Estructura de la tabla DBF 'D:\PADRONES\zpt\ZORRITO ADESFA\FOXUSER.dbf':
Columna: TYPE, Tipo: C
Columna: ID, Tipo: C
Columna: NAME, Tipo: M
Columna: READONLY, Tipo: L
Columna: CKVAL, Tipo: N
Columna: DATA, Tipo: M
Columna: UPDATED, Tipo: D

Estructura de la tabla DBF 'D:\PADRONES\zpt\ZORRITO ADESFA\registro.dbf':
Columna: ID, Tipo: I
Columna: CEDULA_ID, Tipo: N
Columna: VENTA, Tipo: N
Columna: VENDEDOR, Tipo: N
Columna: FECHA, Tipo: D

Estructura de la tabla Firebird 'SIS':
Columna: 1, Tipo: AI                             
Columna: 2, Tipo: AI                             
Columna: 3, Tipo: AI                             
Columna: 4, Tipo: AI                             
Columna: 5, Tipo: AI                             
Columna: 6, Tipo: AI                             
Columna: 7, Tipo: AI                             
Columna: 8, Tipo: AI                             
Columna: 9, Tipo: AI                             
Columna: 10, Tipo: AI                             
Columna: PRODUCTO, Tipo: DESCRIPCION_CORTO              

Estructura de la tabla Firebird 'UCTABRIGHTS':
Columna: UCKEY, Tipo: RDB$8                          
Columna: UCCOMPNAME, Tipo: RDB$7                          
Columna: UCMODULE, Tipo: RDB$6                          
Columna: UCIDUSER, Tipo: RDB$5                          

Estructura de la tabla Firebird 'CLIENTE':
Columna: IMAGEN, Tipo: PICTURE                        
Columna: ACTIVO, Tipo: ENTERO                         
Columna: EMAIL, Tipo: NOMBRE_LARGO                   
Columna: AI_CLIENTE, Tipo: ENTERO                         
Columna: APELLIDO, Tipo: DESCRIPTION_LARGE              
Columna: DIRECCION, Tipo: DESCRIPTION_LARGE              
Columna: ID_CIUDAD, Tipo: AI                             
Columna: ID_GRUPO_CLIENTE, Tipo: AI                             
Columna: MEMO, Tipo: MEMO                           
Columna: ORDEN_VISITA, Tipo: AI                             
Columna: OBSERVACION, Tipo: MEMO                           
Columna: NOMBRE, Tipo: DESCRIPTION_SHORT              
Columna: TELEFONO, Tipo: DESCRIPTION_SHORT              
Columna: RUC, Tipo: DESCRIPTION_SHORT              
Columna: BARRIO, Tipo: DESCRIPTION_SHORT              
Columna: CONTACTO, Tipo: DESCRIPTION_SHORT              
Columna: CONTACTO2, Tipo: DESCRIPTION_SHORT              
Columna: DOCUMENTO_1, Tipo: DESCRIPTION_SHORT              
Columna: DOCUMENTO_2, Tipo: DESCRIPTION_SHORT              
Columna: CELULAR, Tipo: DESCRIPTION_SHORT              
Columna: TELEFONO_1, Tipo: DESCRIPTION_SHORT              
Columna: TELEFONO_2, Tipo: DESCRIPTION_SHORT              
Columna: CALIFICACION, Tipo: NOMBRE_CORTO                   
Columna: RECIBIRPEDIDO, Tipo: SI_NO_NO                       
Columna: LATITUD, Tipo: DESCRIPTION_SHORT              
Columna: LONGITUD, Tipo: DESCRIPTION_SHORT              
Columna: FECHA_NACIMIENTO, Tipo: FECHA                          
Columna: DIRECCIONTRABAJO, Tipo: MEMO                           
Columna: ID_VENDEDOR, Tipo: ENTERO                         
Columna: LUGARTRABAJO, Tipo: DESCRIPTION_LARGE              
Columna: LATITUD1, Tipo: DESCRIPTION_SHORT              
Columna: LONGITUD1, Tipo: DESCRIPTION_SHORT              
Columna: FEC_NAC, Tipo: RDB$2381                       

Estructura de la tabla Firebird 'CIUDAD':
Columna: CODIGOAREA, Tipo: CODIGO_AREA                    
Columna: ID_CIUDAD, Tipo: AI                             
Columna: ID_PAIS, Tipo: AI                             
Columna: NOMBRE, Tipo: DESCRIPTION_SHORT              

Estructura de la tabla Firebird 'UCTABRIGHTSEX':
Columna: UCKEY, Tipo: RDB$13                         
Columna: UCFORMNAME, Tipo: RDB$12                         
Columna: UCCOMPNAME, Tipo: RDB$11                         
Columna: UCMODULE, Tipo: RDB$10                         
Columna: UCIDUSER, Tipo: RDB$9                          

Estructura de la tabla Firebird 'EMPRESA_CLAVE':
Columna: FECHA, Tipo: RDB$2155                       
Columna: ID_EMPRESA, Tipo: AI                             
Columna: PRODUCTO, Tipo: DESCRIPCION_CORTO              
Columna: CLAVE, Tipo: DESCRIPCION_CORTO              

Estructura de la tabla Firebird 'UCTABUSERSLOGGED':
Columna: UCDATA, Tipo: RDB$18                         
Columna: UCMACHINENAME, Tipo: RDB$17                         
Columna: UCAPPLICATIONID, Tipo: RDB$16                         
Columna: UCIDUSER, Tipo: RDB$15                         
Columna: UCIDLOGON, Tipo: RDB$14                         

Estructura de la tabla Firebird 'EMPRESA':
Columna: PAGARE, Tipo: PICTURE                        
Columna: IMAGEN, Tipo: PICTURE                        
Columna: PUERTO_SERVIDOR, Tipo: ENTERO                         
Columna: CONTRASE_EMAIL, Tipo: DESCRIPCION_MEDIO              
Columna: DIRECCION, Tipo: DIRECION                       
Columna: LINEA1, Tipo: DIRECION                       
Columna: LINEA2, Tipo: DIRECION                       
Columna: IDEOLOGIA, Tipo: DIRECION                       
Columna: NOMBRE_SERVIDOR, Tipo: DESCRIPTION_LARGE              
Columna: MAXIMO_ITEMS_COMPRA, Tipo: AI                             
Columna: MAXIMO_ITEMS_SALIDA, Tipo: AI                             
Columna: MAXIMO_ITEMS_ENTRADA, Tipo: AI                             
Columna: MAXIMO_ITEMS_TRANFERENCIA, Tipo: ENTERO                         
Columna: PROMOCION_LINEA2, Tipo: MEMO                           
Columna: PROMOCION_LINEA, Tipo: MEMO                           
Columna: ID_EMPRESA, Tipo: AI                             
Columna: RAZON, Tipo: DESCRIPTION_LARGE              
Columna: ID_CIUDAD, Tipo: AI                             
Columna: EMAIL, Tipo: DESCRIPTION_LARGE              
Columna: WEB, Tipo: DESCRIPTION_LARGE              
Columna: REGISTRO, Tipo: DESCRIPTION_LARGE              
Columna: MAXIMO_ITEMS_VENTA, Tipo: ENTERO                         
Columna: ID_LENGUAJE, Tipo: ENTERO_CORTO                   
Columna: GUARDAR_EVENTOSS, Tipo: YES_NO                         
Columna: CAN_INSER_INCOM, Tipo: YES_NO                         
Columna: COMPROBAR_DO_CLI, Tipo: YES_NO                         
Columna: COMPROBAR_BA_PRO, Tipo: YES_NO                         
Columna: PANTALLA_MODAL, Tipo: YES_NO                         
Columna: PERMITIR_AUTO_CARGA, Tipo: YES_NO                         
Columna: TELEFONO1, Tipo: DESCRIPTION_SHORT              
Columna: TELEFONO2, Tipo: DESCRIPTION_SHORT              
Columna: FAX1, Tipo: DESCRIPTION_SHORT              
Columna: FAX2, Tipo: DESCRIPTION_SHORT              
Columna: NOMBRE, Tipo: DESCRIPTION_SHORT              
Columna: MEMBRETE_HACIENDA, Tipo: YES_NO                         
Columna: OFRECER_PROMOCION, Tipo: NO_YES_YES                     
Columna: EMAILDESALDOBIENVENIDA, Tipo: SI_NO_NO                       
Columna: CONTROLARSTOCK, Tipo: SI_NO_NO                       

Estructura de la tabla Firebird 'UCTABUSERS':
Columna: UCEMAIL, Tipo: RDB$40                         
Columna: UCLOGIN, Tipo: RDB$35                         
Columna: UCUSERNAME, Tipo: RDB$26                         
Columna: UCKEY, Tipo: RDB$44                         
Columna: UCPROFILE, Tipo: RDB$43                         
Columna: UCPRIVILEGED, Tipo: RDB$41                         
Columna: UCUSERDAYSSUN, Tipo: RDB$39                         
Columna: UCUSEREXPIRED, Tipo: RDB$38                         
Columna: UCPASSWORD, Tipo: RDB$36                         
Columna: UCIDUSER, Tipo: RDB$19                         
Columna: UCPASSEXPIRED, Tipo: RDB$37                         
Columna: UCTYPEREC, Tipo: RDB$42                         

Estructura de la tabla Firebird 'VENDEDOR':
Columna: PORCENTAJE_VENTA, Tipo: NUMERO                         
Columna: FECHA_NACIMIENTO, Tipo: RDB$509                        
Columna: DIRECCION, Tipo: DESCRIPTION_LARGE              
Columna: EMAIL, Tipo: DESCRIPTION_LARGE              
Columna: ID_VENDEDOR, Tipo: AI                             
Columna: ACTIVO, Tipo: YES_NO                         
Columna: RUC, Tipo: DESCRIPTION_SHORT              
Columna: TELEFONO, Tipo: DESCRIPTION_SHORT              
Columna: APELLIDO_MATERNO, Tipo: DESCRIPTION_SHORT              
Columna: APELLIDO_PATERNO, Tipo: DESCRIPTION_SHORT              
Columna: NOMBRE, Tipo: DESCRIPTION_SHORT              
Columna: ID_USUARIO, Tipo: ENTERO                         
Columna: CLAVEACCESO, Tipo: NOMBRE_CORTO                   

Estructura de la tabla Firebird 'CUENTA_CLIENTE':
Columna: CREDITO, Tipo: NUMERO                         
Columna: DEBITO, Tipo: NUMERO                         
Columna: ID_COBRANZA_DETALLE, Tipo: ENTERO                         
Columna: REFERENCIA, Tipo: NUMERO_MEDIO                   
Columna: VENCIMIENTO, Tipo: DATE                           
Columna: ID_CUENTA_CLIENTE, Tipo: NUMERO_MEDIO                   
Columna: ID_COMPROBANTE, Tipo: NUMERO_MEDIO                   
Columna: FECHA, Tipo: DATE                           
Columna: ID_CLIENTE, Tipo: ENTERO                         
Columna: ID_PERSONAL, Tipo: AI                             
Columna: NRO, Tipo: NOMBRE_CORTO                   
Columna: DESCRIPCION, Tipo: DESCRIPTION_SHORT              
Columna: DE_HASTA, Tipo: ALIAS                          
Columna: ID_VENTA, Tipo: ENTERO                         
Columna: ID_FORMA_PAGO, Tipo: ENTERO                         
Columna: ID_METO_PAGO, Tipo: ENTERO                         

Estructura de la tabla Firebird 'PAIS':
Columna: AREA_CODIGO, Tipo: CODIGO_AREA                    
Columna: ID_PAIS, Tipo: AI                             
Columna: NOMBRE, Tipo: DESCRIPTION_SHORT              
Columna: NACIONALIDAD, Tipo: DESCRIPTION_SHORT              

Estructura de la tabla Firebird 'GRUPO_CLIENTE':
Columna: ID_GRUPO_CLIENTE, Tipo: AI                             
Columna: DESCRIPCION, Tipo: DESCRIPTION_SHORT              
Columna: ID_VENDEDOR, Tipo: ENTERO                         

Estructura de la tabla Firebird 'FIB$DATASETS_INFO':
Columna: CONDITIONS, Tipo: RDB$5606                       
Columna: REFRESH_SQL, Tipo: RDB$5602                       
Columna: DELETE_SQL, Tipo: RDB$5601                       
Columna: INSERT_SQL, Tipo: RDB$5600                       
Columna: UPDATE_SQL, Tipo: RDB$5599                       
Columna: SELECT_SQL, Tipo: RDB$5598                       
Columna: FIB$VERSION, Tipo: RDB$5607                       
Columna: DS_ID, Tipo: RDB$5596                       
Columna: UPDATE_ONLY_MODIFIED_FIELDS, Tipo: FIB$BOOLEAN                    
Columna: UPDATE_TABLE_NAME, Tipo: RDB$5605                       
Columna: KEY_FIELD, Tipo: RDB$5604                       
Columna: NAME_GENERATOR, Tipo: RDB$5603                       
Columna: DESCRIPTION, Tipo: RDB$5597                       

Estructura de la tabla Firebird 'EMAIL_PENDIENTES':
Columna: ADJUNTO, Tipo: MEMO_CORTO                     
Columna: ID_EMAIL_PENDIENTES, Tipo: ENTERO                         
Columna: EMAIL, Tipo: DESCRIPTION_LARGE              
Columna: ASUNTO, Tipo: DESCRIPTION_LARGE              
Columna: CONTENIDO, Tipo: MEMO                           
Columna: ENVIADO, Tipo: YES_NO                         

Estructura de la tabla Firebird 'PRODUCTO':
Columna: PRECIO_COSTO, Tipo: NUMERO                         
Columna: PESO, Tipo: NUMERO                         
Columna: PRECIO3, Tipo: NUMERO                         
Columna: PRECIO2, Tipo: NUMERO                         
Columna: PRECIO1, Tipo: NUMERO                         
Columna: ID_PRODUCTO, Tipo: ENTERO                         
Columna: OFERTAR, Tipo: SI_NO_NO                       
Columna: CODIGO_BARRAS, Tipo: NOMBRE_CORTO                   
Columna: DESCRIPCION, Tipo: NOMBRE_CORTO                   
Columna: ID_TIPO_PRODUCTO, Tipo: ENTERO                         
Columna: ID_MARCA_PRODUCTO, Tipo: ENTERO                         
Columna: ID_PRODUCTO_SEXO, Tipo: ENTERO                         

Estructura de la tabla Firebird 'MOVIMIENTO':
Columna: FECHA, Tipo: FECHA                          
Columna: ID_VENDEDOR, Tipo: ENTERO                         
Columna: ID_MOVIMIENTO, Tipo: ENTERO                         
Columna: ENVIADO, Tipo: SI_NO_NO                       
Columna: ENTREGADO, Tipo: SI_NO_NO                       

Estructura de la tabla Firebird 'MOVIMIENTO_DETALLE':
Columna: PESO, Tipo: NUMERO                         
Columna: PRECIO3, Tipo: NUMERO                         
Columna: PRECIO2, Tipo: NUMERO                         
Columna: PRECIO1, Tipo: NUMERO                         
Columna: CANT_DEVUELTO, Tipo: ENTERO                         
Columna: CANTIDAD, Tipo: ENTERO                         
Columna: ID_PRODUCTO, Tipo: ENTERO                         
Columna: ID_MOVIMIENTO, Tipo: ENTERO                         
Columna: ID_MOVIMIENTO_DETALLE, Tipo: ENTERO                         
Columna: CODIGO_BARRAS, Tipo: NOMBRE_CORTO                   
Columna: DEVUELTO, Tipo: SI_NO_NO                       

Estructura de la tabla Firebird 'RECIBO_CLIENTE':
Columna: COMISION, Tipo: NUMERO                         
Columna: TOTAL, Tipo: NUMERO                         
Columna: ID_GRUPO, Tipo: ENTERO                         
Columna: COMENTARIO, Tipo: DIRECION                       
Columna: FECHA, Tipo: RDB$510                        
Columna: ID_USUARIO, Tipo: ENTERO                         
Columna: ID_VENDEDOR, Tipo: ENTERO                         
Columna: ID_COBRANZA, Tipo: ENTERO                         
Columna: GUARDADO, Tipo: YES_NO                         
Columna: ANA_ITEMS_CLIENTES, Tipo: ENTERO                         
Columna: ANA_ITEMS_CLIENTES_COBRADO, Tipo: ENTERO                         
Columna: TOTALACOBRAR, Tipo: NUMERO                         

Estructura de la tabla Firebird 'RECIBO_CLIENTE_DETALLE':
Columna: COMSION, Tipo: NUMERO                         
Columna: MONTO, Tipo: NUMERO                         
Columna: ID_CLIENTE, Tipo: ENTERO                         
Columna: ID_COBRANZA, Tipo: ENTERO                         
Columna: ID_COBRANZA_DETALLE, Tipo: ENTERO                         
Columna: NRORECIBO, Tipo: ENTERO                         

Estructura de la tabla Firebird 'VENTA':
Columna: ID_VENTA, Tipo: ENTERO                         
Columna: ID_VENDEDOR, Tipo: ENTERO                         
Columna: ID_CLIENTE, Tipo: ENTERO                         
Columna: FECHA, Tipo: DATE                           
Columna: ID_FORMA_PAGO, Tipo: ENTERO                         
Columna: NRO_PAGARE, Tipo: ENTERO                         
Columna: COMENTARIO, Tipo: DESCRIPTION_LARGE              
Columna: METODOPAGO, Tipo: DESCRIPCION_MEDIO              
Columna: ANULADO, Tipo: SI_NO_NO                       
Columna: ID_USUARIO, Tipo: ENTERO                         

Estructura de la tabla Firebird 'PEDIDO':
Columna: ID_PEDIDO, Tipo: ENTERO                         
Columna: FECHA, Tipo: DATE                           
Columna: ID_VENDEDOR, Tipo: ENTERO                         
Columna: CANTIDAD, Tipo: NUMERO                         
Columna: PRODUCTO, Tipo: DESCRIPCION_MEDIO              
Columna: ID_CLIENTE, Tipo: ENTERO                         
Columna: ENTREGADO, Tipo: SI_NO_NO                       

Estructura de la tabla Firebird 'PREVENTA':
Columna: IDPREVENTA, Tipo: ENTERO                         
Columna: IDVENDEDOR, Tipo: ENTERO                         
Columna: FECHA, Tipo: DATE                           
Columna: CANTIDAD, Tipo: NUMERO                         
Columna: PRECIO, Tipo: NUMERO                         
Columna: ENTREGA, Tipo: NUMERO                         
Columna: CUOTA, Tipo: NUMERO                         
Columna: FORMADEPAGO, Tipo: ENTERO                         
Columna: NROCEDULA, Tipo: DESCRIPCION_CORTO              
Columna: NOMBRE, Tipo: DESCRIPTION_SHORT              
Columna: APELLIDO, Tipo: DESCRIPTION_SHORT              
Columna: CELULAR, Tipo: DESCRIPTION_SHORT              
Columna: PRODUCTO, Tipo: DESCRIPCION_MEDIO              
Columna: ID_VENTA, Tipo: ENTERO                         

Estructura de la tabla Firebird 'ALMACEN_MOVI':
Columna: ID_ALMACEN_MO, Tipo: ENTERO                         
Columna: DESCRIPCION, Tipo: DESCRIPTION_LARGE              
Columna: FECHA, Tipo: RDB$461                        
Columna: NATU, Tipo: AI                             
Columna: GUARDADO, Tipo: YES_NO                         

Estructura de la tabla Firebird 'ALMACEN_MOVI_D':
Columna: ID_DETALLE, Tipo: ENTERO                         
Columna: ID_ALMACEN_MO, Tipo: NUMERO_MEDIO                   
Columna: ID_PRODUCTO, Tipo: AI                             
Columna: CANTIDAD, Tipo: NUMERO                         
Columna: PRECIO, Tipo: NUMERO                         
Columna: SALIDA, Tipo: NUMERO                         

Estructura de la tabla Firebird 'VENTA_FICHAS':
Columna: ID_VENTA_FICHAS, Tipo: ENTERO                         
Columna: ID_VENTA1, Tipo: ENTERO                         
Columna: ACTIVA, Tipo: SI_NO_NO                       
Columna: ID_VENTA2, Tipo: ENTERO                         
Columna: ID_VENTA3, Tipo: ENTERO                         
Columna: ID_VENTA4, Tipo: ENTERO                         
Columna: FECHA, Tipo: DATE                           

Estructura de la tabla Firebird 'CUENTA_CLIENTE_1':
Columna: ID_CUENTA_CLIENTE, Tipo: NUMERO_MEDIO                   
Columna: ID_CLIENTE, Tipo: ENTERO                         
Columna: ID_COMPROBANTE, Tipo: NUMERO_MEDIO                   
Columna: NRO, Tipo: NOMBRE_CORTO                   
Columna: FECHA, Tipo: RDB$681                        
Columna: DESCRIPCION, Tipo: DESCRIPTION_SHORT              
Columna: CREDITO, Tipo: NUMERO                         
Columna: DEBITO, Tipo: NUMERO                         
Columna: VENCIMIENTO, Tipo: RDB$682                        
Columna: REFERENCIA, Tipo: NUMERO_MEDIO                   
Columna: ID_PERSONAL, Tipo: AI                             
Columna: DE_HASTA, Tipo: ALIAS                          
Columna: ID_COBRANZA_DETALLE, Tipo: ENTERO                         
Columna: ID_VENTA, Tipo: ENTERO                         

Estructura de la tabla Firebird 'VENTAMAYO':
Columna: ID_VENTAMAYO, Tipo: ENTERO                         
Columna: ID_CLIENTE, Tipo: ENTERO                         
Columna: ID_USUARIO, Tipo: ENTERO                         
Columna: ID_VENDEDOR, Tipo: ENTERO                         
Columna: FECHA, Tipo: FECHA                          
Columna: NROCOMPROBANTE, Tipo: ALIAS                          
Columna: CONFIRMADO, Tipo: SI_NO_NO                       
Columna: IMPRESO, Tipo: SI_NO_NO                       
Columna: TOTAL, Tipo: NUMERO                         
Columna: COSTO, Tipo: NUMERO                         
Columna: GANANCIA, Tipo: NUMERO                         
Columna: CONTADO, Tipo: SI_NO_NO                       
Columna: ID_PRECIO, Tipo: ENTERO                         

Estructura de la tabla Firebird 'VENTAD':
Columna: ID_VENTAD, Tipo: ENTERO                         
Columna: ID_VENTA, Tipo: ENTERO                         
Columna: ID_PRODUCTO, Tipo: ENTERO                         
Columna: CANTIDAD, Tipo: NUMERO                         
Columna: PRECIO, Tipo: NUMERO                         
Columna: COSTO, Tipo: NUMERO                         

Estructura de la tabla Firebird 'CALIFICACION':
Columna: ID_CALIFICACION, Tipo: ENTERO                         
Columna: DESCRIPCION, Tipo: NOMBRE_CORTO                   
Columna: DESDE, Tipo: ENTERO                         
Columna: HASTA, Tipo: ENTERO                         
Columna: SIMBOLO, Tipo: ALIAS                          

Estructura de la tabla Firebird 'CLIENTE_SEGUI':
Columna: ID_CLIENTE_SEGUI, Tipo: ENTERO                         
Columna: ID_CLIENTE, Tipo: ENTERO                         
Columna: ID_USUARIO, Tipo: ENTERO                         
Columna: FECHA, Tipo: FECHA                          
Columna: HORA, Tipo: HORA                           
Columna: OBSERVACION, Tipo: DESCRIPTION_LARGE              
Columna: LATITUD, Tipo: DESCRIPCION_CORTO              
Columna: LONGITUD, Tipo: DESCRIPCION_CORTO              

Estructura de la tabla Firebird 'TIPO_PRECIO':
Columna: ID_TIPO_PRECIO, Tipo: ENTERO                         
Columna: DESCRIPCION, Tipo: ALIAS                          

Estructura de la tabla Firebird 'METO_PAGO':
Columna: ID_METO_PAGO, Tipo: ENTERO                         
Columna: DESCRIPCION, Tipo: NOMBRE_CORTO                   

Estructura de la tabla Firebird 'VENTAAUX':
Columna: ID_VENTAAUX, Tipo: ENTERO                         
Columna: ID_CLIENTE, Tipo: ENTERO                         
Columna: ID_VENDEDOR, Tipo: ENTERO                         
Columna: ID_PRODUCTO, Tipo: ENTERO                         
Columna: DESCRIPCIONPRO, Tipo: NOMBRE_LARGO                   
Columna: SALDOACTUAL, Tipo: NUMERO                         
Columna: PAGOS, Tipo: NUMERO                         
Columna: MONTOCUOTA, Tipo: NUMERO                         
Columna: ID_FORMA_PAGO, Tipo: ENTERO                         
Columna: FECHA, Tipo: FECHA                          
Columna: FORMA, Tipo: ALIAS                          
Columna: NROPAGARE, Tipo: ALIAS                          

Estructura de la tabla Firebird 'PRODUCTO_PRECIO_PROVE':
Columna: ID_PRODUCTO_PRECIO_PROVE, Tipo: ENTERO                         
Columna: ID_PRODUCTO, Tipo: ENTERO                         
Columna: ID_PROVEEDOR, Tipo: ENTERO                         
Columna: PRECIO, Tipo: NUMERO                         
Columna: FECHA, Tipo: RDB$2005                       
Columna: ID_USUARIO, Tipo: ENTERO                         

Estructura de la tabla Firebird 'PROVEEDOR':
Columna: ID_PROVEEDOR, Tipo: ENTERO                         
Columna: RUC, Tipo: ALIAS                          
Columna: RAZONSOCIAL, Tipo: NOMBRE_LARGO                   
Columna: TELEFONO, Tipo: NOMBRE_CORTO                   
Columna: CELULAR, Tipo: NOMBRE_CORTO                   
Columna: DIRECCION, Tipo: MEMO                           
Columna: CONTACTO, Tipo: NOMBRE_CORTO                   
Columna: CONTACTO_DATOS, Tipo: DESCRIPCION_CORTO              

Estructura de la tabla Firebird 'COMPRAD':
Columna: ID_COMPRAD, Tipo: ENTERO                         
Columna: ID_COMPRA, Tipo: ENTERO                         
Columna: ID_PRODUCTO, Tipo: NUMERO                         
Columna: CANTIDAD, Tipo: NUMERO                         
Columna: PRECIO, Tipo: NUMERO                         

Estructura de la tabla Firebird 'COMPRA':
Columna: ID_COMPRA, Tipo: ENTERO                         
Columna: ID_USUARIO, Tipo: ENTERO                         
Columna: ID_PROVEEDOR, Tipo: ENTERO                         
Columna: FECHA, Tipo: FECHA                          
Columna: NRO_FACTURA, Tipo: ALIAS                          
Columna: RECIBIDO, Tipo: SI_NO_NO                       
Columna: CONTADO, Tipo: SI_NO_NO                       

Estructura de la tabla Firebird 'PRODUCTO_TIPO':
Columna: ID_TIPO_PRODUCTO, Tipo: ENTERO                         
Columna: DESCRIPCION, Tipo: NOMBRE_CORTO                   

Estructura de la tabla Firebird 'UCTABPERFIL':
Columna: ID_CONFIGURACION, Tipo: ENTERO                         
Columna: ID_USUARIO, Tipo: ENTERO                         
Columna: FORM, Tipo: DESCRIPTION_LARGE              
Columna: GRILLA, Tipo: NOMBRE_CORTO                   
Columna: CAMPO, Tipo: NOMBRE_LARGO                   
Columna: VISIBLE, Tipo: SI_NO_NO                       
Columna: ANCHO, Tipo: ENTERO                         
Columna: POSICION, Tipo: ENTERO                         

Estructura de la tabla Firebird 'PRODUCTO_MARCA':
Columna: ID_MARCA_PRODUCTO, Tipo: ENTERO                         
Columna: DESCRIPCION, Tipo: NOMBRE_CORTO                   

Estructura de la tabla Firebird 'CLIENTE_NOTA_CREDITO_D':
Columna: ID_NOTA_CREDITO_D, Tipo: ENTERO                         
Columna: ID_CLIENTE_NOTA_CREDITO, Tipo: ENTERO                         
Columna: ID_PRODUCTO, Tipo: ENTERO                         
Columna: CANTIDAD, Tipo: NUMERO                         
Columna: PRECIO, Tipo: NUMERO                         
Columna: COSTO, Tipo: NUMERO                         

Estructura de la tabla Firebird 'COBRANZAMOVILOBSERVACION':
Columna: ID_COBRANZAMOVILOBSERVACION, Tipo: ENTERO                         
Columna: DESCRIPCION, Tipo: DESCRIPCION_MEDIO              

Estructura de la tabla Firebird 'VENTAMADE':
Columna: COSTO, Tipo: NUMERO                         
Columna: ID_VENTAMADE, Tipo: ENTERO                         
Columna: ID_VENTAMAYO, Tipo: ENTERO                         
Columna: ID_PRODUCTO, Tipo: ENTERO                         
Columna: CANTIDAD, Tipo: NUMERO                         
Columna: UNITARIO, Tipo: NUMERO                         
Columna: DESCONTADO, Tipo: SI_NO_NO                       

Estructura de la tabla Firebird 'CLIENTE_NOTA_CREDITO':
Columna: ID_CLIENTE_NOTA_CREDITO, Tipo: ENTERO                         
Columna: ID_CLIENTE, Tipo: ENTERO                         
Columna: FECHA, Tipo: RDB$2272                       
Columna: ID_USUARIO, Tipo: ENTERO                         
Columna: COMENTARIO, Tipo: MEMO                           
Columna: GUARDADO, Tipo: SI_NO_NO                       
Columna: ACREDITADO, Tipo: SI_NO_NO                       
Columna: NRO_COMPROBANTE, Tipo: ENTERO                         

Estructura de la tabla Firebird 'CLIENTE_LLAMADA':
Columna: ID_CLIENTE_LLAMADA, Tipo: ENTERO                         
Columna: ID_CLIENTE, Tipo: ENTERO                         
Columna: FECHA, Tipo: DATE                           
Columna: HORA, Tipo: HORA                           
Columna: ID_MOTIVO_LLAMADA, Tipo: ENTERO                         
Columna: MEMO, Tipo: MEMO                           
Columna: AGENDAR, Tipo: SI_NO_NO                       
Columna: AGENDAR_FECHA, Tipo: DATE                           
Columna: TERMINADO, Tipo: SI_NO_NO                       
Columna: NUMERO, Tipo: ALIAS                          
Columna: ARCHIVO, Tipo: PICTURE                        
Columna: ID_USUARIO, Tipo: ENTERO                         

Estructura de la tabla Firebird 'PRODUCTO_SEXO':
Columna: ID_PRODUCTO_SEXO, Tipo: ENTERO                         
Columna: DESCRIPCION, Tipo: DESCRIPCION_CORTO              

Estructura de la tabla Firebird 'FORMA_PAGO':
Columna: ID_FORMA_PAGO, Tipo: ENTERO                         
Columna: DESCRIPCION, Tipo: NOMBRE_CORTO                   

Estructura de la tabla Firebird 'EVENTO':
Columna: IDUSER, Tipo: RDB$2377                       
Columna: MSG, Tipo: RDB$2378                       
Columna: DATA, Tipo: RDB$2379                       
Columna: NIVEL, Tipo: RDB$2380                       

Estructura de la tabla Firebird 'COBRANZAMOVIL':
Columna: ID_COBRANZAMOVIL, Tipo: ENTERO                         
Columna: ID_USUARIO, Tipo: ENTERO                         
Columna: ID_VENDEDOR, Tipo: ENTERO                         
Columna: FECHA, Tipo: RDB$2298                       
Columna: ID_GRUPO_CLIENTE, Tipo: ENTERO                         
Columna: CERRADO, Tipo: SI_NO_NO                       
Columna: APLICADO, Tipo: SI_NO_NO                       
Columna: PASS, Tipo: ALIAS                          
Columna: MONTOACOBRAR, Tipo: NUMERO                         
Columna: CANTIDADCLIENTE, Tipo: ENTERO                         
Columna: META, Tipo: NUMERO                         

Estructura de la tabla Firebird 'COBRANZAMOVILD':
Columna: ID_COBRANZAMOVILD, Tipo: ENTERO                         
Columna: ID_COBRANZAMOVIL, Tipo: ENTERO                         
Columna: ID_CLIENTE, Tipo: ENTERO                         
Columna: CUOTASVENCIDA, Tipo: ENTERO                         
Columna: MONTOSVENCIDO, Tipo: NUMERO                         
Columna: MONTOPAGADO, Tipo: NUMERO                         
Columna: NRORECIBO, Tipo: ALIAS                          
Columna: COBRO_LATITUD, Tipo: DESCRIPTION_SHORT              
Columna: COBRO_LONGITUD, Tipo: DESCRIPTION_SHORT              
Columna: ID_COBRANZAMOVILOBSERVACION, Tipo: ENTERO                         
Columna: PASS, Tipo: ALIAS                          
Columna: FECHAULTIMOPAGO, Tipo: FECHA                          
Columna: METODODEPAGO, Tipo: DESCRIPTION_LARGE              
Columna: HORA, Tipo: HORA                           
Columna: SALDOACTUAL, Tipo: NUMERO                         
Columna: ID_COBRANZA_DETALLE, Tipo: ENTERO                         
Columna: VENDEDORA, Tipo: DESCRIPTION_LARGE              
Columna: MONTOCUOTA, Tipo: NUMERO                         
Columna: NRO_COMPROBANTE, Tipo: NOMBRE_CORTO                   

Estructura de la tabla Firebird 'MOTIVO_LLAMADA':
Columna: ID_MOTIVO_LLAMADA, Tipo: ENTERO                         
Columna: DESCRIPCION, Tipo: NOMBRE_CORTO                   

Estructura de la tabla Firebird 'CEDULA2001':
Columna: ID_CEDULA2001, Tipo: NUMERO_REAL                    
Columna: FECHA_NACIMIENTO, Tipo: NOMBRE                         
Columna: NOMBRE, Tipo: NOMBRE                         
Columna: APELLIDO, Tipo: NOMBRE                         
Columna: DIRECCION, Tipo: DIRECCION                      

Estructura de la tabla Firebird 'PADRON':
Columna: ID_PADRON, Tipo: NUMERO_REAL                    
Columna: depar, Tipo: NOMBRE_LARGO                   
Columna: distri, Tipo: NOMBRE_LARGO                   
Columna: nro_ced, Tipo: NOMBRE_LARGO                   
Columna: cedula, Tipo: NOMBRE_LARGO                   
Columna: nombre, Tipo: NOMBRE_LARGO                   
Columna: apellido, Tipo: NOMBRE_LARGO                   
Columna: zona, Tipo: NOMBRE_LARGO                   
Columna: locali, Tipo: NOMBRE_LARGO                   

Estructura de la tabla Firebird 'UCTABRIGHTS':
Columna: UCIDUSER, Tipo: RDB$29                         
Columna: UCMODULE, Tipo: RDB$30                         
Columna: UCCOMPNAME, Tipo: RDB$31                         
Columna: UCKEY, Tipo: RDB$32                         

Estructura de la tabla Firebird 'PRODUCTO':
Columna: BARRAS, Tipo: NOMBRE                         
Columna: DESCRIPCION, Tipo: NOMBRE_LARGO                   
Columna: MARCA, Tipo: NOMBRE_CORTO                   
Columna: GRUPO, Tipo: NOMBRE_CORTO                   
Columna: SESION, Tipo: NOMBRE_CORTO                   
Columna: FAMILIA, Tipo: NOMBRE_CORTO                   
Columna: PRECIO, Tipo: NUMERO                         
Columna: IMAGEN, Tipo: FOTO                           

Estructura de la tabla Firebird 'RUC':
Columna: ID_RUC, Tipo: NUMERO_REAL                    
Columna: RUCDIGITO, Tipo: NOMBRE                         
Columna: RAZON, Tipo: DIRECCION                      

Estructura de la tabla Firebird 'UCTABRIGHTSEX':
Columna: UCIDUSER, Tipo: RDB$33                         
Columna: UCMODULE, Tipo: RDB$34                         
Columna: UCCOMPNAME, Tipo: RDB$35                         
Columna: UCFORMNAME, Tipo: RDB$36                         
Columna: UCKEY, Tipo: RDB$37                         

Estructura de la tabla Firebird 'UCTABUSERS':
Columna: UCIDUSER, Tipo: RDB$38                         
Columna: UCUSERNAME, Tipo: RDB$39                         
Columna: UCLOGIN, Tipo: RDB$40                         
Columna: UCPASSWORD, Tipo: RDB$41                         
Columna: UCPASSEXPIRED, Tipo: RDB$42                         
Columna: UCUSEREXPIRED, Tipo: RDB$43                         
Columna: UCUSERDAYSSUN, Tipo: RDB$44                         
Columna: UCEMAIL, Tipo: RDB$45                         
Columna: UCPRIVILEGED, Tipo: RDB$46                         
Columna: UCTYPEREC, Tipo: RDB$47                         
Columna: UCPROFILE, Tipo: RDB$48                         
Columna: UCKEY, Tipo: RDB$49                         

Estructura de la tabla Firebird 'RUC2017':
Columna: ID_RUC, Tipo: NUMERO_REAL                    
Columna: RUCDIGITO, Tipo: NOMBRE                         
Columna: RAZON, Tipo: DIRECCION                      
Columna: DIGITO, Tipo: NOMBRE                         

Estructura de la tabla Firebird 'USER':
Columna: ID, Tipo: ID                             
Columna: RAZON, Tipo: NOMBRE                         
Columna: CONTRASENA, Tipo: NOMBRE                         

Estructura de la tabla Firebird 'FIB$FIELDS_INFO':
Columna: TABLE_NAME, Tipo: RDB$22                         
Columna: FIELD_NAME, Tipo: RDB$23                         
Columna: DISPLAY_LABEL, Tipo: RDB$24                         
Columna: VISIBLE, Tipo: FIB$BOOLEAN                    
Columna: DISPLAY_FORMAT, Tipo: RDB$25                         
Columna: EDIT_FORMAT, Tipo: RDB$26                         
Columna: TRIGGERED, Tipo: FIB$BOOLEAN                    
Columna: DISPLAY_WIDTH, Tipo: RDB$27                         
Columna: FIB$VERSION, Tipo: RDB$28                         

Estructura de la tabla Firebird 'EMPRESA':
Columna: NOMBRE, Tipo: RDB$1                          
Columna: UBICACION, Tipo: RDB$2                          
Columna: IP, Tipo: RDB$5                          

Estructura de la tabla Firebird 'CONFIGURACION':
Columna: INI_DIRECCION, Tipo: RDB$4                          

Estructura de la tabla Firebird 'COPIA_SEGURIDAD':
Columna: HORA_BACK, Tipo: HORA                           
Columna: SERVIDOR, Tipo: NOMBRE_CORTO                   
Columna: BACK_DESTINO, Tipo: NOMBRE_LARGO                   
Columna: NOMBRE_BD, Tipo: NOMBRE_LARGO                   
Columna: ID_COPIA, Tipo: ID                             

Estructura de la tabla Firebird 'FIB$FIELDS_INFO':
Columna: FIB$VERSION, Tipo: RDB$12                         
Columna: DISPLAY_WIDTH, Tipo: RDB$11                         
Columna: TRIGGERED, Tipo: FIB$BOOLEAN                    
Columna: VISIBLE, Tipo: FIB$BOOLEAN                    
Columna: EDIT_FORMAT, Tipo: RDB$10                         
Columna: DISPLAY_FORMAT, Tipo: RDB$9                          
Columna: DISPLAY_LABEL, Tipo: RDB$8                          
Columna: FIELD_NAME, Tipo: RDB$7                          
Columna: TABLE_NAME, Tipo: RDB$6                          

Estructura de la tabla Firebird 'EMPRESA_EMAIL':
Columna: ID_EMPRESA, Tipo: ID                             
Columna: RAZON, Tipo: NOMBRE                         
Columna: DIRECCION, Tipo: DIRECCION                      
Columna: EMAIL, Tipo: NOMBRE                         
Columna: NOMBRE_SERVIDOR, Tipo: NOMBRE                         
Columna: PUERTO_SERVIDOR, Tipo: ID                             
Columna: CONTRASE_EMAIL, Tipo: NOMBRE                         

Estructura de la tabla Firebird 'GRUPO_ENVIO':
Columna: ID_GRUPO_ENVIO, Tipo: ID                             
Columna: DESCRIPCION, Tipo: DIRECCION                      

Estructura de la tabla Firebird 'CONFI_MENSAJE':
Columna: ID_CONFIGURACION, Tipo: ENTERO                         
Columna: ID_CALIFICACION, Tipo: ENTERO                         
Columna: DESCRIPCION, Tipo: NOMBRE                         
Columna: UBICACION_SONIDO, Tipo: NOMBRE_LARGO                   

Estructura de la tabla Firebird 'REPMAN_REPORTS':
Columna: REPORT_NAME, Tipo: RDB$3                          
Columna: REPORT, Tipo: RDB$13                         
Columna: REPORT_GROUP, Tipo: RDB$14                         
Columna: USER_FLAG, Tipo: RDB$15                         

Estructura de la tabla Firebird 'GRUPO_ENVIO_D':
Columna: ID_GRUPO_ENVIO_D, Tipo: ID                             
Columna: ID_GRUPO_ENVIO, Tipo: ID                             
Columna: ID_CLIENTE, Tipo: ENTERO                         

Estructura de la tabla Firebird 'REPMAN_GROUPS':
Columna: GROUP_CODE, Tipo: RDB$16                         
Columna: GROUP_NAME, Tipo: RDB$17                         
Columna: PARENT_GROUP, Tipo: RDB$18                         

Estructura de la tabla Firebird 'IMAGEN_PRODUCTO':
Columna: ID_IMAGEN_PRODUCTO, Tipo: ENTERO                         
Columna: FECHA, Tipo: FECHA                          
Columna: IMAGEN, Tipo: IMAGEN                         
Columna: ID_PRODUCTO, Tipo: ENTERO                         
Columna: DESCRIPCION, Tipo: DESCRIPCION                    

Estructura de la tabla Firebird 'IMAGEN_CLIENTE':
Columna: ID_IMAGEN_CLIENTE, Tipo: ENTERO                         
Columna: ID_CLIENTE, Tipo: ENTERO                         
Columna: FECHA, Tipo: FECHA                          
Columna: DESCRIPCION, Tipo: DESCRIPCION                    
Columna: IMAGEN, Tipo: IMAGEN                         
Columna: ID_USUARIO, Tipo: ENTERO                         

Estructura de la tabla Firebird 'IMAGEN_FINANCIERO':
Columna: ID_IMAGEN_FINANCIERO, Tipo: ENTERO                         
Columna: ID_OPERACION_FINANCIERO, Tipo: ENTERO                         
Columna: DESCRIPCION, Tipo: DESCRIPCION                    
Columna: IMAGEN, Tipo: IMAGEN                         

Estructura de la tabla Firebird 'REPMAN_REPORTS':
Columna: REPORT, Tipo: RDB$2                          
Columna: REPORT_NAME, Tipo: RDB$1                          
Columna: REPORT_GROUP, Tipo: RDB$3                          
Columna: USER_FLAG, Tipo: RDB$4                          

Estructura de la tabla Firebird 'REPMAN_GROUPS':
Columna: GROUP_CODE, Tipo: RDB$5                          
Columna: PARENT_GROUP, Tipo: RDB$7                          
Columna: GROUP_NAME, Tipo: RDB$6                          

Estructura de la tabla Firebird 'CONFIGURACION':
Columna: ID_CONFIGURACION, Tipo: ENTERO                         
Columna: DESCRIPCION, Tipo: DESCRIPCION                    
Columna: ACTIVO, Tipo: SI_NO_SI                       
Columna: ID_TIPO_CONEXION, Tipo: ENTERO                         
Columna: PROTOCOLO, Tipo: ENTERO                         
Columna: PARAMETROCONEXION, Tipo: DESCRIPCION                    
Columna: CONEXIONPING, Tipo: DESCRIPCION                    
Columna: INTERVALOAGOTADO, Tipo: ENTERO                         
Columna: INTERVALOENVIO, Tipo: ENTERO                         
Columna: INVERVALOREINTENTO, Tipo: ENTERO                         
Columna: VALIDEZMENSAJE, Tipo: ENTERO                         
Columna: CONCATENARSMS, Tipo: ENTERO                         

Estructura de la tabla Firebird 'TIPO_CONEXION':
Columna: ID_TIPO_CONEXION, Tipo: ENTERO                         
Columna: DESCRIPCION, Tipo: DESCRIPCION                    

Estructura de la tabla Firebird 'SMS':
Columna: ID_SMS, Tipo: ENTERO                         
Columna: DESTINATARIO, Tipo: NUMERODESTINATARIO             
Columna: MENSAJE, Tipo: MENSAJE                        
Columna: ENVIADO, Tipo: SI_NO_SI                       
Columna: FECHA, Tipo: FECHA                          
Columna: HORA, Tipo: HORA                           
Columna: MODULO, Tipo: ENTERO                         
Columna: REFERENCIA, Tipo: ENTERO                         
Columna: FECHAENVIADO, Tipo: FECHA                          
Columna: ID_CLIENTE, Tipo: ENTERO                         

Estructura de la tabla Firebird 'UCTABRIGHTS':
Columna: UCIDUSER, Tipo: RDB$1                          
Columna: UCMODULE, Tipo: RDB$2                          
Columna: UCCOMPNAME, Tipo: RDB$3                          
Columna: UCKEY, Tipo: RDB$4                          

Estructura de la tabla Firebird 'UCTABRIGHTSEX':
Columna: UCIDUSER, Tipo: RDB$5                          
Columna: UCMODULE, Tipo: RDB$6                          
Columna: UCCOMPNAME, Tipo: RDB$7                          
Columna: UCFORMNAME, Tipo: RDB$8                          
Columna: UCKEY, Tipo: RDB$9                          

Estructura de la tabla Firebird 'UCTABUSERS':
Columna: UCIDUSER, Tipo: RDB$10                         
Columna: UCUSERNAME, Tipo: RDB$11                         
Columna: UCLOGIN, Tipo: RDB$12                         
Columna: UCPASSWORD, Tipo: RDB$13                         
Columna: UCPASSEXPIRED, Tipo: RDB$14                         
Columna: UCUSEREXPIRED, Tipo: RDB$15                         
Columna: UCUSERDAYSSUN, Tipo: RDB$16                         
Columna: UCEMAIL, Tipo: RDB$17                         
Columna: UCPRIVILEGED, Tipo: RDB$18                         
Columna: UCTYPEREC, Tipo: RDB$19                         
Columna: UCPROFILE, Tipo: RDB$20                         
Columna: UCKEY, Tipo: RDB$21                         

Estructura de la tabla Firebird 'EMAIL':
Columna: ID_EMAIL, Tipo: ENTERO                         
Columna: EMAIL, Tipo: DESCRIPCION                    
Columna: ASUNTO, Tipo: DESCRIPCION                    
Columna: ADJUNTO, Tipo: IMAGEN                         
Columna: CONTENIDO, Tipo: MENSAJE                        
Columna: ENVIADO, Tipo: SI_NO_SI                       
Columna: FECHA, Tipo: FECHA                          
Columna: HORA, Tipo: HORA                           
Columna: MODULO, Tipo: ENTERO                         
Columna: REFERENCIA, Tipo: ENTERO                         

Estructura de la tabla Firebird 'ALDO':
Columna: NUM_ALDO, Tipo: DESCRIPCION                    

Estructura de la tabla Firebird 'SMS_ENTRADA':
Columna: ID_SMS_ENTRADA, Tipo: ENTERO                         
Columna: REMITENTE, Tipo: NUMERODESTINATARIO             
Columna: MENSAJE, Tipo: MENSAJE                        
Columna: LEIDO, Tipo: SI_NO_SI                       
Columna: FECHA, Tipo: FECHA                          
Columna: HORA, Tipo: HORA                           
Columna: ID_CLIENTE, Tipo: ENTERO                         

Estructura del archivo CSV 'D:\PADRONES\RUC\ruc 1.csv':
<class 'pandas.core.frame.DataFrame'>
Index: 65534 entries, 1;1000060-7;BENITEZ CENTURION to 65534;5635210-7;BENITEZ MARTINEZ
Data columns (total 1 columns):
 #   Column                  Non-Null Count  Dtype 
---  ------                  --------------  ----- 
 0   id_ruc;rucdigito;razon  65534 non-null  object
dtypes: object(1)
memory usage: 1024.0+ KB
None

Estructura del archivo CSV 'D:\PADRONES\RUC\ruc0.csv':
<class 'pandas.core.frame.DataFrame'>
RangeIndex: 172875 entries, 0 to 172874
Data columns (total 2 columns):
 #   Column                                  Non-Null Count   Dtype 
---  ------                                  --------------   ----- 
 0   1000000;CAÑETE GONZALEZ                 172875 non-null  object
 1    JUANA DEL CARMEN;3;CAGJ761720E;ACTIVO  160283 non-null  object
dtypes: object(2)
memory usage: 2.6+ MB
None

Estructura del archivo CSV 'D:\PADRONES\RUC\ruc1.csv':
<class 'pandas.core.frame.DataFrame'>
RangeIndex: 173054 entries, 0 to 173053
Data columns (total 2 columns):
 #   Column                         Non-Null Count   Dtype 
---  ------                         --------------   ----- 
 0   1000001;CHIR DE LOPEZ          173054 non-null  object
 1    RAQUEL;1;CIAR6422903;ACTIVO;  160490 non-null  object
dtypes: object(2)
memory usage: 2.6+ MB
None

Estructura del archivo CSV 'D:\PADRONES\RUC\ruc2.csv':
<class 'pandas.core.frame.DataFrame'>
RangeIndex: 174094 entries, 0 to 174093
Data columns (total 2 columns):
 #   Column                             Non-Null Count   Dtype 
---  ------                             --------------   ----- 
 0   1000012;PEÑA INSAURRALDE           174094 non-null  object
 1    LELI GLADYS;7;PEIL632000O;ACTIVO  161521 non-null  object
dtypes: object(2)
memory usage: 2.7+ MB
None

Estructura del archivo CSV 'D:\PADRONES\RUC\ruc3.csv':
<class 'pandas.core.frame.DataFrame'>
RangeIndex: 173757 entries, 0 to 173756
Data columns (total 2 columns):
 #   Column                                Non-Null Count   Dtype 
---  ------                                --------------   ----- 
 0   1000063;ZACARIAS MONNIN               173757 non-null  object
 1    RUBEN GUSTAVO;1;ZAMR653640V;ACTIVO;  161177 non-null  object
dtypes: object(2)
memory usage: 2.7+ MB
None

Estructura del archivo CSV 'D:\PADRONES\RUC\ruc4.csv':
<class 'pandas.core.frame.DataFrame'>
RangeIndex: 173436 entries, 0 to 173435
Data columns (total 2 columns):
 #   Column                                               Non-Null Count   Dtype 
---  ------                                               --------------   ----- 
 0   1000004;MOLINA DE TROCHE                             173436 non-null  object
 1    SANDRA ELIZABETH;6;MOTS763530\;SUSPENSION TEMPORAL  160815 non-null  object
dtypes: object(2)
memory usage: 2.6+ MB
None

Estructura del archivo CSV 'D:\PADRONES\RUC\ruc5.csv':
<class 'pandas.core.frame.DataFrame'>
RangeIndex: 173568 entries, 0 to 173567
Data columns (total 2 columns):
 #   Column                            Non-Null Count   Dtype 
---  ------                            --------------   ----- 
 0   1000025;MIZUMOTO                  173568 non-null  object
 1    TAKASHI;9;MITA662560Q;CANCELADO  160990 non-null  object
dtypes: object(2)
memory usage: 2.6+ MB
None

Estructura del archivo CSV 'D:\PADRONES\RUC\ruc6.csv':
<class 'pandas.core.frame.DataFrame'>
RangeIndex: 173244 entries, 0 to 173243
Data columns (total 2 columns):
 #   Column                              Non-Null Count   Dtype 
---  ------                              --------------   ----- 
 0   1000006;VILLASANTTI  ACOSTA         173244 non-null  object
 1    MAURICIO;2;VIAM6519216;CANCELADO;  160701 non-null  object
dtypes: object(2)
memory usage: 2.6+ MB
None

Estructura del archivo CSV 'D:\PADRONES\RUC\ruc7.csv':
<class 'pandas.core.frame.DataFrame'>
RangeIndex: 172862 entries, 0 to 172861
Data columns (total 2 columns):
 #   Column                          Non-Null Count   Dtype 
---  ------                          --------------   ----- 
 0   1000007;ROMERO GOMEZ            172862 non-null  object
 1    ALFREDO;0;ROGA652940D;ACTIVO;  160272 non-null  object
dtypes: object(2)
memory usage: 2.6+ MB
None

Estructura del archivo CSV 'D:\PADRONES\RUC\ruc8.csv':
<class 'pandas.core.frame.DataFrame'>
RangeIndex: 172789 entries, 0 to 172788
Data columns (total 2 columns):
 #   Column                                         Non-Null Count   Dtype 
---  ------                                         --------------   ----- 
 0   1000018;TRINIDAD                               172789 non-null  object
 1    SEBASTIAN;6;TISE651860P;SUSPENSION TEMPORAL;  160209 non-null  object
dtypes: object(2)
memory usage: 2.6+ MB
None

Estructura del archivo CSV 'D:\PADRONES\RUC\ruc9.csv':
<class 'pandas.core.frame.DataFrame'>
RangeIndex: 173157 entries, 0 to 173156
Data columns (total 2 columns):
 #   Column                                   Non-Null Count   Dtype 
---  ------                                   --------------   ----- 
 0   1000009;GONZALEZ FERNANDEZ               173157 non-null  object
 1    ROBERTO TRIGIDIO;7;GOFR651540U;ACTIVO;  160586 non-null  object
dtypes: object(2)
memory usage: 2.6+ MB
None

ANALIZA TODO EL DOCUMENTO Y enfócate en especial en la tarjeta, de ella depende todo el negocio y para la base de datos deberíamos centrarnos en reproducirla y tener tablas accesorias a ella, número de tarjeta, celular, cómo cédula, antecedentes, barrios, municipios, referencias, los pagos (SEM, QUIN, MENS), fechas y montos, la venta que se da en ella y los recargos, la cédula y firma del cliente y guiarme a importar todos los datos de las dbf

-- Tabla Personas (con alerta de defunción)
CREATE TABLE Personas (
    id_persona SERIAL PRIMARY KEY,
    cedula VARCHAR(20) UNIQUE NOT NULL,
    nombre VARCHAR(100) NOT NULL,
    apellido VARCHAR(100) NOT NULL,
    fecha_nacimiento DATE,
    direccion TEXT,
    departamento VARCHAR(100),
    distrito_municipio VARCHAR(100),
    barrio_localidad VARCHAR(100),
    zona VARCHAR(100),
    telefono VARCHAR(20),
    email VARCHAR(100) UNIQUE,
    fecha_defuncion DATE,  -- Campo para gestionar defunciones
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- Tabla Cédula
CREATE TABLE Cedula (
    numero_ci VARCHAR(20) PRIMARY KEY,
    nombre VARCHAR(100) NOT NULL,
    apellido VARCHAR(100) NOT NULL,
    fecha_nacimiento DATE NOT NULL,
    direccion TEXT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP NULL DEFAULT NULL
);

-- Tabla AntecedentesJudiciales
CREATE TABLE AntecedentesJudiciales (
    id_antecedente SERIAL PRIMARY KEY,
    numero_ci VARCHAR(20) REFERENCES Cedula(numero_ci),
    causa_penal TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP NULL DEFAULT NULL
);

-- Tabla para manejar afiliaciones políticas (si es necesario)
CREATE TABLE afiliaciones_politicas (
    id_afiliacion SERIAL PRIMARY KEY,
    nombre VARCHAR(100) UNIQUE
);

-- Tabla Zona
CREATE TABLE Zona (
    id_zona SERIAL PRIMARY KEY,
    id_municipio INTEGER REFERENCES Municipio(id_municipio),
    nombre_zona VARCHAR(100) UNIQUE CHARACTER SET utf8mb4,
    codigo_zona VARCHAR(10) UNIQUE NOT NULL,
    geometria GEOGRAPHY(POLYGON, 4326)-- Datos geoespaciales para la integración GIS
);

-- Tabla Departamento
CREATE TABLE Departamento (
    id_departamento SERIAL PRIMARY KEY,
    nombre_departamento VARCHAR(100) NOT NULL,
    codigo_departamento VARCHAR(10) UNIQUE NOT NULL
);

-- Tabla Municipio
CREATE TABLE Municipio (
    id_municipio SERIAL PRIMARY KEY,
    id_departamento INTEGER REFERENCES Departamento(id_departamento),
    nombre_municipio VARCHAR(100) NOT NULL,
    codigo_municipio VARCHAR(10) UNIQUE NOT NULL
);	

-- Tabla Ubicacion
CREATE TABLE Ubicacion (
    id_ubicacion SERIAL PRIMARY KEY,
    id_vendedor INTEGER REFERENCES Vendedor(id_vendedor),
    fecha_hora TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    coordenadas GEOGRAPHY(POINT, 4326)
    latitud DECIMAL(9, 6),
    longitud DECIMAL(9, 6),
	created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP NULL DEFAULT NULL
);

-- Tabla Rutas (para integración con GIS y manejo de vendedores)
CREATE TABLE Rutas (
    id_ruta SERIAL PRIMARY KEY,
    id_vendedor INTEGER REFERENCES Vendedores(id_vendedor),
	id_vehiculo INTEGER REFERENCES Vehiculo(id_vehiculo),
	id_zona INTEGER REFERENCES Zonas(id_zona),
    fecha DATE DEFAULT CURRENT_DATE,
    coordenadas GEOGRAPHY(POINT 4326)
);

-- Tabla Clientes
CREATE TABLE Clientes (
    id_cliente SERIAL PRIMARY KEY,
    id_persona INTEGER REFERENCES Personas(id_persona),
    tarjeta VARCHAR(7) UNIQUE NOT NULL,  -- Número de tarjeta obligatorio y único
    saldo DECIMAL(10, 2) DEFAULT 0,
    tipo_pago VARCHAR(20) CHECK (tipo_pago IN ('SEM', 'QUIN', 'MENS')),
    fecha_registro DATE DEFAULT CURRENT_DATE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- Tabla Marcas
CREATE TABLE Marcas (
    id_marca SERIAL PRIMARY KEY,
    nombre VARCHAR(100) UNIQUE NOT NULL,
    año_fundacion INT
);

-- Tabla Productos
CREATE TABLE Productos (
    id_producto SERIAL PRIMARY KEY,
    codigo_barras VARCHAR(50) UNIQUE NOT NULL,
    nombre VARCHAR(100) NOT NULL,
    id_marca INTEGER REFERENCES Marcas(id_marca),
    precio_contado DECIMAL(10, 2) NOT NULL,
    precio_credito DECIMAL(10, 2) NOT NULL,
    stock INTEGER NOT NULL,
    descripcion TEXT,
    presentacion VARCHAR(50),
    volumen INT CHECK (volumen BETWEEN 5 AND 200),
    es_kit BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

--Tabla Ventas
CREATE TABLE Ventas (
    id_venta SERIAL PRIMARY KEY,
    id_cliente INTEGER REFERENCES Clientes(id_cliente),
    id_producto INTEGER REFERENCES Productos(id_producto),
    fecha DATE DEFAULT CURRENT_DATE,
    forma_pago VARCHAR(20) CHECK (forma_pago IN ('Contado', 'Crédito')),
    total DECIMAL(10, 2) NOT NULL,
    saldo DECIMAL(10, 2) DEFAULT 0,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- Tabla Vendedores
CREATE TABLE Vendedores (
    id_vendedor SERIAL PRIMARY KEY,
    nombre VARCHAR(100) NOT NULL,
    zona VARCHAR(50),
    comision DECIMAL(10, 2) DEFAULT 50000
);

-- Tabla Inventario
CREATE TABLE Inventario (
    id_inventario SERIAL PRIMARY KEY,
    id_vendedor INTEGER REFERENCES Vendedores(id_vendedor),
    id_producto INTEGER REFERENCES Productos(id_producto),
    cantidad INTEGER NOT NULL
);

-- Tabla Pagos
CREATE TABLE Pagos (
    id_pago SERIAL PRIMARY KEY,
    id_cliente INTEGER REFERENCES Clientes(id_cliente),
    id_venta INTEGER REFERENCES Ventas(id_venta),
    fecha_pago DATE DEFAULT CURRENT_DATE,
    monto DECIMAL(10, 2) NOT NULL,
    metodo_pago VARCHAR(20) CHECK (metodo_pago IN ('Efectivo', 'Tarjeta', 'Transferencia')),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

CREATE TABLE Liquidaciones (
    id_liquidacion SERIAL PRIMARY KEY,
    id_vendedor INTEGER REFERENCES Vendedores(id_vendedor),
    fecha_liquidacion DATE DEFAULT CURRENT_DATE,
    total_ventas DECIMAL(10, 2),
    comision DECIMAL(10, 2),
    total_pagar DECIMAL(10, 2),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- Tabla Detalles de Venta
CREATE TABLE Detalles_Venta (
    id_detalle SERIAL PRIMARY KEY,
    id_venta INTEGER REFERENCES Ventas(id_venta) ON DELETE CASCADE,
    id_producto INTEGER REFERENCES Productos(id_producto),
    cantidad INTEGER NOT NULL,
    precio_unitario DECIMAL(10, 2),
    subtotal DECIMAL(10, 2) GENERATED ALWAYS AS (cantidad * precio_unitario) STORED,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- Tabla Vehículos
CREATE TABLE Vehiculos (
    id_vehiculo SERIAL PRIMARY KEY,
    placa VARCHAR(20) UNIQUE NOT NULL,  -- Número de placa obligatorio y único
    marca VARCHAR(50),
    modelo VARCHAR(50),
    año INT,
    numero_motor VARCHAR(50) UNIQUE,  -- Número de motor obligatorio y único
    numero_chasis VARCHAR(50) UNIQUE, -- Número de chasis obligatorio y único
    fecha_revision DATE,  -- Fecha de última revisión técnica
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- Trigger para actualizar el stock de productos después de una venta
CREATE OR REPLACE FUNCTION actualizar_stock_producto() 
RETURNS TRIGGER AS $$
BEGIN
    IF (NEW.cantidad > (SELECT stock FROM Productos WHERE id_producto = NEW.id_producto)) THEN
        RAISE EXCEPTION 'No hay suficiente stock para este producto';
    ELSE
        UPDATE Productos 
        SET stock = stock - NEW.cantidad 
        WHERE id_producto = NEW.id_producto;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tg_actualizar_stock
AFTER INSERT ON Ventas
FOR EACH ROW
EXECUTE FUNCTION actualizar_stock_producto();

-- Trigger para actualizar el saldo de los clientes tras una venta
CREATE OR REPLACE FUNCTION actualizar_saldo_cliente() 
RETURNS TRIGGER AS $$
BEGIN
    UPDATE Clientes 
    SET saldo = saldo - NEW.total
    WHERE id_cliente = NEW.id_cliente;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tg_actualizar_saldo
AFTER INSERT ON Ventas
FOR EACH ROW
EXECUTE FUNCTION actualizar_saldo_cliente();

-- Trigger para alerta de defunción
CREATE OR REPLACE FUNCTION verificar_defuncion() 
RETURNS TRIGGER AS $$
BEGIN
    IF (NEW.fecha_defuncion IS NOT NULL) THEN
        RAISE NOTICE 'La persona con cédula % ha sido marcada como fallecida.', NEW.cedula;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tg_verificar_defuncion
AFTER INSERT OR UPDATE ON Personas
FOR EACH ROW
EXECUTE FUNCTION verificar_defuncion();

-- Trigger para actualizar el saldo de los clientes tras una venta
CREATE OR REPLACE FUNCTION actualizar_saldo_cliente() 
RETURNS TRIGGER AS $$
BEGIN
    UPDATE Clientes 
    SET saldo = saldo - NEW.total
    WHERE id_cliente = NEW.id_cliente;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger para actualizar el stock de productos después de una venta
CREATE OR REPLACE FUNCTION actualizar_stock_producto() 
RETURNS TRIGGER AS $$
BEGIN
    IF (NEW.cantidad > (SELECT stock FROM Productos WHERE id_producto = NEW.id_producto)) THEN
        RAISE EXCEPTION 'No hay suficiente stock para este producto';
    ELSE
        UPDATE Productos 
        SET stock = stock - NEW.cantidad 
        WHERE id_producto = NEW.id_producto;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tg_actualizar_stock
AFTER INSERT ON Ventas
FOR EACH ROW
EXECUTE FUNCTION actualizar_stock_producto();

CREATE TRIGGER tg_actualizar_saldo
AFTER INSERT ON Ventas
FOR EACH ROW
EXECUTE FUNCTION actualizar_saldo_cliente();

-- Trigger para alerta de defunción
CREATE OR REPLACE FUNCTION verificar_defuncion() 
RETURNS TRIGGER AS $$
BEGIN
    IF (NEW.fecha_defuncion IS NOT NULL) THEN
        RAISE NOTICE 'La persona con cédula % ha sido marcada como fallecida.', NEW.cedula;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tg_verificar_defuncion
AFTER INSERT OR UPDATE ON Personas
FOR EACH ROW
EXECUTE FUNCTION verificar_defuncion();

CREATE OR REPLACE FUNCTION verificar_defuncion() 
RETURNS TRIGGER AS $$
BEGIN
    IF (NEW.fecha_defuncion IS NOT NULL) THEN
        RAISE NOTICE 'La persona con cédula % ha sido marcada como fallecida.', NEW.cedula;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

Triggers de actualización de stock y saldo
-- Trigger para actualizar el stock de productos después de una venta
CREATE OR REPLACE FUNCTION actualizar_stock_producto() 
RETURNS TRIGGER AS $$
BEGIN
    IF (NEW.cantidad > (SELECT stock FROM Productos WHERE id_producto = NEW.id_producto)) THEN
        RAISE EXCEPTION 'No hay suficiente stock para este producto';
    ELSE
        UPDATE Productos 
        SET stock = stock - NEW.cantidad 
        WHERE id_producto = NEW.id_producto;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tg_actualizar_stock
AFTER INSERT ON Ventas
FOR EACH ROW
EXECUTE FUNCTION actualizar_stock_producto();


CREATE TRIGGER tg_verificar_defuncion
AFTER INSERT OR UPDATE ON Personas
FOR EACH ROW
EXECUTE FUNCTION verificar_defuncion();

CREATE INDEX idx_clientes_tarjeta ON Clientes(tarjeta);

Índice en la tabla Ventas para buscar ventas por cliente y fecha
CREATE INDEX idx_ventas_cliente_fecha ON Ventas(id_cliente, fecha);

Índice en la tabla Productos para código de barras
CREATE INDEX idx_productos_codigo_barras ON Productos(codigo_barras);

Índice en la tabla Pagos para rastrear pagos recientes por cliente
CREATE INDEX idx_pagos_cliente_fecha ON Pagos(id_cliente, fecha_pago);

Índice en la tabla Detalles_Venta para mejorar las consultas entre ventas y productos
CREATE INDEX idx_detalles_venta ON Detalles_Venta(id_venta, id_producto);

Índice en la tabla Liquidaciones para optimizar consultas de liquidaciones por vendedor
CREATE INDEX idx_liquidaciones_vendedor_fecha ON Liquidaciones(id_vendedor, fecha_liquidacion);

en la interfaz debe tener la opción de ingresar pagos de distintas fechas (ejemplo
01-01-2021	50.000	210000 (calcula el saldo del monto de la venta)
08-01-2021	20.000	190000
22-01-2021	20.000	170000

background-color: #f4f4f4;
background-color: #fff;
background-color: #007bff;
color: #fff;
background-color: #6c757d;
background-color: #f9f9f9;
color: red;

¡Buenas noches! Con mucho gusto, te ayudaré a reconocer los colores que mencionaste:

Background-color:

    #f4f4f4: Gris claro, casi blanco.
    #fff: Blanco puro.
    #007bff: Azul claro, similar al cielo.
    #6c757d: Gris oscuro, casi negro.
    #f9f9f9: Gris muy claro, casi blanco.

Color:

    #fff: Blanco puro.
    red: Rojo intenso.

Color	CMYK (C, M, Y, K)	RGB (R, G, B)	Hexadecimal
Rojo puro	0, 100, 100, 0	255, 0, 0	#FF0000
Verde puro	100, 0, 100, 0	0, 255, 0	#00FF00
Azul puro	100, 100, 0, 0	0, 0, 255	#0000FF
Negro puro	0, 0, 0, 100	0, 0, 0	#000000
Blanco puro	0, 0, 0, 0	255, 255, 255	#FFFFFF
Verde menta claro	#B7F5A5	183, 245, 165
Verde agua pastel	#7FFFD4	127, 255, 212
Verde pistacho	#93C572	147, 197, 114

Touring y Automovil Club Paraguayo
https://twitter.com/touringpy
https://www.facebook.com/TouringyAutomovilClubParaguayo
https://www.instagram.com/tacpy
https://www.youtube.com/channel/UCLvCWyje8juRw0AUhY8aUog
25 de Mayo 1086 esq. Brasil
R.A. (021) 217 0000<br>

Líneas de auxilio:
(021)2170300
*822 Tigo
*823 Personal
Asuncion - Paraguay

id_ruc	rucdigito	razon
1	1000060-7	BENITEZ CENTURION, CARLOS ADAN
1000000	CAÑETE GONZALEZ, JUANA DEL CARMEN	3	CAGJ761720E	ACTIVO


"E:\takeout-20241016T130623Z-001\Takeout\Historial de ubicaciones (Rutas)\Records.json"
{
  "locations": [{
    "latitudeE7": -254591267,
    "longitudeE7": -560321401,
    "accuracy": 1899,
    "activity": [{
      "activity": [{
        "type": "STILL",
        "confidence": 100
      }],
      "timestamp": "2017-08-06T19:59:00.117Z"
    }, {
      "activity": [{
        "type": "STILL",
        "confidence": 100
      }],
      "timestamp": "2017-08-06T19:56:59.057Z"
    }, {
      "activity": [{
        "type": "STILL",
        "confidence": 100
      }],
      "timestamp": "2017-08-06T19:54:50.327Z"
    }, {
      "activity": [{
        "type": "STILL",
        "confidence": 100
      }],
      "timestamp": "2017-08-06T19:52:49.247Z"
    }, {
      "activity": [{
        "type": "STILL",
        "confidence": 100
      }],
      "timestamp": "2017-08-06T19:50:55.907Z"

 }, {
    "latitudeE7": -254548985,
    "longitudeE7": -560356753,
    "accuracy": 9,
    "velocity": 0,
    "heading": 220,
    "altitude": 358,
    "verticalAccuracy": 8,
    "source": "GPS",
    "deviceTag": 1150512184,
    "platformType": "ANDROID",
    "osLevel": 33,
    "serverTimestamp": "2024-10-16T10:44:36.159Z",
    "deviceTimestamp": "2024-10-16T10:44:35.197Z",
    "batteryCharging": false,
    "formFactor": "PHONE",
    "timestamp": "2024-10-16T10:43:19.843Z"
  }, {
    "latitudeE7": -254548989,
    "longitudeE7": -560356757,
    "accuracy": 7,
    "velocity": 0,
    "heading": 219,
    "altitude": 358,
    "verticalAccuracy": 12,
    "source": "GPS",
    "deviceTag": 1150512184,
    "platformType": "ANDROID",
    "osLevel": 33,
    "serverTimestamp": "2024-10-16T10:44:36.159Z",
    "deviceTimestamp": "2024-10-16T10:44:35.197Z",
    "batteryCharging": false,
    "formFactor": "PHONE",
    "timestamp": "2024-10-16T10:43:47.872Z"
  }, {
    "latitudeE7": -254548989,
    "longitudeE7": -560356756,
    "accuracy": 7,
    "velocity": 0,
    "heading": 220,
    "altitude": 358,
    "verticalAccuracy": 11,
    "source": "GPS",
    "deviceTag": 1150512184,
    "platformType": "ANDROID",
    "osLevel": 33,
    "serverTimestamp": "2024-10-16T10:44:36.159Z",
    "deviceTimestamp": "2024-10-16T10:44:35.197Z",
    "batteryCharging": false,
    "formFactor": "PHONE",
    "timestamp": "2024-10-16T10:44:15.881Z"
  }, {
    "latitudeE7": -254548987,
    "longitudeE7": -560356755,
    "accuracy": 6,
    "velocity": 0,
    "heading": 219,
    "altitude": 358,
    "verticalAccuracy": 10,
    "source": "GPS",
    "deviceTag": 1150512184,
    "platformType": "ANDROID",
    "osLevel": 33,
    "serverTimestamp": "2024-10-16T10:44:36.529Z",
    "deviceTimestamp": "2024-10-16T10:44:35.887Z",
    "batteryCharging": false,
    "formFactor": "PHONE",
    "timestamp": "2024-10-16T10:44:34.900Z"
  }, {
    "latitudeE7": -254548985,
    "longitudeE7": -560356753,
    "accuracy": 6,
    "velocity": 0,
    "heading": 220,
    "altitude": 358,
    "verticalAccuracy": 10,
    "source": "GPS",
    "deviceTag": 1150512184,
    "platformType": "ANDROID",
    "osLevel": 33,
    "serverTimestamp": "2024-10-16T10:44:36.930Z",
    "deviceTimestamp": "2024-10-16T10:44:36.293Z",
    "batteryCharging": false,
    "formFactor": "PHONE",
    "timestamp": "2024-10-16T10:44:35.898Z"
  }]
}

ABCDEFGHIJKLMNÑOPQRSTUVWXYZ
AEIOU

Se busca desarrollar una aplicación para gestionar un negocio de venta de perfumes a domicilio. La aplicación debe:

    Gestionar rutas de venta: Definidas en un archivo JSON y asignadas por día.
    Controlar inventario: Con un sistema de códigos de barras y reposición diaria.
    Administrar clientes: Con tarjetas personalizadas que funcionan como contrato y pagaré.
    Realizar ventas: Con registro detallado de productos, formas de pago y cuotas.
    Generar reportes: Para analizar ventas, clientes y estado de cuenta.
    Tener una interfaz intuitiva: Con colores y diseño de marca.

Puntos Clave y Mejoras Sugeridas:

    Estructura de Datos:
        Base de Datos:
            Clientes: Cédula, nombre, apellidos, dirección, teléfono, RUC, antecedentes judiciales, tarjetas asociadas.
            Productos: Código de barras, nombre, precio, categoría.
            Ventas: Fecha, cliente, producto, cantidad, precio, forma de pago, cuotas, estado.
            Rutas: Zona, ciudades, barrios, clientes asignados.
            Inventarios: Producto, cantidad, fecha de ingreso.
        Archivo JSON:
            Rutas: Zona, ciudades, barrios, coordenadas GPS (para futuras funcionalidades de geolocalización).
            Productos: Código de barras, nombre, precio, categoría, imagen.

    Funcionalidades:
        Módulo de Ventas:
            Creación de tarjetas: Automatización de campos, cálculo de cuotas, impresión.
            Registro de ventas: Captura de datos del cliente, selección de productos, cálculo de total, generación de recibo.
            Gestión de pagos: Registro de pagos, actualización de saldos, envío de notificaciones.
        Módulo de Inventario:
            Ingreso de productos: Lectura de código de barras, actualización de stock.
            Reposición de productos: Generación de pedidos de compra.
        Módulo de Clientes:
            Búsqueda de clientes: Por cédula, nombre, teléfono.
            Historial de compras: Detalle de todas las compras realizadas.
            Estado de cuenta: Saldo actual, cuotas pendientes.
        Módulo de Reportes:
            Ventas por producto: Top 10, categorías.
            Ventas por vendedor: Comisiones generadas.
            Clientes más activos: Frecuencia de compra, monto total.
            Estado de cuenta por cliente: Detalle de pagos y saldos.

    Interfaz de Usuario:
        Diseño responsivo: Adaptación a diferentes dispositivos (móvil, tablet, PC).
        Intuitiva y fácil de usar: Menús claros, botones grandes, ayuda en línea.
        Personalizable: Temas, colores, accesos directos.
        Integración de mapas: Visualización de rutas, ubicación de clientes.

    Tecnología:
        Backend: Node.js, Python (Django o Flask), PHP (Laravel).
        Base de datos: PostgreSQL, MySQL.
        Frontend: React, Vue.js, Angular.
        Móvil: React Native, Flutter.
        Cloud: AWS, Google Cloud, Azure.

Prompt Mejorado:

    Desarrollar una aplicación web y móvil para gestionar un negocio de venta de perfumes a domicilio. La app debe permitir:

        Registro de ventas: Con tarjetas personalizadas, cálculo de cuotas y pagos.
        Gestión de inventario: Con control de stock y reposición.
        Administración de clientes: Con búsqueda, historial de compras y estado de cuenta.
        Optimización de rutas: Basada en un archivo JSON con coordenadas GPS.
        Generación de reportes: Para analizar ventas, clientes y productos.

    La interfaz debe ser intuitiva y responsiva, con los colores y tipografía de la marca. La base de datos debe incluir tablas para clientes, productos, ventas, rutas e inventario. Se requiere integración con un sistema de pagos y notificaciones.

    Consideraciones adicionales:

        Seguridad: Encriptación de datos, control de acceso. Escalabilidad: Diseño para un crecimiento futuro del negocio. Integración: Con sistemas de contabilidad y gestión empresarial. Mantenibilidad: Código limpio y documentado.

Próximos Pasos:

    Diseño detallado: Diagramas de flujo, wireframes, maquetas.
    Desarrollo backend: Creación de la API, conexión a la base de datos.
    Desarrollo frontend: Diseño de la interfaz, implementación de funcionalidades.
    Pruebas: Unitarias, de integración, de usuario.
    Implementación: Despliegue en producción.
    Mantenimiento: Actualizaciones, soporte técnico.