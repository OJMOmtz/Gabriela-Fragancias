ALTER TABLE gf.distrito ADD CONSTRAINT unique_dpto_distrito UNIQUE (dpto, distrito);
created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
deleted_at TIMESTAMP NULL DEFAULT NULL

ALTER TABLE gf.distrito ADD CONSTRAINT unique_distrito_columna UNIQUE (columna_referenciada);

CREATE TRIGGER update_usuario_timestamp
    BEFORE UPDATE ON gf.usuario
    FOR EACH ROW
    EXECUTE FUNCTION gf.update_timestamp();
	
CREATE TRIGGER update_distrito_timestamp
    BEFORE UPDATE ON gf.distrito
    FOR EACH ROW
    EXECUTE FUNCTION gf.update_timestamp();


-- Database: Gabriela Fragancias

-- DROP DATABASE IF EXISTS "Gabriela Fragancias";

CREATE DATABASE "Gabriela Fragancias"
    WITH
    OWNER = postgres
    ENCODING = 'UTF8'
    LC_COLLATE = 'Spanish_Paraguay.1252'
    LC_CTYPE = 'Spanish_Paraguay.1252'
    LOCALE_PROVIDER = 'libc'
    TABLESPACE = pg_default
    CONNECTION LIMIT = -1
    IS_TEMPLATE = False;
	
-- Esquema principal
CREATE SCHEMA gf;

--Creación de la Base de Datos
CREATE DATABASE Gabriela_Fragancias;

--Tabla Empresa
CREATE TABLE gf.empresa (
    id_empresa SERIAL PRIMARY KEY,
    ruc VARCHAR(20) UNIQUE NOT NULL,
    razon_social VARCHAR(100) NOT NULL
);

-- Tabla Usuario
CREATE TABLE gf.usuario (
    id_usuario SERIAL PRIMARY KEY,
    nombre VARCHAR(100) NOT NULL,
    apellido VARCHAR(100) NOT NULL,
    cedula VARCHAR(20) UNIQUE NOT NULL,
    email VARCHAR(100) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP NULL DEFAULT NULL
);

-- Extensión para funcionalidades geoespaciales
CREATE EXTENSION postgis;

-- Modificación de las tablas de ubicación geográfica según INEC
-- Dominios y tipos personalizados
CREATE TYPE gf.estado_registro AS ENUM ('activo', 'inactivo', 'eliminado');
CREATE TYPE gf.tipo_pago AS ENUM ('contado', 'semanal', 'quincenal', 'mensual');
CREATE TYPE gf.estado_pago AS ENUM ('pendiente', 'pagado', 'cancelado');
CREATE DOMAIN gf.cargo_empleado AS VARCHAR(20);
CREATE TYPE gf.grupo_edad AS ENUM ('niño', 'púber', 'adolescente', 'joven', 'adulto', 'mayor');
CREATE TYPE gf.sexo AS ENUM ('M', 'F');

--Tabla Cédulas
CREATE TABLE gf.cedulas (
    numero_cedula VARCHAR(20) PRIMARY KEY,
    nombre VARCHAR(100) NOT NULL,
    apellido VARCHAR(100) NOT NULL,
    fecha_nacimiento DATE,
    sexo CHAR(1),
    direccion TEXT,
	id_barrio INTEGER REFERENCES gf.barrios_localidades(id_barrio),
	id_distrito INTEGER REFERENCES gf.distritos(id_distrito),
	id_dpto INTEGER REFERENCES gf.departamentos(id_dpto),
	id_via INTEGER REFERENCES gf.vias(id_via),
	id_prefijo INTEGER REFERENCES prefijos(id_prefijo);	
    telefono VARCHAR(20),
	lugar_nacimiento VARCHAR(100),
    fecha_defuncion DATE,
    email VARCHAR(100),
    id_ruc INTEGER REFERENCES ruc(ruc_id),
    created_at TIMESTAMP WITHOUT TIME ZONE DEFAULT (now() at time zone 'utc'),
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

--Tabla RUC
CREATE TABLE gf.ruc (
    numero_ruc VARCHAR(20) UNIQUE NOT NULL,
    razon_social VARCHAR(255),
    digito_verificador VARCHAR(255) NOT NULL,
    cedula_tributaria VARCHAR(20) UNIQUE,
    estado VARCHAR(20),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

--Tabla Antecedentes Judiciales
CREATE TABLE gf.antecedentes_judiciales (
    id_antecedente SERIAL PRIMARY KEY,
    numero_cedula VARCHAR(20) REFERENCES gf.cedulas(numero_cedula),
    causa_penal TEXT,
    fecha_causa DATE,
    unidad_procesadora VARCHAR(100),
    juez VARCHAR(100),
    estado_proceso VARCHAR(50),
    fuente VARCHAR(50)
);

-- Tabla Clientes
CREATE TABLE gf.clientes (
    id_cliente INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    tarjeta VARCHAR(5), -- este número se puede repetir en otras zonas y en la misma con otro cliente
    numero_cedula VARCHAR(20) UNIQUE NOT NULL,
    id_ruc INT REFERENCES gf.ruc(id_ruc), -- referencia a la tabla gf.ruc
    nombre VARCHAR(100) NOT NULL,
    apellido VARCHAR(100) NOT NULL,
    id_prefijo INT REFERENCES gf.prefijos(id_prefijo),
    numero_telefono VARCHAR(20),
    numero_celular VARCHAR(20),
    numero_tarjeta VARCHAR(20) UNIQUE,
    id_zona INT REFERENCES gf.zonas(id_zona),
    id_direccion INT REFERENCES gf.direcciones(id_direccion),
    direccion GEOGRAPHY(POINT, 4326),
    saldo INT DEFAULT 0,
    tipo_pago VARCHAR(20) CHECK (tipo_pago IN ('SEM', 'QUIN', 'MENS')),
    fecha_registro TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    estado VARCHAR(20) CHECK (estado IN ('activo', 'inactivo')) DEFAULT 'activo',
    ultimo_inicio_sesion TIMESTAMP WITH TIME ZONE
);

-- Tabla de Empleados
CREATE TABLE gf.empleados (
    id_empleado SERIAL PRIMARY KEY,
    cedula VARCHAR(20) UNIQUE,
    nombre VARCHAR(100) NOT NULL,
    apellido VARCHAR(100) NOT NULL,
    telefono VARCHAR(20),
    zona VARCHAR(50),
    cargo VARCHAR(50) CHECK (cargo IN ('Vendedor', 'Cobrador', 'Chofer')),
    fecha_contratacion DATE,
    salario INTEGER,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP NULL DEFAULT NULL
);


CREATE TABLE gf.zonas (
    id_zona SERIAL PRIMARY KEY,
    nombre VARCHAR(50) UNIQUE,
    id_distrito INTEGER REFERENCES gf.distritos(id_distrito)
);

INSERT INTO gf.zonas (nombre, id_distrito)
VALUES
    -- Zona 1
    ('Zona 1', 13),  -- ALTO PARANÁ, SANTA RITA
    ('Zona 1', 14),  -- ALTO PARANÁ, NARANJAL
    ('Zona 1', 18),  -- ALTO PARANÁ, SAN ALBERTO
    ('Zona 1', 21),  -- ALTO PARANÁ, TAVAPY
    -- Zona 2
    ('Zona 2', 4),   -- ALTO PARANÁ, DR. JUAN LEÓN MALLORQUÍN
    ('Zona 2', 7),   -- ALTO PARANÁ, JUAN E. O'LEARY
    ('Zona 2', 9),   -- ALTO PARANÁ, YGUAZÚ
    ('Zona 2', 11),  -- ALTO PARANÁ, MINGA GUAZÚ
    -- Zona 3
    ('Zona 3', 1),   -- GUAIRÁ, VILLARRICA
    ('Zona 3', 3),   -- GUAIRÁ, CAPITÁN MAURICIO JOSÉ TROCHE
    ('Zona 3', 6),   -- GUAIRÁ, GRAL. EUGENIO A. GARAY
    ('Zona 3', 11),  -- GUAIRÁ, MBOCAYATY
    ('Zona 3', 12),  -- GUAIRÁ, NATALICIO TALAVERA
    ('Zona 3', 15),  -- GUAIRÁ, YATAITY
    -- Zona 4
    ('Zona 4', 1),   -- PARAGUARÍ,PARAGUARÍ
	('Zona 4', 15),  -- PARAGUARÍ,YAGUARÓN
	('Zona 4', 7),   -- CENTRAL, ITÁ
	-- Zona 5
    ('Zona 5', 5),   -- CAAGUAZÚ, CORONEL OVIEDO
	
-- Tabla de Departamentos
CREATE TABLE gf.departamentos (
    id_dpto SERIAL PRIMARY KEY,
    dpto VARCHAR(2) NOT NULL,
    dpto_desc VARCHAR(20) NOT NULL
);

-- Tabla de Distritos
CREATE TABLE gf.distritos (
    id_distrito SERIAL PRIMARY KEY,
    id_dpto INTEGER REFERENCES gf.departamentos(id_dpto),
    distrito VARCHAR(2) NOT NULL,
    dist_desc VARCHAR(40) NOT NULL,
    clave VARCHAR(4) NOT NULL
);

-- Tabla de Barrios y Localidades
CREATE TABLE gf.barrios_localidades (
    id_barrio SERIAL PRIMARY KEY,
    id_distrito INTEGER REFERENCES gf.distritos(id_distrito),
    area VARCHAR(1),
    bar_loc VARCHAR(3),
    barlo_desc VARCHAR(51),
    clave VARCHAR(7)
);

-- Tabla de Vías Principales
CREATE TABLE gf.vias_principales (
    id_via SERIAL PRIMARY KEY,
    nombre VARCHAR(100),
    long_km_en NUMERIC(6),
    ruta_nro VARCHAR(2),
    ancho NUMERIC(2),
    tipo NUMERIC(2),
    long_mts NUMERIC(10)
);

-- Tabla de Vías
CREATE TABLE gf.vias (
    id_via SERIAL PRIMARY KEY,
    nombre VARCHAR(50),
    tipo NUMERIC(2),
    ancho NUMERIC(2),
    id_dpto INTEGER REFERENCES gf.departamentos(id_dpto)
);

-- Tabla de Locales de Salud
CREATE TABLE gf.locales_salud (
    id_local_salud SERIAL PRIMARY KEY,
    id_dpto INTEGER REFERENCES gf.departamentos(id_dpto),
    id_distrito INTEGER REFERENCES gf.distritos(id_distrito),
    nombre VARCHAR(50),
    ubicacion GEOGRAPHY(POINT, 4326)
);

-- Tabla de Locales Educativos
CREATE TABLE gf.locales_educativos (
    id_local_edu SERIAL PRIMARY KEY,
    id_dpto_id INTEGER REFERENCES gf.departamentos(id_dpto),
    id_distrito INTEGER REFERENCES gf.distritos(id_distrito),
    nombre VARCHAR(56),
    ubicacion GEOGRAPHY(POINT, 4326)
);

-- Tabla de Locales Policiales
CREATE TABLE gf.locales_policiales (
    id_local_policial SERIAL PRIMARY KEY,
    id_dpto INTEGER REFERENCES gf.departamentos(id_dpto),
    id_distrito INTEGER REFERENCES gf.distritos(id_distrito),
    nombre VARCHAR(51),
    ubicacion GEOGRAPHY(POINT, 4326)
);

-- Tabla Marca
CREATE TABLE gf.marca (
    id_marca SERIAL PRIMARY KEY,
    nombre VARCHAR(100) NOT NULL UNIQUE,
    descripcion TEXT,
	año_fundacion INT,
	sede TEXT,
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    estado gf.estado_registro DEFAULT 'activo'
);

-- Tabla Producto
CREATE TABLE gf.producto (
    id_producto SERIAL PRIMARY KEY,
    codigo_barras VARCHAR(50) UNIQUE NOT NULL,
    nombre VARCHAR(100) NOT NULL,
    id_marca INTEGER NOT NULL REFERENCES gf.marca(id_marca),
    descripcion TEXT,
    volumen INTEGER CHECK (volumen BETWEEN 5 AND 200),
    es_kit BOOLEAN DEFAULT FALSE,
    costo INTEGER NOT NULL,
    precio_venta_credito INTEGER NOT NULL,
    precio_venta_contado INTEGER NOT NULL,
    segmento VARCHAR(50),
    franja_etaria gf.grupo_edad,
    ocasion VARCHAR(50),
    ano_lanzamiento INTEGER,
    origen VARCHAR(50),
    perfumero VARCHAR(100),
    notas_olfativas TEXT,
    notas_salida TEXT,
    notas_corazon TEXT,
    notas_fondo TEXT,
    intensidad VARCHAR(20),
    concentracion VARCHAR(20),
    duracion VARCHAR(50),
    estilo VARCHAR(50),
    imagen_url VARCHAR(255),
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    estado gf.estado_registro DEFAULT 'activo',
    CONSTRAINT precios_validos CHECK (
        precio_venta_contado >= costo AND 
        precio_venta_credito >= precio_venta_contado
    )
);

--Tabla Tarjetas
CREATE TABLE gf.tarjetas (
    id_tarjeta SERIAL PRIMARY KEY,
    numero_tarjeta VARCHAR(7) NOT NULL,
    id_cliente INTEGER REFERENCES Clientes(id_cliente),
    id_vendedor INTEGER REFERENCES Vendedores(id_vendedor),
    id_zona INTEGER REFERENCES Zonas(id_zona),
    total_gs INTEGER NOT NULL,
    saldo INTEGER DEFAULT 0,
    forma_pago VARCHAR(20) CHECK (forma_pago IN ('SEM', 'QUIN', 'MENS')),
    estado VARCHAR(20) CHECK (estado IN ('activa', 'cancelada')) DEFAULT 'activa',
    fecha_emision DATE DEFAULT CURRENT_DATE,
    id_tarjeta_anterior INTEGER REFERENCES Tarjetas(id_tarjeta)
);

-- Tabla Kit
CREATE TABLE gf.kit (
    id_kit SERIAL PRIMARY KEY,
    id_producto INTEGER NOT NULL REFERENCES gf.producto(id_producto),
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    estado gf.estado_registro DEFAULT 'activo'
);

-- Tabla Productos_Kit
CREATE TABLE gf.producto_kit (
    id_kit INTEGER REFERENCES gf.kit(id_kit),
    id_producto INTEGER REFERENCES gf.producto(id_producto),
    cantidad INTEGER NOT NULL CHECK (cantidad > 0),
    PRIMARY KEY (id_kit, id_producto),
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    estado gf.estado_registro DEFAULT 'activo'
);

-- Tabla Inventario
CREATE TABLE gf.inventario (
    id_inventario SERIAL PRIMARY KEY,
    id_producto INTEGER NOT NULL REFERENCES gf.producto(id_producto),
    stock INTEGER NOT NULL DEFAULT 0 CHECK (stock >= 0),
    ubicacion VARCHAR(50),
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    estado gf.estado_registro DEFAULT 'activo'
);

-- Tabla Venta
CREATE TABLE gf.venta (
    id_venta SERIAL PRIMARY KEY,
    id_cliente INTEGER NOT NULL REFERENCES gf.cliente(id_cliente),
    id_empleado INTEGER NOT NULL REFERENCES gf.empleado(id_empleado),
    fecha_venta TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    tipo_pago gf.tipo_pago NOT NULL,
    estado gf.estado_pago DEFAULT 'pendiente',
    total INTEGER NOT NULL CHECK (total >= 0),
    entrega_inmediata BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    estado_registro gf.estado_registro DEFAULT 'activo'
);

-- Tabla Detalle_Venta
CREATE TABLE gf.detalle_venta (
    id_detalle SERIAL PRIMARY KEY,
    id_venta INTEGER NOT NULL REFERENCES gf.venta(id_venta) ON DELETE CASCADE,
    id_producto INTEGER NOT NULL REFERENCES gf.producto(id_producto) ON DELETE RESTRICT,
    cantidad INTEGER NOT NULL CHECK (cantidad > 0),
    precio_unitario INTEGER NOT NULL CHECK (precio_unitario >= 0),
    subtotal INTEGER GENERATED ALWAYS AS (cantidad * precio_unitario) STORED,
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    estado gf.estado_registro DEFAULT 'activo'
);

-- Tabla de Maletines de Vendedoras
CREATE TABLE gf.maletines (
	id_maletin SERIAL PRIMARY KEY,
    id_empleado INT REFERENCES empleados(id_empleado),
    codigo_barra VARCHAR(50) UNIQUE NOT NULL,	
    fecha_carga DATE DEFAULT CURRENT_DATE,
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMPZ NULL DEFAULT NULL
);

-- Tabla Productos de Maletines
CREATE TABLE gf.productos_maletin (
    id_maletin INT REFERENCES maletines(id_maletin),
    id_producto INT REFERENCES productos(id_producto),
    codigo_barra VARCHAR(50) UNIQUE NOT NULL,	
    cantidad INT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP,
    deleted_at TIMESTAMP NULL DEFAULT NULL,
    PRIMARY KEY (id_maletin, id_producto)
);

-- Tabla de Liquidaciones
CREATE TABLE gf.liquidaciones (
    id_liquidacion SERIAL PRIMARY KEY,
    id_empleado INT REFERENCES empleados(id_empleado),
    fecha_liquidacion DATE DEFAULT CURRENT_DATE,
    total_ventas INTEGER,
    comision INTEGER,
    total_pagar INTEGER,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP,
    deleted_at TIMESTAMP NULL DEFAULT NULL
);

--Tabla Productos Vendidos
CREATE TABLE gf.productos_vendidos (
    id_producto_vendido SERIAL PRIMARY KEY,
    id_tarjeta INTEGER REFERENCES Tarjetas(id_tarjeta),
    id_producto INTEGER REFERENCES Productos(id_producto),
    cantidad INTEGER CHECK (cantidad > 0),
    precio INTEGER
);

-- Tabla Pago
CREATE TABLE gf.pago (
    id_pago SERIAL PRIMARY KEY,
    id_venta INTEGER NOT NULL REFERENCES gf.venta(id_venta),
    id_tarjeta INTEGER REFERENCES Tarjetas(id_tarjeta),	
    monto INTEGER NOT NULL CHECK (monto > 0),
    saldo_restante INTEGER NOT NULL,
    entrega_inicial BOOLEAN DEFAULT FALSE,
    recargo BOOLEAN DEFAULT FALSE,	
    fecha_pago TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    estado gf.estado_registro DEFAULT 'activo'
);

-- Tabla Vehículo
CREATE TABLE gf.vehiculo (
    id_vehiculo SERIAL PRIMARY KEY,
    clave INT,
    placa VARCHAR(20) UNIQUE NOT NULL,
    marca_id INT,
    modelo_id INT,
    tipo_vehiculo_id INT,
    color VARCHAR(50) NOT NULL,
    motor VARCHAR(50) NOT NULL,
    chassis VARCHAR(50) NOT NULL,
    año INTEGER NOT NULL,
    tipo_documento VARCHAR(50),
    cedula INT,
    titulo VARCHAR(50),
	km_recorridos INTEGER,
    ultima_revision DATE,
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    estado gf.estado_registro DEFAULT 'activo',
    FOREIGN KEY (marca_id) REFERENCES gf.marca(id_marca),
    FOREIGN KEY (modelo_id) REFERENCES gf.modelo(id_modelo),
    FOREIGN KEY (tipo_vehiculo_id) REFERENCES gf.tipo_vehiculo(id_tipo_vehiculo)
);

-- Tabla Modelo
CREATE TABLE gf.modelo (
    id_modelo SERIAL PRIMARY KEY,
    id_marca INTEGER REFERENCES gf.marca(id_marca),
    nombre VARCHAR(100) NOT NULL,
    año INTEGER,
    estado gf.estado_registro DEFAULT 'activo'
);

-- Tabla Tipo de Vehiculo
CREATE TABLE gf.tipo_vehiculo (
    id_tipo_vehiculo SERIAL PRIMARY KEY,
    nombre VARCHAR(50) NOT NULL,
    descripcion TEXT,
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    estado gf.estado_registro DEFAULT 'activo'
);

-- Tabla Color de Vehiculo
CREATE TABLE gf.autocolor (
  codigo INT,
  xxx VARCHAR,
  color VARCHAR
);

-- Tabla Marca de Vehiculo
CREATE TABLE gf.automarca (
    codigo INT PRIMARY KEY,
    xxx VARCHAR(50),
    marca VARCHAR(50)
);


-- Tabla Origen de Vehiculo
CREATE TABLE gf.nacionalidades (
    clave INT PRIMARY KEY,
    descri VARCHAR(50)
);

-- Tabla Tracking_GPS
CREATE TABLE gf.tracking_gps (
    id_tracking SERIAL PRIMARY KEY,
    id_vehiculo INTEGER NOT NULL REFERENCES gf.vehiculo(id_vehiculo),
    ubicacion GEOGRAPHY(POINT, 4326) NOT NULL,
    fecha_hora TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    estado gf.estado_registro DEFAULT 'activo'
);

-- Tabla Rutas
CREATE TABLE gf.rutas (
    id SERIAL PRIMARY KEY,
    id_vendedor INTEGER REFERENCES Vendedores(id_vendedor),
    id_vehiculo INTEGER REFERENCES vehiculos(id_vehiculo),
    fecha DATE NOT NULL,
    inicio_ruta GEOGRAPHY(POINT, 4326),
    fin_ruta GEOGRAPHY(POINT, 4326),
    distancia_km DECIMAL(10,2),
    tiempo_estimado INTEGER, -- minutos
    tiempo_real INTEGER,
    estado VARCHAR(20) CHECK (estado IN ('planificada', 'en_progreso', 'completada', 'cancelada')),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Tabla Puntos Ruta
CREATE TABLE gf.puntos_ruta (
    id SERIAL PRIMARY KEY,
    ruta_id INTEGER REFERENCES rutas(id),
    id_cliente INTEGER REFERENCES clientes(id_cliente),
    orden INTEGER NOT NULL,
    hora_planificada TIME,
    hora_real TIME,
    ubicacion GEOGRAPHY(POINT, 4326),
    estado VARCHAR(20) CHECK (estado IN ('pendiente', 'visitado', 'no_visitado', 'reprogramado')),
    notas TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Tabla de Proveedores
CREATE TABLE gf.proveedores (
    id_proveedor SERIAL PRIMARY KEY,
    ruc VARCHAR(20) UNIQUE,
    nombre VARCHAR(100) NOT NULL,
    direccion TEXT,
    telefono VARCHAR(20),
    email VARCHAR(100)
);

-- Tabla de Compras a Proveedores
CREATE TABLE gf.compras_proveedores (
    id_compra SERIAL PRIMARY KEY,
    id_proveedor INT REFERENCES proveedores(id_proveedor),
    fecha_compra DATE DEFAULT CURRENT_DATE,
    total INTEGER,
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP NULL DEFAULT NULL
);

-- Tabla de Detalles de Compra
CREATE TABLE gf.detalles_compra (
    id_detalle SERIAL PRIMARY KEY,
    id_compra INT REFERENCES compras_proveedores(id_compra),
    id_producto INT REFERENCES productos(id_producto),
    cantidad INT,
    precio_unitario INTEGER,
    subtotal INTEGER,
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP NULL DEFAULT NULL
);

-- Índices
CREATE INDEX idx_persona_cedula ON gf.persona(cedula);
CREATE INDEX idx_cliente_ruc ON gf.cliente(ruc);
CREATE INDEX idx_producto_codigo ON gf.producto(codigo_barras);
CREATE INDEX idx_venta_fecha ON gf.venta(fecha_venta);
CREATE INDEX idx_pago_fecha ON gf.pago(fecha_pago);
CREATE INDEX idx_tracking_fecha ON gf.tracking_gps(fecha_hora);

-- Índices normales para columnas de texto
CREATE INDEX idx_barrios_localidades_barlo_desc ON gf.barrios_localidades (barlo_desc);
CREATE INDEX idx_comunidades_indigenas_barlo_desc ON gf.comunidades_indigenas (barlo_desc);
CREATE INDEX idx_clientes_direccion ON gf.clientes (direccion);

-- Índices espaciales para columnas de ubicación
CREATE INDEX idx_locales_salud_ubicacion ON gf.locales_salud USING GIST (ubicacion);
CREATE INDEX idx_locales_educativos_ubicacion ON gf.locales_educativos USING GIST (ubicacion);
CREATE INDEX idx_locales_policiales_ubicacion ON gf.locales_policiales USING GIST (ubicacion);

-- Índice para la columna de fecha de último inicio de sesión
CREATE INDEX idx_clientes_ultimo_inicio_sesion ON gf.clientes (ultimo_inicio_sesion);

-- Índices para subcadenas del código de barras
CREATE INDEX idx_productos_codigo_barras_inicio ON gf.productos (LEFT(codigo_barras, 3));
CREATE INDEX idx_productos_codigo_barras_fin ON gf.productos (RIGHT(codigo_barras, 3));

-- Función para actualizar timestamps
CREATE OR REPLACE FUNCTION gf.update_timestamp()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger para actualizar timestamps
CREATE TRIGGER update_timestamp
    BEFORE UPDATE ON gf.persona
    FOR EACH ROW
    EXECUTE FUNCTION gf.update_timestamp();

-- Repetir para todas las tablas que necesiten actualización de timestamp

-- Índices para optimizar búsquedas geográficas
CREATE INDEX idx_departamento_geometria ON gf.departamento USING GIST (geometria);
CREATE INDEX idx_distrito_geometria ON gf.distrito USING GIST (geometria);
CREATE INDEX idx_barrio_geometria ON gf.barrio_localidad USING GIST (geometria);

-- Índices para búsquedas por código
CREATE INDEX idx_distrito_clave ON gf.distrito(clave);
CREATE INDEX idx_barrio_clave ON gf.barrio_localidad(clave);

-- Función para obtener la ubicación completa
CREATE OR REPLACE FUNCTION gf.obtener_ubicacion_completa(
    p_dpto CHAR(2),
    p_distrito CHAR(2),
    p_bar_loc CHAR(3)
)
RETURNS TABLE (
    departamento VARCHAR(100),
    distrito VARCHAR(100),
    barrio_localidad VARCHAR(100),
    area CHAR(1)
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        b.dpto_desc,
        b.dist_desc,
        b.barlo_desc,
        b.area
    FROM gf.barrio_localidad b
    WHERE b.dpto = p_dpto
        AND b.distrito = p_distrito
        AND b.bar_loc = p_bar_loc;
END;
$$ LANGUAGE plpgsql;

-- Función para encontrar la ubicación por coordenada
CREATE OR REPLACE FUNCTION gf.obtener_ubicacion_por_punto(
    latitud DOUBLE PRECISION,
    longitud DOUBLE PRECISION
)
RETURNS TABLE (
    dpto CHAR(2),
    distrito CHAR(2),
    bar_loc CHAR(3),
    dpto_desc VARCHAR(100),
    dist_desc VARCHAR(100),
    barlo_desc VARCHAR(100)
) AS $$
DECLARE
    punto GEOGRAPHY;
BEGIN
    punto := ST_SetSRID(ST_MakePoint(longitud, latitud), 4326)::GEOGRAPHY;
    
    RETURN QUERY
    SELECT 
        b.dpto,
        b.distrito,
        b.bar_loc,
        b.dpto_desc,
        b.dist_desc,
        b.barlo_desc
    FROM gf.barrio_localidad b
    WHERE ST_Contains(b.geometria::geometry, punto::geometry)
    LIMIT 1;
END;
$$ LANGUAGE plpgsql;

--Optimización con Índices
CREATE INDEX idx_tarjetas_cliente ON Tarjetas(id_cliente);
CREATE INDEX idx_productos_codigo_barras ON Productos(codigo_barras);
CREATE INDEX idx_pagos_fecha ON Pagos(fecha_pago);
CREATE INDEX idx_rutas_vendedor_fecha ON Rutas(id_vendedor, fecha);
CREATE INDEX idx_pagos_cliente_metodo ON Pagos(id_cliente, metodo_pago);
CREATE INDEX idx_antecedentes_cedula ON AntecedentesJudiciales(cedula);
CREATE INDEX idx_inventario_maletines_producto ON Inventario_Maletines(id_maletin, id_producto);
CREATE INDEX idx_vehiculos_motor_chasis_placa ON Vehiculos(numero_motor, numero_chasis, placa);
CREATE INDEX idx_tarjetas_numero ON Tarjetas(numero_tarjeta);
CREATE INDEX idx_maletin_empleado ON Maletines(id_empleado);
CREATE INDEX idx_liquidacion_empleado ON Liquidaciones(id_empleado);
CREATE INDEX ON barrios_localidades (barlo_desc);
CREATE INDEX ON comunidades_indigenas (barlo_desc);
CREATE INDEX idx_rutas_inicio_ruta ON rutas USING GIST (inicio_ruta);
CREATE INDEX idx_puntos_ruta_ubicacion ON puntos_ruta USING GIST (ubicacion);
CREATE INDEX idx_zonas_geom ON zonas USING GIST (geom);

-- Índices espaciales para optimizar consultas
CREATE INDEX ON barrios_localidades USING GIST (barlo_desc);
CREATE INDEX ON comunidades_indigenas USING GIST (barlo_desc);
CREATE INDEX ON locales_salud USING GIST (ubicacion);
CREATE INDEX ON locales_educativos USING GIST (ubicacion);
CREATE INDEX ON locales_policiales USING GIST (ubicacion);
CREATE INDEX idx_clientes_direccion ON Clientes USING GIST (direccion);
CREATE INDEX idx_clientes_ultimo_inicio_sesion ON Clientes (ultimo_inicio_sesion);
CREATE INDEX idx_productos_codigo_barras_inicio ON Productos (LEFT(codigo_barras, 3));
CREATE INDEX idx_productos_codigo_barras_fin ON Productos (RIGHT(codigo_barras, 3));

CREATE TRIGGER update_ultimo_inicio_sesion
BEFORE UPDATE ON Clientes
FOR EACH ROW
WHEN (NEW.estado = 'activo')
EXECUTE PROCEDURE update_ultimo_inicio_sesion();

-- Ejemplo de consulta para encontrar clientes activos en una zona específica
WITH clientes_en_zona AS (
  SELECT id_cliente
  FROM Clientes
  WHERE ST_DWithin(direccion, ST_MakePoint(-58.3816, -34.6037), 1000) -- Buscar clientes a 1 km de un punto
)
SELECT * FROM Clientes
WHERE id_cliente IN (SELECT id_cliente FROM clientes_en_zona);
CREATE OR REPLACE FUNCTION update_ultimo_inicio_sesion()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.estado = 'activo' THEN
        NEW.ultimo_inicio_sesion = CURRENT_TIMESTAMP;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_ultimo_inicio_sesion
BEFORE UPDATE ON Clientes
FOR EACH ROW
WHEN (NEW.estado = 'activo')
EXECUTE FUNCTION update_ultimo_inicio_sesion();

CREATE FUNCTION calcular_edad(fecha_nacimiento DATE)
RETURNS INTEGER AS $$
DECLARE
  edad INTEGER;
BEGIN
  SELECT AGE(CURRENT_DATE, fecha_nacimiento) INTO edad;
  RETURN edad;
END;
$$ LANGUAGE plpgsql;

--Triggers y Funciones

--Actualizar saldo del cliente
CREATE OR REPLACE FUNCTION actualizar_saldo_cliente() 
RETURNS TRIGGER AS $$
BEGIN
    UPDATE Tarjetas 
    SET saldo = saldo - NEW.monto
    WHERE id_tarjeta = NEW.id_tarjeta;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

--Trigger para actualizar saldo tras un pago:
CREATE TRIGGER tg_actualizar_saldo
AFTER INSERT ON Pagos
FOR EACH ROW
EXECUTE FUNCTION actualizar_saldo_cliente();

--Función para actualizar inventario tras una venta:
CREATE OR REPLACE FUNCTION actualizar_inventario() 
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.cantidad > (SELECT stock FROM Productos WHERE id_producto = NEW.id_producto) THEN
        RAISE EXCEPTION 'No hay suficiente stock para este producto';
    ELSE
        UPDATE Productos 
        SET stock = stock - NEW.cantidad 
        WHERE id_producto = NEW.id_producto;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

--Trigger para actualizar inventario tras una venta:
CREATE TRIGGER tg_actualizar_inventario
AFTER INSERT ON Productos_Vendidos
FOR EACH ROW
EXECUTE FUNCTION actualizar_inventario();

CREATE OR REPLACE FUNCTION actualizar_stock_maletin() RETURNS TRIGGER AS $$
BEGIN
    IF NEW.cantidad > (SELECT stock FROM Productos WHERE id_producto = NEW.id_producto) THEN
        RAISE EXCEPTION 'No hay suficiente stock';
    ELSE
        UPDATE Productos SET stock = stock - NEW.cantidad WHERE id_producto = NEW.id_producto;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

--Trigger para Actualizar Stock,
CREATE TRIGGER tg_actualizar_stock
AFTER INSERT ON Productos_Maletin
FOR EACH ROW EXECUTE FUNCTION actualizar_stock_maletin();

CREATE OR REPLACE FUNCTION actualizar_stock_producto() RETURNS TRIGGER AS $$
BEGIN
    IF (NEW.cantidad > (SELECT stock FROM Productos WHERE id_producto = NEW.id_producto)) THEN
        RAISE EXCEPTION 'No hay suficiente stock para este producto';
    ELSE
        UPDATE Productos 
        SET stock = stock - NEW.cantidad 
        WHERE id_producto = NEW.id_producto;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tg_actualizar_stock
AFTER INSERT ON DetalleVenta
FOR EACH ROW
EXECUTE FUNCTION actualizar_stock_producto();

--Trigger para Control de Stock en Maletines: Disminuye el stock de productos cuando se asignan a un maletín.

CREATE OR REPLACE FUNCTION actualizar_stock_maletin() RETURNS TRIGGER AS $$
BEGIN
    IF (NEW.cantidad > (SELECT stock FROM Productos WHERE id_producto = NEW.id_producto)) THEN
        RAISE EXCEPTION 'No hay suficiente stock para el producto %', NEW.id_producto;
    ELSE
        UPDATE Productos 
        SET stock = stock - NEW.cantidad 
        WHERE id_producto = NEW.id_producto;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tg_actualizar_stock_maletin
AFTER INSERT ON Productos_Maletin
FOR EACH ROW
EXECUTE FUNCTION actualizar_stock_maletin();

--Trigger para Actualizar Liquidación por Venta: Calcula la liquidación de la vendedora al final del día.

CREATE OR REPLACE FUNCTION calcular_liquidacion() RETURNS TRIGGER AS $$
BEGIN
	NEW.total_pagar := NEW.total_ventas * 50000;
	RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tg_calcular_liquidacion
BEFORE INSERT ON Liquidaciones
FOR EACH ROW
EXECUTE FUNCTION calcular_liquidacion();

--Trigger de antecedentes judiciales: Verificar si un cliente tiene antecedentes antes de ser registrado.

CREATE OR REPLACE FUNCTION verificar_antecedentes_judiciales() RETURNS TRIGGER AS $$
BEGIN
	IF EXISTS (SELECT 1 FROM AntecedentesJudiciales WHERE numero_ci = NEW.cedula) THEN
		RAISE NOTICE 'El cliente con cédula % tiene antecedentes judiciales', NEW.cedula;
	END IF;
	RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tg_verificar_antecedentes_judiciales
BEFORE INSERT ON Clientes
FOR EACH ROW
EXECUTE FUNCTION verificar_antecedentes_judiciales();

--Vista para Reportes de Ventas
CREATE VIEW VW_Ventas_Por_Cliente AS
SELECT 
    c.id_cliente, 
    c.nombre, 
    c.apellido, 
    COUNT(v.id_tarjeta) AS total_ventas, 
    SUM(v.total_gs) AS monto_total
FROM 
    Clientes c
JOIN 
    Tarjetas v ON c.id_cliente = v.id_cliente
GROUP BY 
    c.id_cliente;

CREATE VIEW VW_Ventas_Por_Zona AS
SELECT Z.nombre_zona, SUM(T.total_gs) AS total_ventas
FROM Zonas Z
JOIN Rutas R ON Z.id_zona = R.id_zona
JOIN Tarjetas T ON R.id_ruta = T.id_ruta
GROUP BY Z.nombre_zona;

-- 1. Corregir tipos de datos y charset
ALTER DATABASE Gabriela_Fragancias SET DEFAULT_TEXT_SEARCH_CONFIG = 'spanish';

-- 2. Agregar columnas faltantes
ALTER TABLE gf.cliente ADD COLUMN IF NOT EXISTS ultimo_inicio_sesion TIMESTAMPTZ;

-- 3. Crear índices parciales
CREATE INDEX idx_cliente_activo ON gf.cliente(id_cliente) 
WHERE estado = 'activo';

-- 4. Mejorar índices espaciales
CREATE INDEX idx_tracking_ubicacion_tiempo ON gf.tracking_gps 
USING GIST (ubicacion, fecha_hora);

-- 5. Implementar RLS
ALTER TABLE gf.cliente ENABLE ROW LEVEL SECURITY;
CREATE POLICY cliente_access_policy ON gf.cliente
    USING (id_empleado = current_user_id());

CREATE OR REPLACE FUNCTION actualizar_updated_at()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_actualizar_updated_at
BEFORE UPDATE ON gf.productos_maletin
FOR EACH ROW
EXECUTE FUNCTION actualizar_updated_at();